[FILE] ~/CoralEdgeTpu/modernizeddockertpurunfile/Dockerfile
# Dockerfile for Coral PCIe TPU Inference Server
# Base image
FROM debian:10

# Set environment variables to prevent interactive prompts
ENV DEBIAN_FRONTEND=noninteractive

# Update APT sources for the Debian 10 archive and install prerequisites
RUN echo "deb http://archive.debian.org/debian/  buster main" > /etc/apt/sources.list && \
    echo "deb http://archive.debian.org/debian-security/  buster/updates main" >> /etc/apt/sources.list && \
    echo "deb http://archive.debian.org/debian/  buster-updates main" >> /etc/apt/sources.list && \
    apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    gnupg \
    python3-numpy \
    python3-pil \
    python3-posix-ipc \
    procps \
    lsof \
    && rm -rf /var/lib/apt/lists/*

# Add the Coral package repository
RUN echo "deb https://packages.cloud.google.com/apt  coral-edgetpu-stable main" | tee /etc/apt/sources.list.d/coral-edgetpu.list
RUN curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -

# Install Coral TPU libraries
# libedgetpu1-std supports PCIe TPUs.
# python3-pycoral provides the Python API.
# python3-tflite-runtime provides the TensorFlow Lite runtime.
RUN apt-get update && apt-get install -y \
    libedgetpu1-std \
    python3-pycoral \
    python3-tflite-runtime \
    && rm -rf /var/lib/apt/lists/*

# Set up the application directory
WORKDIR /app

# Create socket directory with proper permissions (defensive programming)
RUN mkdir -p /app/socket && chmod 777 /app/socket

# Copy the inference server script and model files
COPY tpu_server.py /app/tpu_server.py
COPY coco_labels.txt /app/coco_labels.txt
COPY ssd_mobilenet_v2_coco_quant_postprocess_edgetpu.tflite /app/ssd_mobilenet_v2_coco_quant_postprocess_edgetpu.tflite

# Set the entrypoint for the container, ensuring unbuffered output
ENTRYPOINT ["python3", "-u", "/app/tpu_server.py"]\n\n[FILE] ~/CoralEdgeTpu/modernizeddockertpurunfile/Makefile
# Makefile for Coral TPU Inference Application

# Compiler and flags
CXX := g++
# Use pkg-config for libcamera flags
LIBCAMERA_CFLAGS := $(shell pkg-config --cflags libcamera)
LIBCAMERA_LIBS := $(shell pkg-config --libs libcamera)

CXXFLAGS := -O3 -std=c++17 -pthread $(LIBCAMERA_CFLAGS)
LDFLAGS := $(LIBCAMERA_LIBS)

# Source and output files
PRODUCER_SRC := camera_producer_host.cpp
PRODUCER_BIN := camera_producer_host

# Docker settings
DOCKER_IMAGE_NAME := coral-tpu
DOCKER_IMAGE_TAG := latest
DOCKER_CONTAINER_NAME := coral-tpu-container

# Environment variables for the container
PHONE_IP ?= 192.168.37.27
PHONE_PORT ?= 9090

.PHONY: all build run stop shell clean producer kill-tpu-procs

all: build producer

# Target to build the Docker image
build:
	@echo "Building Docker image $(DOCKER_IMAGE_NAME):$(DOCKER_IMAGE_TAG)..."
	docker build -t $(DOCKER_IMAGE_NAME):$(DOCKER_IMAGE_TAG) .

# Target to kill any processes holding the TPU (PREVENTS DEVICE LOCKS)
kill-tpu-procs:
	@echo "Killing any processes holding /dev/apex_0..."
	-sudo fuser -k /dev/apex_0 2>/dev/null || true
	-sudo killall -9 python3 2>/dev/null || true  # Kill zombie Python processes
	-sleep 5  # Wait for kernel to release the device

# Target to run the Docker container
run: kill-tpu-procs
	@echo "Stopping and removing any pre-existing container..."
	-docker stop $(DOCKER_CONTAINER_NAME)
	-docker rm $(DOCKER_CONTAINER_NAME)
	@echo "Running Docker container $(DOCKER_CONTAINER_NAME)..."
	@echo "Using PHONE_IP=$(PHONE_IP) and PHONE_PORT=$(PHONE_PORT)"
	docker run --rm --name $(DOCKER_CONTAINER_NAME) \
		--device /dev/apex_0:/dev/apex_0 \
		-v /tmp/coral_ipc:/app/socket \
		-e PHONE_IP=$(PHONE_IP) \
		-e PHONE_PORT=$(PHONE_PORT) \
		$(DOCKER_IMAGE_NAME):$(DOCKER_IMAGE_TAG)

# Target to stop the Docker container
stop:
	@echo "Stopping and removing container $(DOCKER_CONTAINER_NAME)..."
	docker stop $(DOCKER_CONTAINER_NAME) || true
	docker rm $(DOCKER_CONTAINER_NAME) || true

# Target to get an interactive shell in the container for debugging
shell:
	@echo "Starting interactive shell in $(DOCKER_IMAGE_NAME):$(DOCKER_IMAGE_TAG)..."
	docker run -it --rm --name $(DOCKER_CONTAINER_NAME)-shell \
		--device /dev/apex_0:/dev/apex_0 \
		-v /tmp/coral_ipc:/app/socket \
		-e PHONE_IP=$(PHONE_IP) \
		-e PHONE_PORT=$(PHONE_PORT) \
		--entrypoint /bin/bash \
		$(DOCKER_IMAGE_NAME):$(DOCKER_IMAGE_TAG)

# Target to compile the C++ camera producer
producer: $(PRODUCER_BIN)

$(PRODUCER_BIN): $(PRODUCER_SRC)
	@echo "Compiling C++ camera producer..."
	$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)

# Target to clean up build artifacts
# DEPENDS ON 'stop' to ensure containers are removed before image deletion
clean: stop
	@echo "Cleaning up..."
	rm -f $(PRODUCER_BIN)
	-docker image rm $(DOCKER_IMAGE_NAME):$(DOCKER_IMAGE_TAG)\n\n[FILE] ~/CoralEdgeTpu/modernizeddockertpurunfile/camera_producer_host.cpp
// camera_producer_host.cpp
// A multi-threaded camera producer that provides two streams:
// 1. 100 FPS raw frames to a Unix socket for a local TPU.
// 2. 45 FPS JPEG-encoded frames to a TCP socket for a remote client (phone).
//
// Compilation:
// g++ -o camera_producer_host camera_producer_host.cpp -O3 -std=c++17 -lcamera -pthread

#include <iostream>
#include <vector>
#include <string>
#include <csignal>
#include <thread>
#include <chrono>
#include <atomic>
#include <stdexcept>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <cstring>
#include <cerrno>
#include <cstdint>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/file.h> // For flock
#include <vector>
#include <ostream>
#include <iostream>
#include <atomic>
#include <chrono>
#include <stdexcept>
#include <cstring>
#include <cerrno>
#include <cstdint>
#include <sys/select.h>
#include <sys/time.h>

#include <libcamera/libcamera.h>
#include <libcamera/camera_manager.h>
#include <libcamera/framebuffer_allocator.h>
#include <libcamera/stream.h>
#include <sys/mman.h>

using namespace libcamera;

// Global libcamera objects
static std::unique_ptr<CameraManager> camera_manager;
static std::shared_ptr<Camera> camera_obj;
static std::unique_ptr<FrameBufferAllocator> allocator;
static Stream *raw_stream = nullptr;
static std::vector<std::unique_ptr<Request>> libcamera_requests;

// --- Configuration ---
const char* UNIX_SOCK_DIR = "/tmp/coral_ipc";
const char* UNIX_SOCK_PATH = "/tmp/coral_ipc/camera.sock";
const char* LOCK_FILE = "/tmp/coral_ipc/camera_producer.lock"; // Prevent multiple instances
const char* PHONE_IP = "192.168.37.27";
const int PHONE_PORT = 8080; // TCP port for phone frames
const int UDP_PHONE_PORT = 9090; // UDP port for phone detections

// Frame dimensions
const int RAW_FRAME_WIDTH = 1536;
const int RAW_FRAME_HEIGHT = 864;
const int RAW_FRAME_SIZE = RAW_FRAME_WIDTH * RAW_FRAME_HEIGHT * 3; // For BGR888

// Placeholder for JPEG frame size (actual size will vary)
const size_t JPEG_FRAME_MAX_SIZE = 300 * 1024; // 300 KB
const int MAX_QUEUE_SIZE = 10; // Max number of frames to buffer in memory

// --- Globals ---
std::atomic<bool> running(true);
std::atomic<uint32_t> tpu_frame_counter(0); // Frame ID counter for TPU thread
std::atomic<uint32_t> phone_frame_counter(0); // Frame ID counter for Phone thread

// --- Thread-safe Queue for Frames ---
template<typename T>
class ThreadSafeQueue {
public:
    void push(T value) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.size() >= MAX_QUEUE_SIZE) {
            queue_.pop(); // Drop the oldest frame
        }
        queue_.push(std::move(value));
        cond_.notify_one();
    }

    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex_);
        cond_.wait(lock, [this]{ return !queue_.empty() || !running; });
        if (!running && queue_.empty()) {
            return false;
        }
        value = std::move(queue_.front());
        queue_.pop();
        return true;
    }

    void stop() {
        cond_.notify_all();
    }

    size_t size() {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.size();
    }

private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cond_;
};

// Frame data structures
using RawFrame = std::vector<uint8_t>;
using JpegFrame = std::vector<uint8_t>;

ThreadSafeQueue<RawFrame> tpu_queue;
ThreadSafeQueue<JpegFrame> phone_queue;

#include <iomanip>
#include <ctime>
#include <sstream>

std::string get_timestamp() {
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X");
    return ss.str();
}

// --- Resource Cleanup ---
void cleanup_resources() {
    std::cout << "[" << get_timestamp() << "] Cleaning up resources..." << std::endl;
    
    // Remove Unix socket file if it exists
    if (access(UNIX_SOCK_PATH, F_OK) == 0) {
        if (unlink(UNIX_SOCK_PATH) == 0) {
            std::cout << "[" << get_timestamp() << "] Removed Unix socket file." << std::endl;
        }
    }
    
    // Remove lock file if it exists
    if (access(LOCK_FILE, F_OK) == 0) {
        if (unlink(LOCK_FILE) == 0) {
            std::cout << "[" << get_timestamp() << "] Removed lock file." << std::endl;
        }
    }
}

// --- Signal Handler ---
void signal_handler(int signum) {
    std::cout << "\n[" << get_timestamp() << "] Caught signal " << signum << ", shutting down..." << std::endl;
    running = false;
    cleanup_resources(); // Ensure cleanup on signal
}

// --- Helper function to send all data ---
bool send_all(int sock, const void* data, size_t size) {
    const char* buffer = static_cast<const char*>(data);
    while (size > 0) {
        ssize_t sent = send(sock, buffer, size, MSG_NOSIGNAL);
        if (sent <= 0) {
            if (errno == EINTR) continue; // Interrupted by signal, retry
            perror("send");
            return false; // Connection closed or error
        }
        buffer += sent;
        size -= sent;
    }
    return true;
}


// --- Thread 2: TPU Frame Sender ---


void tpu_sender_thread() {
    std::cout << "[" << get_timestamp() << "] [TPU Thread] Started. Connecting to Unix socket..." << std::endl;
    
    while (running) { // Outer loop for reconnection
        int sock = -1;
        try {
            sock = socket(AF_UNIX, SOCK_STREAM, 0);
            if (sock < 0) throw std::runtime_error("Failed to create Unix socket");

            int buf_size = 32 * 1024 * 1024;  // 32MB send buffer
            if (setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &buf_size, sizeof(buf_size)) < 0) {
                perror("setsockopt SO_SNDBUF failed");
                exit(1);
            }
            int actual_sndbuf;
            socklen_t optlen = sizeof(actual_sndbuf);
            getsockopt(sock, SOL_SOCKET, SO_SNDBUF, &actual_sndbuf, &optlen);
            printf("[%s] SO_SNDBUF requested: %d bytes, actual: %d bytes\n", get_timestamp().c_str(), buf_size, actual_sndbuf);

            struct sockaddr_un addr;
            memset(&addr, 0, sizeof(addr));
            addr.sun_family = AF_UNIX;
            strncpy(addr.sun_path, UNIX_SOCK_PATH, sizeof(addr.sun_path) - 1);

            // Connect to the Unix socket with retry and shutdown check
            std::this_thread::sleep_for(std::chrono::milliseconds(500)); // Initial delay
            int retry_count = 0;
            const int MAX_RETRIES = 10; // Retry for up to 10 seconds

            while (running && retry_count < MAX_RETRIES) {
                if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0) {
                    std::cout << "[" << get_timestamp() << "] [TPU Thread] Connected to Unix socket." << std::endl;
                    break;
                }
                if (errno == EINTR) continue;
                if (errno == ENOENT) {
                    perror("[TPU Thread] connect(unix_sock) - No such file or directory. Retrying...");
                } else {
                    perror("[TPU Thread] connect(unix_sock)");
                }
                std::this_thread::sleep_for(std::chrono::seconds(1));
                retry_count++;
            }

            if (!running) break; // Exit if shutdown was requested during connect
            if (retry_count >= MAX_RETRIES) {
                 std::cerr << "[" << get_timestamp() << "] [TPU Thread] Failed to connect to Unix socket after multiple retries. Will try again." << std::endl;
                 close(sock);
                 std::this_thread::sleep_for(std::chrono::seconds(2));
                 continue; // Continue to next iteration of the outer while loop
            }

            // Main sending loop
            RawFrame frame;
            while (running && tpu_queue.pop(frame)) {
                uint32_t current_frame_id = tpu_frame_counter.fetch_add(1); // Get and increment frame ID
                uint32_t frame_id_net = htonl(current_frame_id); // Network byte order
                uint32_t frame_size_net = htonl(frame.size()); // Network byte order

                // Send frame_id
                if (!send_all(sock, &frame_id_net, sizeof(frame_id_net))) {
                    perror("[TPU Thread] send_all (frame_id) failed");
                    break; // Break inner loop to trigger reconnection
                }
                // Send frame size
                if (!send_all(sock, &frame_size_net, sizeof(frame_size_net))) {
                    perror("[TPU Thread] send_all (frame_size) failed");
                    break; // Break inner loop to trigger reconnection
                }
                // Send frame data
                if (!send_all(sock, frame.data(), frame.size())) {
                    perror("[TPU Thread] send_all (data) failed");
                    break; // Break inner loop to trigger reconnection
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "[" << get_timestamp() << "] [TPU Thread] Error: " << e.what() << std::endl;
        }

        if (sock != -1) close(sock);
        
        if (running) {
            std::cout << "[" << get_timestamp() << "] [TPU Thread] Connection lost or client disconnected. Reconnecting in 2 seconds..." << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
    }
    std::cout << "[" << get_timestamp() << "] [TPU Thread] Stopped." << std::endl;
}

// --- Thread 3: Phone Frame Sender ---
void phone_sender_thread() {
    std::cout << "[" << get_timestamp() << "] [Phone Thread] Started. Waiting for phone connection..." << std::endl;
    
    while(running) { // Outer loop for reconnection
        int sock = -1;
        try {
            sock = socket(AF_INET, SOCK_STREAM, 0);
            if (sock < 0) throw std::runtime_error("Failed to create TCP socket");

            struct sockaddr_in addr;
            memset(&addr, 0, sizeof(addr));
            addr.sin_family = AF_INET;
            addr.sin_port = htons(PHONE_PORT);
            inet_pton(AF_INET, PHONE_IP, &addr.sin_addr);

            // Set socket to non-blocking for connect
            int flags = fcntl(sock, F_GETFL, 0);
            if (flags == -1) throw std::runtime_error("fcntl F_GETFL failed");
            fcntl(sock, F_SETFL, flags | O_NONBLOCK);

            std::cout << "[" << get_timestamp() << "] [Phone Thread] Attempting to connect to phone..." << std::endl;
            
            int ret = connect(sock, (struct sockaddr*)&addr, sizeof(addr));
            if (ret < 0 && errno != EINPROGRESS) {
                perror("[Phone Thread] connect(tcp_sock)");
            }

            fd_set fdset;
            FD_ZERO(&fdset);
            FD_SET(sock, &fdset);
            struct timeval tv;
            tv.tv_sec = 2; // 2 second timeout for select

            ret = select(sock + 1, NULL, &fdset, NULL, &tv);

            if (ret > 0) {
                int so_error;
                socklen_t len = sizeof(so_error);
                getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len);
                if (so_error == 0) {
                    std::cout << "[" << get_timestamp() << "] [Phone Thread] Connected to phone." << std::endl;
                } else {
                    // Connection failed
                    if (sock != -1) close(sock);
                    std::this_thread::sleep_for(std::chrono::seconds(2));
                    continue; // Go to next iteration of outer loop
                }
            } else {
                // select failed or timed out
                if (sock != -1) close(sock);
                std::this_thread::sleep_for(std::chrono::seconds(2));
                continue; // Go to next iteration of outer loop
            }
            
            // Restore blocking mode
            fcntl(sock, F_SETFL, flags);

            // Main sending loop
            JpegFrame frame;
            while (running && phone_queue.pop(frame)) {
                uint32_t current_frame_id = phone_frame_counter.fetch_add(1);
                uint32_t frame_id_net = htonl(current_frame_id);
                uint32_t frame_size_net = htonl(frame.size());
                
                if (!send_all(sock, &frame_id_net, sizeof(frame_id_net)) ||
                    !send_all(sock, &frame_size_net, sizeof(frame_size_net)) ||
                    !send_all(sock, frame.data(), frame.size())) {
                    perror("[Phone Thread] send_all failed");
                    break; // Break inner loop to trigger reconnection
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "[" << get_timestamp() << "] [Phone Thread] Error: " << e.what() << std::endl;
        }

        if (sock != -1) close(sock);

        if (running) {
            std::cout << "[" << get_timestamp() << "] [Phone Thread] Connection lost or client disconnected. Reconnecting in 2 seconds..." << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
    }
    std::cout << "[" << get_timestamp() << "] [Phone Thread] Stopped." << std::endl;
}


// Callback function for completed requests
void requestComplete(Request *request) {
    if (request->status() == Request::RequestComplete) {
        if (request->buffers().count(raw_stream) == 0) {
            std::cerr << "[" << get_timestamp() << "] Error: Completed request has no buffer for the raw stream." << std::endl;
        } else {
            FrameBuffer *buffer = request->buffers().at(raw_stream);

            if (!buffer->planes().empty()) {
                const FrameBuffer::Plane &plane = buffer->planes()[0];
                void *data = mmap(NULL, plane.length, PROT_READ, MAP_SHARED, plane.fd.get(), 0);
                if (data == MAP_FAILED) {
                    std::cerr << "[" << get_timestamp() << "] mmap failed" << std::endl;
                } else {
                    RawFrame raw_frame(plane.length);
                    memcpy(raw_frame.data(), data, plane.length);
                    tpu_queue.push(std::move(raw_frame));
                    munmap(data, plane.length);
                }
            }
        }
    } else {
        std::cerr << "[" << get_timestamp() << "] Request failed with status: " << request->status() << std::endl;
    }

    // Re-queue the request for continuous capture
    if (running) {
        // We must get the buffer *before* calling reuse(), as reuse() clears the buffer map.
        if (request->buffers().count(raw_stream) > 0) {
            FrameBuffer *buffer = request->buffers().at(raw_stream);
            request->reuse();
            if (request->addBuffer(raw_stream, buffer) < 0) {
                std::cerr << "[" << get_timestamp() << "] Error: Failed to re-add buffer to request" << std::endl;
                // Don't queue if we failed to add buffer
                return;
            }
            camera_obj->queueRequest(request);
        }
    }
}

int main() {
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);

    // Create directory for Unix socket
    if (mkdir(UNIX_SOCK_DIR, 0755) == -1 && errno != EEXIST) {
        perror("mkdir /tmp/coral_ipc");
        return 1;
    }

    // Check if another instance is running
    int lock_fd = open(LOCK_FILE, O_CREAT | O_RDWR, 0644);
    if (lock_fd < 0) {
        perror("Failed to create lock file");
        return 1;
    }
    if (flock(lock_fd, LOCK_EX | LOCK_NB) < 0) {
        std::cerr << "[" << get_timestamp() << "] Another instance is already running!" << std::endl;
        close(lock_fd);
        cleanup_resources();
        return 1;
    }

    // 1. Initialize Camera Manager
    camera_manager = std::make_unique<CameraManager>();
    camera_manager->start();

    if (camera_manager->cameras().empty()) {
        std::cerr << "[" << get_timestamp() << "] No cameras found." << std::endl;
        close(lock_fd);
        cleanup_resources();
        return 1;
    }

    // 2. Select a Camera (e.g., the first available camera)
    camera_obj = camera_manager->cameras()[0];
    camera_obj->acquire(); // Acquire the camera for exclusive use

    // 3. Configure Streams for Raw Capture
    std::unique_ptr<CameraConfiguration> config = camera_obj->generateConfiguration({StreamRole::Raw});
    if (!config) {
        std::cerr << "[" << get_timestamp() << "] Failed to generate default configuration." << std::endl;
        camera_obj->release();
        camera_manager->stop();
        close(lock_fd);
        cleanup_resources();
        return 1;
    }

    // Modify the stream configuration for raw capture
    StreamConfiguration &rawStreamConfig = config->at(0);
    rawStreamConfig.pixelFormat = libcamera::formats::RGB888; // Match what libcamera configures
    rawStreamConfig.size.width = RAW_FRAME_WIDTH;
    rawStreamConfig.size.height = RAW_FRAME_HEIGHT;
    rawStreamConfig.bufferCount = 6; // Explicitly set buffer count

    // Validate and apply the configuration
    int ret = config->validate();
    if (ret == -EINVAL) {
        std::cerr << "[" << get_timestamp() << "] Failed to validate camera configuration." << std::endl;
        camera_obj->release();
        camera_manager->stop();
        close(lock_fd);
        cleanup_resources();
        return 1;
    }
    camera_obj->configure(config.get());

    // Get the raw stream
    raw_stream = rawStreamConfig.stream();

    // 4. Allocate Frame Buffers
    allocator = std::make_unique<FrameBufferAllocator>(camera_obj);
    for (StreamConfiguration &cfg : *config) {
        int ret = allocator->allocate(cfg.stream());
        if (ret < 0) {
            std::cerr << "[" << get_timestamp() << "] Can't allocate buffers for stream. Error: " << ret << std::endl;
            camera_obj->release();
            camera_manager->stop();
            close(lock_fd);
            cleanup_resources();
            return 1;
        }
        std::cout << "[" << get_timestamp() << "] Allocated " << allocator->buffers(cfg.stream()).size()
                  << " buffers for stream." << std::endl;
    }

    // 5. Create and Queue Requests
    for (StreamConfiguration &cfg : *config) {
        Stream *stream = cfg.stream();
        const std::vector<std::unique_ptr<FrameBuffer>> &buffers = allocator->buffers(stream);

        std::cout << "[" << get_timestamp() << "] Creating requests for stream " << stream << " with " << buffers.size() << " buffers." << std::endl;

        for (const auto &buffer : buffers) {
            std::cout << "[" << get_timestamp() << "] Processing buffer at address: " << buffer.get() << std::endl;
            std::unique_ptr<Request> request = camera_obj->createRequest();
            if (!request) {
                std::cerr << "[" << get_timestamp() << "] Failed to create request." << std::endl;
                camera_obj->release();
                camera_manager->stop();
                close(lock_fd);
                cleanup_resources();
                return 1;
            }
            std::cout << "[" << get_timestamp() << "] Created request " << request.get() << std::endl;

            int add_buffer_ret = request->addBuffer(stream, buffer.get());
            if (add_buffer_ret < 0) {
                std::cerr << "[" << get_timestamp() << "] Failed to add buffer to request: " << add_buffer_ret << std::endl;
                camera_obj->release();
                camera_manager->stop();
                close(lock_fd);
                cleanup_resources();
                return 1; // Or handle error appropriately
            }
            std::cout << "[" << get_timestamp() << "] Added buffer " << buffer.get() << " to request " << request.get() << std::endl;

            libcamera_requests.push_back(std::move(request));
            std::cout << "[" << get_timestamp() << "] Pushed request to vector. Vector size: " << libcamera_requests.size() << std::endl;
        }
    }

    // Set the request completion callback
    camera_obj->requestCompleted.connect(requestComplete);

    // 6. Start Camera
    camera_obj->start();
    std::cout << "[" << get_timestamp() << "] [Main] Camera started." << std::endl;

    // Queue all initial requests
    for (auto &request : libcamera_requests) {
        std::cout << "[" << get_timestamp() << "] Queuing request " << request.get() << std::endl;
        camera_obj->queueRequest(request.get());
    }

    std::cout << "[" << get_timestamp() << "] [Main] Starting threads..." << std::endl;

    std::thread t2(tpu_sender_thread);
    // std::thread t3(phone_sender_thread); // Disabled for debugging OOM

    // The main thread will now wait for a signal to stop
    // The camera_capture_thread is no longer needed as a separate thread for frame generation.
    // The requestComplete callback handles frame pushing.
    while(running) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // 7. Stop Camera and Cleanup
    std::cout << "[" << get_timestamp() << "] [Main] Stopping camera..." << std::endl;
    camera_obj->stop();
    tpu_queue.stop();
    phone_queue.stop();
    camera_obj->release();
    camera_manager->stop();

    std::cout << "[" << get_timestamp() << "] [Main] Joining threads..." << std::endl;
    t2.join();
    // t3.join(); // Disabled for debugging OOM

    // Final cleanup
    close(lock_fd);
    cleanup_resources();

    std::cout << "[" << get_timestamp() << "] [Main] All threads have stopped. Application terminated." << std::endl;
    return 0;
}
Installing Docker... This may take a few minutes.
Hit:1 http://deb.debian.org/debian bookworm InRelease
Hit:2 http://deb.debian.org/debian-security bookworm-security InRelease
Hit:3 http://archive.raspberrypi.com/debian bookworm InRelease
Hit:4 http://deb.debian.org/debian bookworm-updates InRelease
Hit:5 https://deb.nodesource.com/node_20.x nodistro InRelease
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
apt-transport-https is already the newest version (2.6.1).
ca-certificates is already the newest version (20230311+deb12u1).
curl is already the newest version (7.88.1-10+deb12u14).
gnupg is already the newest version (2.2.40-1.1+deb12u1).
lsb-release is already the newest version (12.0-1).
The following packages were automatically installed and are no longer required:
  acl colord-data containerd hplip-data libcolorhug2 libgdata-common
  libgdata22 libgoa-1.0-0b libgoa-1.0-common libgusb2 libharfbuzz-icu0
  libhpmud0 libhyphen0 libieee1284-3 libimobiledevice6
  libjavascriptcoregtk-4.1-0 libmanette-0.2-0 libplist3 libsane-common
  libsane-hpaio libsnmp-base libsnmp40 libusbmuxd6 libwoff1 lxplug-network
  lxplug-ptbatt pishutdown printer-driver-hpcups printer-driver-postscript-hp
  python3-pexpect python3-ptyprocess python3-renderpm python3-reportlab
  python3-reportlab-accel runc sane-airscan update-inetd usb.ids
  xdg-dbus-proxy zenity-common
Use 'sudo apt autoremove' to remove them.
0 upgraded, 0 newly installed, 0 to remove and 316 not upgraded.
deb [arch=arm64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian bookworm stable
Hit:1 http://deb.debian.org/debian bookworm InRelease
Hit:2 http://deb.debian.org/debian-security bookworm-security InRelease
Hit:3 http://deb.debian.org/debian bookworm-updates InRelease
Hit:4 http://archive.raspberrypi.com/debian bookworm InRelease
Get:5 https://download.docker.com/linux/debian bookworm InRelease [46,6 kB]
Hit:6 https://deb.nodesource.com/node_20.x nodistro InRelease
Get:7 https://download.docker.com/linux/debian bookworm/stable arm64 Packages [53,3 kB]
Fetched 99,9 kB in 4s (25,6 kB/s)
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
The following packages were automatically installed and are no longer required:
  acl colord-data hplip-data libcolorhug2 libgdata-common libgdata22
  libgoa-1.0-0b libgoa-1.0-common libgusb2 libharfbuzz-icu0 libhpmud0
  libhyphen0 libieee1284-3 libimobiledevice6 libjavascriptcoregtk-4.1-0
  libmanette-0.2-0 libplist3 libsane-common libsane-hpaio libsnmp-base
  libsnmp40 libusbmuxd6 libwoff1 lxplug-network lxplug-ptbatt pishutdown
  printer-driver-hpcups printer-driver-postscript-hp python3-pexpect
  python3-ptyprocess python3-renderpm python3-reportlab
  python3-reportlab-accel sane-airscan update-inetd usb.ids xdg-dbus-proxy
  zenity-common
Use 'sudo apt autoremove' to remove them.
The following additional packages will be installed:
  docker-buildx-plugin docker-ce-rootless-extras docker-compose-plugin
  iptables libip6tc2 libslirp0 pigz slirp4netns
Suggested packages:
  cgroupfs-mount | cgroup-lite docker-model-plugin firewalld
The following packages will be REMOVED:
  containerd runc
The following NEW packages will be installed:
  containerd.io docker-buildx-plugin docker-ce docker-ce-cli
  docker-ce-rootless-extras docker-compose-plugin iptables libip6tc2 libslirp0
  pigz slirp4netns
0 upgraded, 11 newly installed, 2 to remove and 316 not upgraded.
Need to get 83,7 MB/84,1 MB of archives.
After this operation, 308 MB of additional disk space will be used.
Get:1 http://deb.debian.org/debian bookworm/main arm64 pigz arm64 2.6-1 [56,2 kB]
Get:2 http://deb.debian.org/debian bookworm/main arm64 libslirp0 arm64 4.7.0-1 [58,4 kB]
Get:3 http://deb.debian.org/debian bookworm/main arm64 slirp4netns arm64 1.2.0-1 [36,6 kB]
Get:4 https://download.docker.com/linux/debian bookworm/stable arm64 containerd.io arm64 2.1.5-1~debian.12~bookworm [19,3 MB]
Get:5 https://download.docker.com/linux/debian bookworm/stable arm64 docker-ce-cli arm64 5:29.0.2-1~debian.12~bookworm [14,7 MB]
Get:6 https://download.docker.com/linux/debian bookworm/stable arm64 docker-ce arm64 5:29.0.2-1~debian.12~bookworm [17,5 MB]
Get:7 https://download.docker.com/linux/debian bookworm/stable arm64 docker-buildx-plugin arm64 0.30.0-1~debian.12~bookworm [14,1 MB]
Get:8 https://download.docker.com/linux/debian bookworm/stable arm64 docker-ce-rootless-extras arm64 5:29.0.2-1~debian.12~bookworm [5.656 kB]
Get:9 https://download.docker.com/linux/debian bookworm/stable arm64 docker-compose-plugin arm64 2.40.3-1~debian.12~bookworm [12,3 MB]
Fetched 83,7 MB in 24s (3.493 kB/s)
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 170008 files and directories currently installed.)
Removing containerd (1.6.20~ds1-1+deb12u1) ...
Removing runc (1.1.5+ds1-1+deb12u1) ...
Selecting previously unselected package containerd.io.
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 169946 files and directories currently installed.)
Preparing to unpack .../00-containerd.io_2.1.5-1~debian.12~bookworm_arm64.deb ...
Unpacking containerd.io (2.1.5-1~debian.12~bookworm) ...
Selecting previously unselected package docker-ce-cli.
Preparing to unpack .../01-docker-ce-cli_5%3a29.0.2-1~debian.12~bookworm_arm64.deb ...
Unpacking docker-ce-cli (5:29.0.2-1~debian.12~bookworm) ...
Selecting previously unselected package libip6tc2:arm64.
Preparing to unpack .../02-libip6tc2_1.8.9-2_arm64.deb ...
Unpacking libip6tc2:arm64 (1.8.9-2) ...
Selecting previously unselected package iptables.
Preparing to unpack .../03-iptables_1.8.9-2_arm64.deb ...
Unpacking iptables (1.8.9-2) ...
Selecting previously unselected package docker-ce.
Preparing to unpack .../04-docker-ce_5%3a29.0.2-1~debian.12~bookworm_arm64.deb ...
Unpacking docker-ce (5:29.0.2-1~debian.12~bookworm) ...
Selecting previously unselected package pigz.
Preparing to unpack .../05-pigz_2.6-1_arm64.deb ...
Unpacking pigz (2.6-1) ...
Selecting previously unselected package docker-buildx-plugin.
Preparing to unpack .../06-docker-buildx-plugin_0.30.0-1~debian.12~bookworm_arm64.deb ...
Unpacking docker-buildx-plugin (0.30.0-1~debian.12~bookworm) ...
Selecting previously unselected package docker-ce-rootless-extras.
Preparing to unpack .../07-docker-ce-rootless-extras_5%3a29.0.2-1~debian.12~bookworm_arm64.deb ...
Unpacking docker-ce-rootless-extras (5:29.0.2-1~debian.12~bookworm) ...
Selecting previously unselected package docker-compose-plugin.
Preparing to unpack .../08-docker-compose-plugin_2.40.3-1~debian.12~bookworm_arm64.deb ...
Unpacking docker-compose-plugin (2.40.3-1~debian.12~bookworm) ...
Selecting previously unselected package libslirp0:arm64.
Preparing to unpack .../09-libslirp0_4.7.0-1_arm64.deb ...
Unpacking libslirp0:arm64 (4.7.0-1) ...
Selecting previously unselected package slirp4netns.
Preparing to unpack .../10-slirp4netns_1.2.0-1_arm64.deb ...
Unpacking slirp4netns (1.2.0-1) ...
Setting up libip6tc2:arm64 (1.8.9-2) ...
Setting up docker-buildx-plugin (0.30.0-1~debian.12~bookworm) ...
Setting up containerd.io (2.1.5-1~debian.12~bookworm) ...
Installing new version of config file /etc/containerd/config.toml ...
Setting up docker-compose-plugin (2.40.3-1~debian.12~bookworm) ...
Setting up docker-ce-cli (5:29.0.2-1~debian.12~bookworm) ...
Setting up libslirp0:arm64 (4.7.0-1) ...
Setting up pigz (2.6-1) ...
Setting up docker-ce-rootless-extras (5:29.0.2-1~debian.12~bookworm) ...
Setting up slirp4netns (1.2.0-1) ...
Setting up iptables (1.8.9-2) ...
update-alternatives: using /usr/sbin/iptables-legacy to provide /usr/sbin/iptables (iptables) in auto mode
update-alternatives: using /usr/sbin/ip6tables-legacy to provide /usr/sbin/ip6tables (ip6tables) in auto mode
update-alternatives: using /usr/sbin/iptables-nft to provide /usr/sbin/iptables (iptables) in auto mode
update-alternatives: using /usr/sbin/ip6tables-nft to provide /usr/sbin/ip6tables (ip6tables) in auto mode
update-alternatives: using /usr/sbin/arptables-nft to provide /usr/sbin/arptables (arptables) in auto mode
update-alternatives: using /usr/sbin/ebtables-nft to provide /usr/sbin/ebtables (ebtables) in auto mode
Setting up docker-ce (5:29.0.2-1~debian.12~bookworm) ...
Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service.
Created symlink /etc/systemd/system/sockets.target.wants/docker.socket → /lib/systemd/system/docker.socket.
Processing triggers for man-db (2.11.2-2) ...
Processing triggers for libc-bin (2.36-9+rpt2+deb12u9) ...
coral_extractor
coral_extractor
Untagged: coral-tpu-builder:latest
Deleted: sha256:f41cfd9e997d0dc7e36ebce3ccc29c7cc8ff125fe33f80c13962e87f73771898
