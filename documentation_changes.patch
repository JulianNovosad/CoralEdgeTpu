diff --git a/CMakeLists.txt b/CMakeLists.txt
index a2133ac..62cb358 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,75 +1,56 @@
 cmake_minimum_required(VERSION 3.16)
 project(CoralEdgeTpuDetector CXX)
 
-find_package(PkgConfig REQUIRED)
-
-# --- Local Dependencies ---
-
-# FlatBuffers
-set(FLATBUFFERS_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/flatbuffers/include)
-set(FLATBUFFERS_LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/flatbuffers/lib)
-message(STATUS "Flatbuffers include dir: ${FLATBUFFERS_INCLUDE_DIR}")
-message(STATUS "Flatbuffers lib dir: ${FLATBUFFERS_LIB_DIR}")
-
-# TensorFlow Lite
-set(TFLITE_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/include)
-set(TFLITE_LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/lib)
-message(STATUS "TFLite include dir: ${TFLITE_INCLUDE_DIR}")
-message(STATUS "TFLite lib dir: ${TFLITE_LIB_DIR}")
-
-# --- C++ Standard and Compiler Flags ---
 set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
-set(CMAKE_CXX_EXTENSIONS OFF)
 
-# Release build optimization flags are typically handled by default CMake behavior.
-# Avoid manually setting CMAKE_CXX_FLAGS to prevent parsing issues.
+find_package(PkgConfig REQUIRED)
+find_package(Threads REQUIRED)
 
-# Set RPATH for shared libraries to be found at runtime
-set(CMAKE_INSTALL_RPATH "${CMAKE_CURRENT_SOURCE_DIR}/lib")
-set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+# --- Find System Dependencies ---
+pkg_check_modules(JPEG REQUIRED libjpeg)
+message(STATUS "Found libjpeg: ${JPEG_LIBRARIES}")
 
-# --- Application Target ---
+# --- Find Local/Custom Dependencies ---
+set(TFLITE_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/include)
+set(TFLITE_LIB_DIR ${CMAKE_CURRENT_SOURCE_DIR}/lib)
+set(FLATBUFFERS_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/flatbuffers/include)
 
-# Find libcamera using pkg-config
-pkg_check_modules(LIBCAMERA REQUIRED libcamera)
-if (NOT LIBCAMERA_FOUND)
-    message(FATAL_ERROR "libcamera not found!")
+if(NOT EXISTS ${TFLITE_INCLUDE_DIR})
+    message(FATAL_ERROR "TensorFlow Lite include directory not found at ${TFLITE_INCLUDE_DIR}")
 endif()
-
-# Find libusb-1.0 using pkg-config (often a dependency for libcamera)
-pkg_check_modules(LIBUSB1 REQUIRED libusb-1.0)
-if (NOT LIBUSB1_FOUND)
-    message(FATAL_ERROR "libusb-1.0 not found!")
+if(NOT EXISTS ${FLATBUFFERS_INCLUDE_DIR})
+    message(FATAL_ERROR "Flatbuffers include directory not found at ${FLATBUFFERS_INCLUDE_DIR}")
 endif()
 
-add_executable(detector src/main.cpp src/camera_capture.cpp src/inference.cpp src/mjpeg_server.cpp src/udp_sender.cpp src/jpeg_wrapper.cpp src/util_logging.cpp src/output_processor.cpp)
-
-# Apply compiler flags directly to the target to ensure they are used
-target_compile_options(detector PRIVATE -O3 -std=c++17)
-
-# Link FlatBuffers manually
-target_include_directories(detector PRIVATE ${FLATBUFFERS_INCLUDE_DIR} ${LIBCAMERA_INCLUDE_DIRS})
-target_link_directories(detector PRIVATE ${FLATBUFFERS_LIB_DIR})
-# Link against libflatbuffers.a. CMake will infer the library name flatbuffers from libflatbuffers.a
-target_link_libraries(detector PRIVATE flatbuffers ${LIBCAMERA_LIBRARIES} ${LIBUSB1_LIBRARIES})
+# --- Set up Executable Target ---
+add_executable(detector
+    src/main.cpp
+    src/camera_capture.cpp
+    src/mjpeg_capture.cpp # Added new module
+    src/inference.cpp
+    src/mjpeg_server.cpp
+    src/udp_sender.cpp
+    src/jpeg_wrapper.cpp
+    src/util_logging.cpp
+)
 
-# Link TensorFlow Lite
+# --- Link Libraries and Include Directories ---
 target_include_directories(detector PRIVATE
     ${TFLITE_INCLUDE_DIR}
-    ${TFLITE_INCLUDE_DIR}/tensorflow/lite
-    ${TFLITE_INCLUDE_DIR}/tensorflow/lite/c
-    ${TFLITE_INCLUDE_DIR}/tensorflow/lite/core # For core headers if needed directly
+    ${FLATBUFFERS_INCLUDE_DIR}
+    ${JPEG_INCLUDE_DIRS}
 )
+
 target_link_directories(detector PRIVATE ${TFLITE_LIB_DIR})
-# Link against libtensorflowlite.so. CMake will infer the library name tensorflowlite from libtensorflowlite.so
-target_link_libraries(detector PRIVATE tensorflowlite edgetpu jpeg)
 
-# Set RPATH for the executable itself. The  variable is resolved at runtime
-# to the directory containing the executable. We want to link to ../lib.
-target_link_options(detector PRIVATE
-    "-Wl,-rpath,'$ORIGIN/../lib'"
+target_link_libraries(detector PRIVATE
+    ${JPEG_LIBRARIES}
+    tensorflowlite
+    edgetpu
+    Threads::Threads
 )
 
-message(STATUS "Detector executable will be built.")
+target_link_options(detector PRIVATE "-Wl,-rpath,'$ORIGIN/../lib'")
 
+message(STATUS "Target 'detector' configured. Ready to build.")
diff --git a/build/CMakeCache.txt b/build/CMakeCache.txt
index 856a3b6..08c9b50 100644
--- a/build/CMakeCache.txt
+++ b/build/CMakeCache.txt
@@ -202,13 +202,7 @@ PKG_CONFIG_ARGN:STRING=
 PKG_CONFIG_EXECUTABLE:FILEPATH=/usr/bin/pkg-config
 
 //Path to a library.
-pkgcfg_lib_LIBCAMERA_camera:FILEPATH=/usr/lib/aarch64-linux-gnu/libcamera.so
-
-//Path to a library.
-pkgcfg_lib_LIBCAMERA_camera-base:FILEPATH=/usr/lib/aarch64-linux-gnu/libcamera-base.so
-
-//Path to a library.
-pkgcfg_lib_LIBUSB1_usb-1.0:FILEPATH=/usr/lib/aarch64-linux-gnu/libusb-1.0.so
+pkgcfg_lib_JPEG_jpeg:FILEPATH=/usr/lib/aarch64-linux-gnu/libjpeg.so
 
 
 ########################
@@ -277,6 +271,8 @@ CMAKE_GENERATOR_INSTANCE:INTERNAL=
 CMAKE_GENERATOR_PLATFORM:INTERNAL=
 //Name of generator toolset.
 CMAKE_GENERATOR_TOOLSET:INTERNAL=
+//Test CMAKE_HAVE_LIBC_PTHREAD
+CMAKE_HAVE_LIBC_PTHREAD:INTERNAL=1
 //Source directory with the top level CMakeLists.txt file for this
 // project
 CMAKE_HOME_DIRECTORY:INTERNAL=/home/pi/CoralEdgeTpu
@@ -344,91 +340,52 @@ CMAKE_UNAME:INTERNAL=/usr/bin/uname
 CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1
 //Details about finding PkgConfig
 FIND_PACKAGE_MESSAGE_DETAILS_PkgConfig:INTERNAL=[/usr/bin/pkg-config][v1.8.1()]
-LIBCAMERA_CFLAGS:INTERNAL=-I/usr/include/libcamera
-LIBCAMERA_CFLAGS_I:INTERNAL=
-LIBCAMERA_CFLAGS_OTHER:INTERNAL=
-LIBCAMERA_FOUND:INTERNAL=1
-LIBCAMERA_INCLUDEDIR:INTERNAL=/usr/include
-LIBCAMERA_INCLUDE_DIRS:INTERNAL=/usr/include/libcamera
-LIBCAMERA_LDFLAGS:INTERNAL=-L/usr/lib/aarch64-linux-gnu;-lcamera;-lcamera-base
-LIBCAMERA_LDFLAGS_OTHER:INTERNAL=
-LIBCAMERA_LIBDIR:INTERNAL=/usr/lib/aarch64-linux-gnu
-LIBCAMERA_LIBRARIES:INTERNAL=camera;camera-base
-LIBCAMERA_LIBRARY_DIRS:INTERNAL=/usr/lib/aarch64-linux-gnu
-LIBCAMERA_LIBS:INTERNAL=
-LIBCAMERA_LIBS_L:INTERNAL=
-LIBCAMERA_LIBS_OTHER:INTERNAL=
-LIBCAMERA_LIBS_PATHS:INTERNAL=
-LIBCAMERA_MODULE_NAME:INTERNAL=libcamera
-LIBCAMERA_PREFIX:INTERNAL=/usr
-LIBCAMERA_STATIC_CFLAGS:INTERNAL=-I/usr/include/libcamera
-LIBCAMERA_STATIC_CFLAGS_I:INTERNAL=
-LIBCAMERA_STATIC_CFLAGS_OTHER:INTERNAL=
-LIBCAMERA_STATIC_INCLUDE_DIRS:INTERNAL=/usr/include/libcamera
-LIBCAMERA_STATIC_LDFLAGS:INTERNAL=-L/usr/lib/aarch64-linux-gnu;-lcamera;-lcamera-base
-LIBCAMERA_STATIC_LDFLAGS_OTHER:INTERNAL=
-LIBCAMERA_STATIC_LIBDIR:INTERNAL=
-LIBCAMERA_STATIC_LIBRARIES:INTERNAL=camera;camera-base
-LIBCAMERA_STATIC_LIBRARY_DIRS:INTERNAL=/usr/lib/aarch64-linux-gnu
-LIBCAMERA_STATIC_LIBS:INTERNAL=
-LIBCAMERA_STATIC_LIBS_L:INTERNAL=
-LIBCAMERA_STATIC_LIBS_OTHER:INTERNAL=
-LIBCAMERA_STATIC_LIBS_PATHS:INTERNAL=
-LIBCAMERA_VERSION:INTERNAL=0.5.2
-LIBCAMERA_libcamera_INCLUDEDIR:INTERNAL=
-LIBCAMERA_libcamera_LIBDIR:INTERNAL=
-LIBCAMERA_libcamera_PREFIX:INTERNAL=
-LIBCAMERA_libcamera_VERSION:INTERNAL=
-LIBUSB1_CFLAGS:INTERNAL=-I/usr/include/libusb-1.0
-LIBUSB1_CFLAGS_I:INTERNAL=
-LIBUSB1_CFLAGS_OTHER:INTERNAL=
-LIBUSB1_FOUND:INTERNAL=1
-LIBUSB1_INCLUDEDIR:INTERNAL=/usr/include
-LIBUSB1_INCLUDE_DIRS:INTERNAL=/usr/include/libusb-1.0
-LIBUSB1_LDFLAGS:INTERNAL=-L/usr/lib/aarch64-linux-gnu;-lusb-1.0
-LIBUSB1_LDFLAGS_OTHER:INTERNAL=
-LIBUSB1_LIBDIR:INTERNAL=/usr/lib/aarch64-linux-gnu
-LIBUSB1_LIBRARIES:INTERNAL=usb-1.0
-LIBUSB1_LIBRARY_DIRS:INTERNAL=/usr/lib/aarch64-linux-gnu
-LIBUSB1_LIBS:INTERNAL=
-LIBUSB1_LIBS_L:INTERNAL=
-LIBUSB1_LIBS_OTHER:INTERNAL=
-LIBUSB1_LIBS_PATHS:INTERNAL=
-LIBUSB1_MODULE_NAME:INTERNAL=libusb-1.0
-LIBUSB1_PREFIX:INTERNAL=/usr
-LIBUSB1_STATIC_CFLAGS:INTERNAL=-I/usr/include/libusb-1.0
-LIBUSB1_STATIC_CFLAGS_I:INTERNAL=
-LIBUSB1_STATIC_CFLAGS_OTHER:INTERNAL=
-LIBUSB1_STATIC_INCLUDE_DIRS:INTERNAL=/usr/include/libusb-1.0
-LIBUSB1_STATIC_LDFLAGS:INTERNAL=-L/usr/lib/aarch64-linux-gnu;-lusb-1.0;-ludev;-latomic;-lpthread
-LIBUSB1_STATIC_LDFLAGS_OTHER:INTERNAL=
-LIBUSB1_STATIC_LIBDIR:INTERNAL=
-LIBUSB1_STATIC_LIBRARIES:INTERNAL=usb-1.0;udev;atomic;pthread
-LIBUSB1_STATIC_LIBRARY_DIRS:INTERNAL=/usr/lib/aarch64-linux-gnu
-LIBUSB1_STATIC_LIBS:INTERNAL=
-LIBUSB1_STATIC_LIBS_L:INTERNAL=
-LIBUSB1_STATIC_LIBS_OTHER:INTERNAL=
-LIBUSB1_STATIC_LIBS_PATHS:INTERNAL=
-LIBUSB1_VERSION:INTERNAL=1.0.26
-LIBUSB1_libusb-1.0_INCLUDEDIR:INTERNAL=
-LIBUSB1_libusb-1.0_LIBDIR:INTERNAL=
-LIBUSB1_libusb-1.0_PREFIX:INTERNAL=
-LIBUSB1_libusb-1.0_VERSION:INTERNAL=
+//Details about finding Threads
+FIND_PACKAGE_MESSAGE_DETAILS_Threads:INTERNAL=[TRUE][v()]
+JPEG_CFLAGS:INTERNAL=
+JPEG_CFLAGS_I:INTERNAL=
+JPEG_CFLAGS_OTHER:INTERNAL=
+JPEG_FOUND:INTERNAL=1
+JPEG_INCLUDEDIR:INTERNAL=/usr/include
+JPEG_INCLUDE_DIRS:INTERNAL=
+JPEG_LDFLAGS:INTERNAL=-L/usr/lib/aarch64-linux-gnu;-ljpeg
+JPEG_LDFLAGS_OTHER:INTERNAL=
+JPEG_LIBDIR:INTERNAL=/usr/lib/aarch64-linux-gnu
+JPEG_LIBRARIES:INTERNAL=jpeg
+JPEG_LIBRARY_DIRS:INTERNAL=/usr/lib/aarch64-linux-gnu
+JPEG_LIBS:INTERNAL=
+JPEG_LIBS_L:INTERNAL=
+JPEG_LIBS_OTHER:INTERNAL=
+JPEG_LIBS_PATHS:INTERNAL=
+JPEG_MODULE_NAME:INTERNAL=libjpeg
+JPEG_PREFIX:INTERNAL=/usr
+JPEG_STATIC_CFLAGS:INTERNAL=
+JPEG_STATIC_CFLAGS_I:INTERNAL=
+JPEG_STATIC_CFLAGS_OTHER:INTERNAL=
+JPEG_STATIC_INCLUDE_DIRS:INTERNAL=
+JPEG_STATIC_LDFLAGS:INTERNAL=-L/usr/lib/aarch64-linux-gnu;-ljpeg
+JPEG_STATIC_LDFLAGS_OTHER:INTERNAL=
+JPEG_STATIC_LIBDIR:INTERNAL=
+JPEG_STATIC_LIBRARIES:INTERNAL=jpeg
+JPEG_STATIC_LIBRARY_DIRS:INTERNAL=/usr/lib/aarch64-linux-gnu
+JPEG_STATIC_LIBS:INTERNAL=
+JPEG_STATIC_LIBS_L:INTERNAL=
+JPEG_STATIC_LIBS_OTHER:INTERNAL=
+JPEG_STATIC_LIBS_PATHS:INTERNAL=
+JPEG_VERSION:INTERNAL=2.1.5
+JPEG_libjpeg_INCLUDEDIR:INTERNAL=
+JPEG_libjpeg_LIBDIR:INTERNAL=
+JPEG_libjpeg_PREFIX:INTERNAL=
+JPEG_libjpeg_VERSION:INTERNAL=
 //ADVANCED property for variable: PKG_CONFIG_ARGN
 PKG_CONFIG_ARGN-ADVANCED:INTERNAL=1
 //ADVANCED property for variable: PKG_CONFIG_EXECUTABLE
 PKG_CONFIG_EXECUTABLE-ADVANCED:INTERNAL=1
 //linker supports push/pop state
 _CMAKE_LINKER_PUSHPOP_STATE_SUPPORTED:INTERNAL=TRUE
-__pkg_config_arguments_LIBCAMERA:INTERNAL=REQUIRED;libcamera
-__pkg_config_arguments_LIBUSB1:INTERNAL=REQUIRED;libusb-1.0
-__pkg_config_checked_LIBCAMERA:INTERNAL=1
-__pkg_config_checked_LIBUSB1:INTERNAL=1
-//ADVANCED property for variable: pkgcfg_lib_LIBCAMERA_camera
-pkgcfg_lib_LIBCAMERA_camera-ADVANCED:INTERNAL=1
-//ADVANCED property for variable: pkgcfg_lib_LIBCAMERA_camera-base
-pkgcfg_lib_LIBCAMERA_camera-base-ADVANCED:INTERNAL=1
-//ADVANCED property for variable: pkgcfg_lib_LIBUSB1_usb-1.0
-pkgcfg_lib_LIBUSB1_usb-1.0-ADVANCED:INTERNAL=1
+__pkg_config_arguments_JPEG:INTERNAL=REQUIRED;libjpeg
+__pkg_config_checked_JPEG:INTERNAL=1
+//ADVANCED property for variable: pkgcfg_lib_JPEG_jpeg
+pkgcfg_lib_JPEG_jpeg-ADVANCED:INTERNAL=1
 prefix_result:INTERNAL=/usr/lib/aarch64-linux-gnu
 
diff --git a/build/CMakeFiles/CMakeOutput.log b/build/CMakeFiles/CMakeOutput.log
index 59bac4e..c97a1f8 100644
--- a/build/CMakeFiles/CMakeOutput.log
+++ b/build/CMakeFiles/CMakeOutput.log
@@ -13,12 +13,12 @@ Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" p
 The CXX compiler identification is GNU, found in "/home/pi/CoralEdgeTpu/build/CMakeFiles/3.25.1/CompilerIdCXX/a.out"
 
 Detecting CXX compiler ABI info compiled with the following output:
-Change Dir: /home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-8l70lE
+Change Dir: /home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-TtJK11
 
-Run Build Command(s):/usr/bin/gmake -f Makefile cmTC_7bfd1/fast && /usr/bin/gmake  -f CMakeFiles/cmTC_7bfd1.dir/build.make CMakeFiles/cmTC_7bfd1.dir/build
-gmake[1]: Entering directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-8l70lE'
-Building CXX object CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o
-/usr/bin/c++   -v -o CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp
+Run Build Command(s):/usr/bin/gmake -f Makefile cmTC_92292/fast && /usr/bin/gmake  -f CMakeFiles/cmTC_92292.dir/build.make CMakeFiles/cmTC_92292.dir/build
+gmake[1]: Entering directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-TtJK11'
+Building CXX object CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o
+/usr/bin/c++   -v -o CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp
 Using built-in specs.
 COLLECT_GCC=/usr/bin/c++
 Target: aarch64-linux-gnu
@@ -26,8 +26,8 @@ Configured with: ../src/configure -v --with-pkgversion='Debian 12.2.0-14' --with
 Thread model: posix
 Supported LTO compression algorithms: zlib zstd
 gcc version 12.2.0 (Debian 12.2.0-14) 
-COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_7bfd1.dir/'
- /usr/lib/gcc/aarch64-linux-gnu/12/cc1plus -quiet -v -imultiarch aarch64-linux-gnu -D_GNU_SOURCE /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpdir CMakeFiles/cmTC_7bfd1.dir/ -dumpbase CMakeCXXCompilerABI.cpp.cpp -dumpbase-ext .cpp -mlittle-endian -mabi=lp64 -version -fasynchronous-unwind-tables -o /tmp/ccUhOkUn.s
+COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_92292.dir/'
+ /usr/lib/gcc/aarch64-linux-gnu/12/cc1plus -quiet -v -imultiarch aarch64-linux-gnu -D_GNU_SOURCE /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpdir CMakeFiles/cmTC_92292.dir/ -dumpbase CMakeCXXCompilerABI.cpp.cpp -dumpbase-ext .cpp -mlittle-endian -mabi=lp64 -version -fasynchronous-unwind-tables -o /tmp/ccqQjMMf.s
 GNU C++17 (Debian 12.2.0-14) version 12.2.0 (aarch64-linux-gnu)
 	compiled by GNU C version 12.2.0, GMP version 6.2.1, MPFR version 4.1.1-p1, MPC version 1.3.1, isl version isl-0.25-GMP
 
@@ -53,15 +53,15 @@ GNU C++17 (Debian 12.2.0-14) version 12.2.0 (aarch64-linux-gnu)
 warning: MPFR header version 4.1.1-p1 differs from library version 4.2.0.
 GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
 Compiler executable checksum: 76d6f14273b9515783c50374b109b352
-COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_7bfd1.dir/'
- as -v -EL -mabi=lp64 -o CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccUhOkUn.s
+COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_92292.dir/'
+ as -v -EL -mabi=lp64 -o CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccqQjMMf.s
 GNU assembler version 2.40 (aarch64-linux-gnu) using BFD version (GNU Binutils for Debian) 2.40
 COMPILER_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/
 LIBRARY_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib/:/lib/aarch64-linux-gnu/:/lib/../lib/:/usr/lib/aarch64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../:/lib/:/usr/lib/
-COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.'
-Linking CXX executable cmTC_7bfd1
-/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_7bfd1.dir/link.txt --verbose=1
-/usr/bin/c++  -v CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o -o cmTC_7bfd1 
+COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.'
+Linking CXX executable cmTC_92292
+/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_92292.dir/link.txt --verbose=1
+/usr/bin/c++  -v CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o -o cmTC_92292 
 Using built-in specs.
 COLLECT_GCC=/usr/bin/c++
 COLLECT_LTO_WRAPPER=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper
@@ -72,10 +72,10 @@ Supported LTO compression algorithms: zlib zstd
 gcc version 12.2.0 (Debian 12.2.0-14) 
 COMPILER_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/
 LIBRARY_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib/:/lib/aarch64-linux-gnu/:/lib/../lib/:/usr/lib/aarch64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../:/lib/:/usr/lib/
-COLLECT_GCC_OPTIONS='-v' '-o' 'cmTC_7bfd1' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'cmTC_7bfd1.'
- /usr/lib/gcc/aarch64-linux-gnu/12/collect2 -plugin /usr/lib/gcc/aarch64-linux-gnu/12/liblto_plugin.so -plugin-opt=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper -plugin-opt=-fresolution=/tmp/ccw2HLss.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux-aarch64.so.1 -X -EL -maarch64linux --fix-cortex-a53-843419 -pie -o cmTC_7bfd1 /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/Scrt1.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crti.o /usr/lib/gcc/aarch64-linux-gnu/12/crtbeginS.o -L/usr/lib/gcc/aarch64-linux-gnu/12 -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib -L/lib/aarch64-linux-gnu -L/lib/../lib -L/usr/lib/aarch64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/aarch64-linux-gnu/12/../../.. CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/aarch64-linux-gnu/12/crtendS.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crtn.o
-COLLECT_GCC_OPTIONS='-v' '-o' 'cmTC_7bfd1' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'cmTC_7bfd1.'
-gmake[1]: Leaving directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-8l70lE'
+COLLECT_GCC_OPTIONS='-v' '-o' 'cmTC_92292' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'cmTC_92292.'
+ /usr/lib/gcc/aarch64-linux-gnu/12/collect2 -plugin /usr/lib/gcc/aarch64-linux-gnu/12/liblto_plugin.so -plugin-opt=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper -plugin-opt=-fresolution=/tmp/ccrVDdeM.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux-aarch64.so.1 -X -EL -maarch64linux --fix-cortex-a53-843419 -pie -o cmTC_92292 /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/Scrt1.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crti.o /usr/lib/gcc/aarch64-linux-gnu/12/crtbeginS.o -L/usr/lib/gcc/aarch64-linux-gnu/12 -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib -L/lib/aarch64-linux-gnu -L/lib/../lib -L/usr/lib/aarch64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/aarch64-linux-gnu/12/../../.. CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/aarch64-linux-gnu/12/crtendS.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crtn.o
+COLLECT_GCC_OPTIONS='-v' '-o' 'cmTC_92292' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'cmTC_92292.'
+gmake[1]: Leaving directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-TtJK11'
 
 
 
@@ -102,12 +102,12 @@ Parsed CXX implicit include dir info from above output: rv=done
 
 Parsed CXX implicit link information from above output:
   link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
-  ignore line: [Change Dir: /home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-8l70lE]
+  ignore line: [Change Dir: /home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-TtJK11]
   ignore line: []
-  ignore line: [Run Build Command(s):/usr/bin/gmake -f Makefile cmTC_7bfd1/fast && /usr/bin/gmake  -f CMakeFiles/cmTC_7bfd1.dir/build.make CMakeFiles/cmTC_7bfd1.dir/build]
-  ignore line: [gmake[1]: Entering directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-8l70lE']
-  ignore line: [Building CXX object CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o]
-  ignore line: [/usr/bin/c++   -v -o CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp]
+  ignore line: [Run Build Command(s):/usr/bin/gmake -f Makefile cmTC_92292/fast && /usr/bin/gmake  -f CMakeFiles/cmTC_92292.dir/build.make CMakeFiles/cmTC_92292.dir/build]
+  ignore line: [gmake[1]: Entering directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-TtJK11']
+  ignore line: [Building CXX object CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o]
+  ignore line: [/usr/bin/c++   -v -o CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp]
   ignore line: [Using built-in specs.]
   ignore line: [COLLECT_GCC=/usr/bin/c++]
   ignore line: [Target: aarch64-linux-gnu]
@@ -115,8 +115,8 @@ Parsed CXX implicit link information from above output:
   ignore line: [Thread model: posix]
   ignore line: [Supported LTO compression algorithms: zlib zstd]
   ignore line: [gcc version 12.2.0 (Debian 12.2.0-14) ]
-  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_7bfd1.dir/']
-  ignore line: [ /usr/lib/gcc/aarch64-linux-gnu/12/cc1plus -quiet -v -imultiarch aarch64-linux-gnu -D_GNU_SOURCE /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpdir CMakeFiles/cmTC_7bfd1.dir/ -dumpbase CMakeCXXCompilerABI.cpp.cpp -dumpbase-ext .cpp -mlittle-endian -mabi=lp64 -version -fasynchronous-unwind-tables -o /tmp/ccUhOkUn.s]
+  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_92292.dir/']
+  ignore line: [ /usr/lib/gcc/aarch64-linux-gnu/12/cc1plus -quiet -v -imultiarch aarch64-linux-gnu -D_GNU_SOURCE /usr/share/cmake-3.25/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpdir CMakeFiles/cmTC_92292.dir/ -dumpbase CMakeCXXCompilerABI.cpp.cpp -dumpbase-ext .cpp -mlittle-endian -mabi=lp64 -version -fasynchronous-unwind-tables -o /tmp/ccqQjMMf.s]
   ignore line: [GNU C++17 (Debian 12.2.0-14) version 12.2.0 (aarch64-linux-gnu)]
   ignore line: [	compiled by GNU C version 12.2.0  GMP version 6.2.1  MPFR version 4.1.1-p1  MPC version 1.3.1  isl version isl-0.25-GMP]
   ignore line: []
@@ -142,15 +142,15 @@ Parsed CXX implicit link information from above output:
   ignore line: [warning: MPFR header version 4.1.1-p1 differs from library version 4.2.0.]
   ignore line: [GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072]
   ignore line: [Compiler executable checksum: 76d6f14273b9515783c50374b109b352]
-  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_7bfd1.dir/']
-  ignore line: [ as -v -EL -mabi=lp64 -o CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccUhOkUn.s]
+  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_92292.dir/']
+  ignore line: [ as -v -EL -mabi=lp64 -o CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccqQjMMf.s]
   ignore line: [GNU assembler version 2.40 (aarch64-linux-gnu) using BFD version (GNU Binutils for Debian) 2.40]
   ignore line: [COMPILER_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/]
   ignore line: [LIBRARY_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib/:/lib/aarch64-linux-gnu/:/lib/../lib/:/usr/lib/aarch64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../:/lib/:/usr/lib/]
-  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.']
-  ignore line: [Linking CXX executable cmTC_7bfd1]
-  ignore line: [/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_7bfd1.dir/link.txt --verbose=1]
-  ignore line: [/usr/bin/c++  -v CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o -o cmTC_7bfd1 ]
+  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.']
+  ignore line: [Linking CXX executable cmTC_92292]
+  ignore line: [/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_92292.dir/link.txt --verbose=1]
+  ignore line: [/usr/bin/c++  -v CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o -o cmTC_92292 ]
   ignore line: [Using built-in specs.]
   ignore line: [COLLECT_GCC=/usr/bin/c++]
   ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper]
@@ -161,13 +161,13 @@ Parsed CXX implicit link information from above output:
   ignore line: [gcc version 12.2.0 (Debian 12.2.0-14) ]
   ignore line: [COMPILER_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/]
   ignore line: [LIBRARY_PATH=/usr/lib/gcc/aarch64-linux-gnu/12/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib/:/lib/aarch64-linux-gnu/:/lib/../lib/:/usr/lib/aarch64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/aarch64-linux-gnu/12/../../../:/lib/:/usr/lib/]
-  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTC_7bfd1' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'cmTC_7bfd1.']
-  link line: [ /usr/lib/gcc/aarch64-linux-gnu/12/collect2 -plugin /usr/lib/gcc/aarch64-linux-gnu/12/liblto_plugin.so -plugin-opt=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper -plugin-opt=-fresolution=/tmp/ccw2HLss.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux-aarch64.so.1 -X -EL -maarch64linux --fix-cortex-a53-843419 -pie -o cmTC_7bfd1 /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/Scrt1.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crti.o /usr/lib/gcc/aarch64-linux-gnu/12/crtbeginS.o -L/usr/lib/gcc/aarch64-linux-gnu/12 -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib -L/lib/aarch64-linux-gnu -L/lib/../lib -L/usr/lib/aarch64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/aarch64-linux-gnu/12/../../.. CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/aarch64-linux-gnu/12/crtendS.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crtn.o]
+  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'cmTC_92292' '-shared-libgcc' '-mlittle-endian' '-mabi=lp64' '-dumpdir' 'cmTC_92292.']
+  link line: [ /usr/lib/gcc/aarch64-linux-gnu/12/collect2 -plugin /usr/lib/gcc/aarch64-linux-gnu/12/liblto_plugin.so -plugin-opt=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper -plugin-opt=-fresolution=/tmp/ccrVDdeM.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux-aarch64.so.1 -X -EL -maarch64linux --fix-cortex-a53-843419 -pie -o cmTC_92292 /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/Scrt1.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crti.o /usr/lib/gcc/aarch64-linux-gnu/12/crtbeginS.o -L/usr/lib/gcc/aarch64-linux-gnu/12 -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu -L/usr/lib/gcc/aarch64-linux-gnu/12/../../../../lib -L/lib/aarch64-linux-gnu -L/lib/../lib -L/usr/lib/aarch64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/aarch64-linux-gnu/12/../../.. CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/aarch64-linux-gnu/12/crtendS.o /usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crtn.o]
     arg [/usr/lib/gcc/aarch64-linux-gnu/12/collect2] ==> ignore
     arg [-plugin] ==> ignore
     arg [/usr/lib/gcc/aarch64-linux-gnu/12/liblto_plugin.so] ==> ignore
     arg [-plugin-opt=/usr/lib/gcc/aarch64-linux-gnu/12/lto-wrapper] ==> ignore
-    arg [-plugin-opt=-fresolution=/tmp/ccw2HLss.res] ==> ignore
+    arg [-plugin-opt=-fresolution=/tmp/ccrVDdeM.res] ==> ignore
     arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
     arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
     arg [-plugin-opt=-pass-through=-lc] ==> ignore
@@ -185,7 +185,7 @@ Parsed CXX implicit link information from above output:
     arg [--fix-cortex-a53-843419] ==> ignore
     arg [-pie] ==> ignore
     arg [-o] ==> ignore
-    arg [cmTC_7bfd1] ==> ignore
+    arg [cmTC_92292] ==> ignore
     arg [/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/Scrt1.o] ==> obj [/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/Scrt1.o]
     arg [/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crti.o] ==> obj [/usr/lib/gcc/aarch64-linux-gnu/12/../../../aarch64-linux-gnu/crti.o]
     arg [/usr/lib/gcc/aarch64-linux-gnu/12/crtbeginS.o] ==> obj [/usr/lib/gcc/aarch64-linux-gnu/12/crtbeginS.o]
@@ -197,7 +197,7 @@ Parsed CXX implicit link information from above output:
     arg [-L/usr/lib/aarch64-linux-gnu] ==> dir [/usr/lib/aarch64-linux-gnu]
     arg [-L/usr/lib/../lib] ==> dir [/usr/lib/../lib]
     arg [-L/usr/lib/gcc/aarch64-linux-gnu/12/../../..] ==> dir [/usr/lib/gcc/aarch64-linux-gnu/12/../../..]
-    arg [CMakeFiles/cmTC_7bfd1.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
+    arg [CMakeFiles/cmTC_92292.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
     arg [-lstdc++] ==> lib [stdc++]
     arg [-lm] ==> lib [m]
     arg [-lgcc_s] ==> lib [gcc_s]
@@ -224,3 +224,38 @@ Parsed CXX implicit link information from above output:
   implicit fwks: []
 
 
+Performing C++ SOURCE FILE Test CMAKE_HAVE_LIBC_PTHREAD succeeded with the following output:
+Change Dir: /home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-ZZrfaa
+
+Run Build Command(s):/usr/bin/gmake -f Makefile cmTC_23137/fast && /usr/bin/gmake  -f CMakeFiles/cmTC_23137.dir/build.make CMakeFiles/cmTC_23137.dir/build
+gmake[1]: Entering directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-ZZrfaa'
+Building CXX object CMakeFiles/cmTC_23137.dir/src.cxx.o
+/usr/bin/c++ -DCMAKE_HAVE_LIBC_PTHREAD  -std=gnu++17 -o CMakeFiles/cmTC_23137.dir/src.cxx.o -c /home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-ZZrfaa/src.cxx
+Linking CXX executable cmTC_23137
+/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_23137.dir/link.txt --verbose=1
+/usr/bin/c++ CMakeFiles/cmTC_23137.dir/src.cxx.o -o cmTC_23137 
+gmake[1]: Leaving directory '/home/pi/CoralEdgeTpu/build/CMakeFiles/CMakeScratch/TryCompile-ZZrfaa'
+
+
+Source file was:
+#include <pthread.h>
+
+static void* test_func(void* data)
+{
+  return data;
+}
+
+int main(void)
+{
+  pthread_t thread;
+  pthread_create(&thread, NULL, test_func, NULL);
+  pthread_detach(thread);
+  pthread_cancel(thread);
+  pthread_join(thread, NULL);
+  pthread_atfork(NULL, NULL, NULL);
+  pthread_exit(NULL);
+
+  return 0;
+}
+
+
diff --git a/build/CMakeFiles/Makefile.cmake b/build/CMakeFiles/Makefile.cmake
index 9013da8..8feedd9 100644
--- a/build/CMakeFiles/Makefile.cmake
+++ b/build/CMakeFiles/Makefile.cmake
@@ -34,6 +34,9 @@ set(CMAKE_MAKEFILE_DEPENDS
   "/usr/share/cmake-3.25/Modules/CMakeTestCXXCompiler.cmake"
   "/usr/share/cmake-3.25/Modules/CMakeTestCompilerCommon.cmake"
   "/usr/share/cmake-3.25/Modules/CMakeUnixFindMake.cmake"
+  "/usr/share/cmake-3.25/Modules/CheckCXXSourceCompiles.cmake"
+  "/usr/share/cmake-3.25/Modules/CheckIncludeFileCXX.cmake"
+  "/usr/share/cmake-3.25/Modules/CheckLibraryExists.cmake"
   "/usr/share/cmake-3.25/Modules/Compiler/ADSP-DetermineCompiler.cmake"
   "/usr/share/cmake-3.25/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
   "/usr/share/cmake-3.25/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
@@ -78,6 +81,8 @@ set(CMAKE_MAKEFILE_DEPENDS
   "/usr/share/cmake-3.25/Modules/FindPackageHandleStandardArgs.cmake"
   "/usr/share/cmake-3.25/Modules/FindPackageMessage.cmake"
   "/usr/share/cmake-3.25/Modules/FindPkgConfig.cmake"
+  "/usr/share/cmake-3.25/Modules/FindThreads.cmake"
+  "/usr/share/cmake-3.25/Modules/Internal/CheckSourceCompiles.cmake"
   "/usr/share/cmake-3.25/Modules/Internal/FeatureTesting.cmake"
   "/usr/share/cmake-3.25/Modules/Platform/Linux-Determine-CXX.cmake"
   "/usr/share/cmake-3.25/Modules/Platform/Linux-GNU-CXX.cmake"
diff --git a/build/CMakeFiles/detector.dir/DependInfo.cmake b/build/CMakeFiles/detector.dir/DependInfo.cmake
index 061852e..12cc75d 100644
--- a/build/CMakeFiles/detector.dir/DependInfo.cmake
+++ b/build/CMakeFiles/detector.dir/DependInfo.cmake
@@ -12,8 +12,8 @@ set(CMAKE_DEPENDS_DEPENDENCY_FILES
   "/home/pi/CoralEdgeTpu/src/inference.cpp" "CMakeFiles/detector.dir/src/inference.cpp.o" "gcc" "CMakeFiles/detector.dir/src/inference.cpp.o.d"
   "/home/pi/CoralEdgeTpu/src/jpeg_wrapper.cpp" "CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o" "gcc" "CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d"
   "/home/pi/CoralEdgeTpu/src/main.cpp" "CMakeFiles/detector.dir/src/main.cpp.o" "gcc" "CMakeFiles/detector.dir/src/main.cpp.o.d"
+  "/home/pi/CoralEdgeTpu/src/mjpeg_capture.cpp" "CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o" "gcc" "CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o.d"
   "/home/pi/CoralEdgeTpu/src/mjpeg_server.cpp" "CMakeFiles/detector.dir/src/mjpeg_server.cpp.o" "gcc" "CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d"
-  "/home/pi/CoralEdgeTpu/src/output_processor.cpp" "CMakeFiles/detector.dir/src/output_processor.cpp.o" "gcc" "CMakeFiles/detector.dir/src/output_processor.cpp.o.d"
   "/home/pi/CoralEdgeTpu/src/udp_sender.cpp" "CMakeFiles/detector.dir/src/udp_sender.cpp.o" "gcc" "CMakeFiles/detector.dir/src/udp_sender.cpp.o.d"
   "/home/pi/CoralEdgeTpu/src/util_logging.cpp" "CMakeFiles/detector.dir/src/util_logging.cpp.o" "gcc" "CMakeFiles/detector.dir/src/util_logging.cpp.o.d"
   )
diff --git a/build/CMakeFiles/detector.dir/build.make b/build/CMakeFiles/detector.dir/build.make
index 34fcb4e..400bf71 100644
--- a/build/CMakeFiles/detector.dir/build.make
+++ b/build/CMakeFiles/detector.dir/build.make
@@ -97,10 +97,24 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.s: cmake_force
 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/detector.dir/src/camera_capture.cpp.s"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/pi/CoralEdgeTpu/src/camera_capture.cpp -o CMakeFiles/detector.dir/src/camera_capture.cpp.s
 
+CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o: CMakeFiles/detector.dir/flags.make
+CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o: /home/pi/CoralEdgeTpu/src/mjpeg_capture.cpp
+CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building CXX object CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o"
+	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o -MF CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o.d -o CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o -c /home/pi/CoralEdgeTpu/src/mjpeg_capture.cpp
+
+CMakeFiles/detector.dir/src/mjpeg_capture.cpp.i: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/detector.dir/src/mjpeg_capture.cpp.i"
+	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/pi/CoralEdgeTpu/src/mjpeg_capture.cpp > CMakeFiles/detector.dir/src/mjpeg_capture.cpp.i
+
+CMakeFiles/detector.dir/src/mjpeg_capture.cpp.s: cmake_force
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/detector.dir/src/mjpeg_capture.cpp.s"
+	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/pi/CoralEdgeTpu/src/mjpeg_capture.cpp -o CMakeFiles/detector.dir/src/mjpeg_capture.cpp.s
+
 CMakeFiles/detector.dir/src/inference.cpp.o: CMakeFiles/detector.dir/flags.make
 CMakeFiles/detector.dir/src/inference.cpp.o: /home/pi/CoralEdgeTpu/src/inference.cpp
 CMakeFiles/detector.dir/src/inference.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building CXX object CMakeFiles/detector.dir/src/inference.cpp.o"
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building CXX object CMakeFiles/detector.dir/src/inference.cpp.o"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/inference.cpp.o -MF CMakeFiles/detector.dir/src/inference.cpp.o.d -o CMakeFiles/detector.dir/src/inference.cpp.o -c /home/pi/CoralEdgeTpu/src/inference.cpp
 
 CMakeFiles/detector.dir/src/inference.cpp.i: cmake_force
@@ -114,7 +128,7 @@ CMakeFiles/detector.dir/src/inference.cpp.s: cmake_force
 CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: CMakeFiles/detector.dir/flags.make
 CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: /home/pi/CoralEdgeTpu/src/mjpeg_server.cpp
 CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building CXX object CMakeFiles/detector.dir/src/mjpeg_server.cpp.o"
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building CXX object CMakeFiles/detector.dir/src/mjpeg_server.cpp.o"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/mjpeg_server.cpp.o -MF CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d -o CMakeFiles/detector.dir/src/mjpeg_server.cpp.o -c /home/pi/CoralEdgeTpu/src/mjpeg_server.cpp
 
 CMakeFiles/detector.dir/src/mjpeg_server.cpp.i: cmake_force
@@ -128,7 +142,7 @@ CMakeFiles/detector.dir/src/mjpeg_server.cpp.s: cmake_force
 CMakeFiles/detector.dir/src/udp_sender.cpp.o: CMakeFiles/detector.dir/flags.make
 CMakeFiles/detector.dir/src/udp_sender.cpp.o: /home/pi/CoralEdgeTpu/src/udp_sender.cpp
 CMakeFiles/detector.dir/src/udp_sender.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building CXX object CMakeFiles/detector.dir/src/udp_sender.cpp.o"
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Building CXX object CMakeFiles/detector.dir/src/udp_sender.cpp.o"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/udp_sender.cpp.o -MF CMakeFiles/detector.dir/src/udp_sender.cpp.o.d -o CMakeFiles/detector.dir/src/udp_sender.cpp.o -c /home/pi/CoralEdgeTpu/src/udp_sender.cpp
 
 CMakeFiles/detector.dir/src/udp_sender.cpp.i: cmake_force
@@ -142,7 +156,7 @@ CMakeFiles/detector.dir/src/udp_sender.cpp.s: cmake_force
 CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o: CMakeFiles/detector.dir/flags.make
 CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o: /home/pi/CoralEdgeTpu/src/jpeg_wrapper.cpp
 CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Building CXX object CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o"
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_7) "Building CXX object CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o -MF CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d -o CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o -c /home/pi/CoralEdgeTpu/src/jpeg_wrapper.cpp
 
 CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.i: cmake_force
@@ -156,7 +170,7 @@ CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.s: cmake_force
 CMakeFiles/detector.dir/src/util_logging.cpp.o: CMakeFiles/detector.dir/flags.make
 CMakeFiles/detector.dir/src/util_logging.cpp.o: /home/pi/CoralEdgeTpu/src/util_logging.cpp
 CMakeFiles/detector.dir/src/util_logging.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_7) "Building CXX object CMakeFiles/detector.dir/src/util_logging.cpp.o"
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_8) "Building CXX object CMakeFiles/detector.dir/src/util_logging.cpp.o"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/util_logging.cpp.o -MF CMakeFiles/detector.dir/src/util_logging.cpp.o.d -o CMakeFiles/detector.dir/src/util_logging.cpp.o -c /home/pi/CoralEdgeTpu/src/util_logging.cpp
 
 CMakeFiles/detector.dir/src/util_logging.cpp.i: cmake_force
@@ -167,42 +181,28 @@ CMakeFiles/detector.dir/src/util_logging.cpp.s: cmake_force
 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/detector.dir/src/util_logging.cpp.s"
 	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/pi/CoralEdgeTpu/src/util_logging.cpp -o CMakeFiles/detector.dir/src/util_logging.cpp.s
 
-CMakeFiles/detector.dir/src/output_processor.cpp.o: CMakeFiles/detector.dir/flags.make
-CMakeFiles/detector.dir/src/output_processor.cpp.o: /home/pi/CoralEdgeTpu/src/output_processor.cpp
-CMakeFiles/detector.dir/src/output_processor.cpp.o: CMakeFiles/detector.dir/compiler_depend.ts
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_8) "Building CXX object CMakeFiles/detector.dir/src/output_processor.cpp.o"
-	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -MD -MT CMakeFiles/detector.dir/src/output_processor.cpp.o -MF CMakeFiles/detector.dir/src/output_processor.cpp.o.d -o CMakeFiles/detector.dir/src/output_processor.cpp.o -c /home/pi/CoralEdgeTpu/src/output_processor.cpp
-
-CMakeFiles/detector.dir/src/output_processor.cpp.i: cmake_force
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/detector.dir/src/output_processor.cpp.i"
-	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/pi/CoralEdgeTpu/src/output_processor.cpp > CMakeFiles/detector.dir/src/output_processor.cpp.i
-
-CMakeFiles/detector.dir/src/output_processor.cpp.s: cmake_force
-	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/detector.dir/src/output_processor.cpp.s"
-	/usr/bin/c++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/pi/CoralEdgeTpu/src/output_processor.cpp -o CMakeFiles/detector.dir/src/output_processor.cpp.s
-
 # Object files for target detector
 detector_OBJECTS = \
 "CMakeFiles/detector.dir/src/main.cpp.o" \
 "CMakeFiles/detector.dir/src/camera_capture.cpp.o" \
+"CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o" \
 "CMakeFiles/detector.dir/src/inference.cpp.o" \
 "CMakeFiles/detector.dir/src/mjpeg_server.cpp.o" \
 "CMakeFiles/detector.dir/src/udp_sender.cpp.o" \
 "CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o" \
-"CMakeFiles/detector.dir/src/util_logging.cpp.o" \
-"CMakeFiles/detector.dir/src/output_processor.cpp.o"
+"CMakeFiles/detector.dir/src/util_logging.cpp.o"
 
 # External object files for target detector
 detector_EXTERNAL_OBJECTS =
 
 detector: CMakeFiles/detector.dir/src/main.cpp.o
 detector: CMakeFiles/detector.dir/src/camera_capture.cpp.o
+detector: CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o
 detector: CMakeFiles/detector.dir/src/inference.cpp.o
 detector: CMakeFiles/detector.dir/src/mjpeg_server.cpp.o
 detector: CMakeFiles/detector.dir/src/udp_sender.cpp.o
 detector: CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o
 detector: CMakeFiles/detector.dir/src/util_logging.cpp.o
-detector: CMakeFiles/detector.dir/src/output_processor.cpp.o
 detector: CMakeFiles/detector.dir/build.make
 detector: CMakeFiles/detector.dir/link.txt
 	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/pi/CoralEdgeTpu/build/CMakeFiles --progress-num=$(CMAKE_PROGRESS_9) "Linking CXX executable detector"
diff --git a/build/CMakeFiles/detector.dir/cmake_clean.cmake b/build/CMakeFiles/detector.dir/cmake_clean.cmake
index 6e15e5f..4951043 100644
--- a/build/CMakeFiles/detector.dir/cmake_clean.cmake
+++ b/build/CMakeFiles/detector.dir/cmake_clean.cmake
@@ -7,10 +7,10 @@ file(REMOVE_RECURSE
   "CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d"
   "CMakeFiles/detector.dir/src/main.cpp.o"
   "CMakeFiles/detector.dir/src/main.cpp.o.d"
+  "CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o"
+  "CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o.d"
   "CMakeFiles/detector.dir/src/mjpeg_server.cpp.o"
   "CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d"
-  "CMakeFiles/detector.dir/src/output_processor.cpp.o"
-  "CMakeFiles/detector.dir/src/output_processor.cpp.o.d"
   "CMakeFiles/detector.dir/src/udp_sender.cpp.o"
   "CMakeFiles/detector.dir/src/udp_sender.cpp.o.d"
   "CMakeFiles/detector.dir/src/util_logging.cpp.o"
diff --git a/build/CMakeFiles/detector.dir/flags.make b/build/CMakeFiles/detector.dir/flags.make
index 909f714..5afb33c 100644
--- a/build/CMakeFiles/detector.dir/flags.make
+++ b/build/CMakeFiles/detector.dir/flags.make
@@ -4,7 +4,7 @@
 # compile CXX with /usr/bin/c++
 CXX_DEFINES = 
 
-CXX_INCLUDES = -I/home/pi/CoralEdgeTpu/flatbuffers/include -I/usr/include/libcamera -I/home/pi/CoralEdgeTpu/include -I/home/pi/CoralEdgeTpu/include/tensorflow/lite -I/home/pi/CoralEdgeTpu/include/tensorflow/lite/c -I/home/pi/CoralEdgeTpu/include/tensorflow/lite/core
+CXX_INCLUDES = -I/home/pi/CoralEdgeTpu/include -I/home/pi/CoralEdgeTpu/flatbuffers/include
 
-CXX_FLAGS = -O3 -std=c++17 -std=c++17
+CXX_FLAGS = -std=gnu++17
 
diff --git a/build/CMakeFiles/detector.dir/link.txt b/build/CMakeFiles/detector.dir/link.txt
index 28686f9..83f8dc0 100644
--- a/build/CMakeFiles/detector.dir/link.txt
+++ b/build/CMakeFiles/detector.dir/link.txt
@@ -1 +1 @@
-/usr/bin/c++ "-Wl,-rpath,'\$$ORIGIN/../lib'" CMakeFiles/detector.dir/src/main.cpp.o CMakeFiles/detector.dir/src/camera_capture.cpp.o CMakeFiles/detector.dir/src/inference.cpp.o CMakeFiles/detector.dir/src/mjpeg_server.cpp.o CMakeFiles/detector.dir/src/udp_sender.cpp.o CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o CMakeFiles/detector.dir/src/util_logging.cpp.o CMakeFiles/detector.dir/src/output_processor.cpp.o -o detector   -L/home/pi/CoralEdgeTpu/flatbuffers/lib  -L/home/pi/CoralEdgeTpu/lib  -Wl,-rpath,/home/pi/CoralEdgeTpu/flatbuffers/lib:/home/pi/CoralEdgeTpu/lib -lflatbuffers -lcamera -lcamera-base -lusb-1.0 -ltensorflowlite -ledgetpu -ljpeg 
+/usr/bin/c++ "-Wl,-rpath,'\$$ORIGIN/../lib'" CMakeFiles/detector.dir/src/main.cpp.o CMakeFiles/detector.dir/src/camera_capture.cpp.o CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o CMakeFiles/detector.dir/src/inference.cpp.o CMakeFiles/detector.dir/src/mjpeg_server.cpp.o CMakeFiles/detector.dir/src/udp_sender.cpp.o CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o CMakeFiles/detector.dir/src/util_logging.cpp.o -o detector   -L/home/pi/CoralEdgeTpu/lib  -Wl,-rpath,/home/pi/CoralEdgeTpu/lib -ljpeg -ltensorflowlite -ledgetpu 
diff --git a/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o b/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o
index 68ddf3c..4e5d956 100644
Binary files a/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o and b/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o.d b/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o.d
index 4ca89ce..858875c 100644
--- a/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/camera_capture.cpp.o.d
@@ -1,9 +1,7 @@
 CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /home/pi/CoralEdgeTpu/src/camera_capture.cpp /usr/include/stdc-predef.h \
- /home/pi/CoralEdgeTpu/src/camera_capture.h \
- /usr/include/libcamera/libcamera/libcamera.h \
- /usr/include/libcamera/libcamera/camera.h \
- /usr/include/c++/12/initializer_list \
+ /home/pi/CoralEdgeTpu/src/camera_capture.h /usr/include/c++/12/thread \
+ /usr/include/c++/12/bits/std_thread.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/c++config.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/os_defines.h \
  /usr/include/features.h /usr/include/features-time64.h \
@@ -14,56 +12,16 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /usr/include/aarch64-linux-gnu/gnu/stubs.h \
  /usr/include/aarch64-linux-gnu/gnu/stubs-lp64.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/cpu_defines.h \
- /usr/include/c++/12/pstl/pstl_config.h /usr/include/c++/12/memory \
- /usr/include/c++/12/bits/stl_algobase.h \
- /usr/include/c++/12/bits/functexcept.h \
- /usr/include/c++/12/bits/exception_defines.h \
- /usr/include/c++/12/bits/cpp_type_traits.h \
- /usr/include/c++/12/ext/type_traits.h \
- /usr/include/c++/12/ext/numeric_traits.h \
- /usr/include/c++/12/bits/stl_pair.h /usr/include/c++/12/type_traits \
- /usr/include/c++/12/bits/move.h /usr/include/c++/12/bits/utility.h \
- /usr/include/c++/12/bits/stl_iterator_base_types.h \
- /usr/include/c++/12/bits/stl_iterator_base_funcs.h \
- /usr/include/c++/12/bits/concept_check.h \
- /usr/include/c++/12/debug/assertions.h \
- /usr/include/c++/12/bits/stl_iterator.h \
- /usr/include/c++/12/bits/ptr_traits.h /usr/include/c++/12/debug/debug.h \
- /usr/include/c++/12/bits/predefined_ops.h \
- /usr/include/c++/12/bits/allocator.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/c++allocator.h \
- /usr/include/c++/12/bits/new_allocator.h /usr/include/c++/12/new \
- /usr/include/c++/12/bits/exception.h \
- /usr/include/c++/12/bits/memoryfwd.h \
- /usr/include/c++/12/bits/stl_construct.h \
- /usr/include/c++/12/bits/stl_uninitialized.h \
- /usr/include/c++/12/ext/alloc_traits.h \
- /usr/include/c++/12/bits/alloc_traits.h \
- /usr/include/c++/12/bits/stl_tempbuf.h \
- /usr/include/c++/12/bits/stl_raw_storage_iter.h \
- /usr/include/c++/12/bits/align.h /usr/include/c++/12/bit \
- /usr/lib/gcc/aarch64-linux-gnu/12/include/stdint.h /usr/include/stdint.h \
- /usr/include/aarch64-linux-gnu/bits/libc-header-start.h \
- /usr/include/aarch64-linux-gnu/bits/types.h \
- /usr/include/aarch64-linux-gnu/bits/typesizes.h \
- /usr/include/aarch64-linux-gnu/bits/time64.h \
- /usr/include/aarch64-linux-gnu/bits/wchar.h \
- /usr/include/aarch64-linux-gnu/bits/stdint-intn.h \
- /usr/include/aarch64-linux-gnu/bits/stdint-uintn.h \
- /usr/include/c++/12/bits/uses_allocator.h \
- /usr/include/c++/12/bits/unique_ptr.h /usr/include/c++/12/tuple \
- /usr/include/c++/12/bits/invoke.h \
- /usr/include/c++/12/bits/stl_function.h \
- /usr/include/c++/12/backward/binders.h \
- /usr/include/c++/12/bits/functional_hash.h \
- /usr/include/c++/12/bits/hash_bytes.h \
- /usr/include/c++/12/bits/shared_ptr.h /usr/include/c++/12/iosfwd \
- /usr/include/c++/12/bits/stringfwd.h /usr/include/c++/12/bits/postypes.h \
+ /usr/include/c++/12/pstl/pstl_config.h /usr/include/c++/12/iosfwd \
+ /usr/include/c++/12/bits/stringfwd.h \
+ /usr/include/c++/12/bits/memoryfwd.h /usr/include/c++/12/bits/postypes.h \
  /usr/include/c++/12/cwchar /usr/include/wchar.h \
+ /usr/include/aarch64-linux-gnu/bits/libc-header-start.h \
  /usr/include/aarch64-linux-gnu/bits/floatn.h \
  /usr/include/aarch64-linux-gnu/bits/floatn-common.h \
  /usr/lib/gcc/aarch64-linux-gnu/12/include/stddef.h \
  /usr/lib/gcc/aarch64-linux-gnu/12/include/stdarg.h \
+ /usr/include/aarch64-linux-gnu/bits/wchar.h \
  /usr/include/aarch64-linux-gnu/bits/types/wint_t.h \
  /usr/include/aarch64-linux-gnu/bits/types/mbstate_t.h \
  /usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h \
@@ -71,14 +29,23 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/locale_t.h \
  /usr/include/aarch64-linux-gnu/bits/types/__locale_t.h \
- /usr/include/c++/12/bits/shared_ptr_base.h /usr/include/c++/12/typeinfo \
- /usr/include/c++/12/bits/allocated_ptr.h \
- /usr/include/c++/12/bits/refwrap.h \
- /usr/include/c++/12/ext/aligned_buffer.h \
- /usr/include/c++/12/ext/atomicity.h \
+ /usr/include/c++/12/tuple /usr/include/c++/12/bits/stl_pair.h \
+ /usr/include/c++/12/type_traits /usr/include/c++/12/bits/move.h \
+ /usr/include/c++/12/bits/utility.h \
+ /usr/include/c++/12/bits/uses_allocator.h \
+ /usr/include/c++/12/bits/invoke.h \
+ /usr/include/c++/12/bits/functional_hash.h \
+ /usr/include/c++/12/bits/hash_bytes.h /usr/include/c++/12/bits/refwrap.h \
+ /usr/include/c++/12/bits/stl_function.h \
+ /usr/include/c++/12/backward/binders.h \
+ /usr/include/c++/12/bits/unique_ptr.h \
+ /usr/include/c++/12/debug/assertions.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/gthr.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/gthr-default.h \
  /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/aarch64-linux-gnu/bits/types.h \
+ /usr/include/aarch64-linux-gnu/bits/typesizes.h \
+ /usr/include/aarch64-linux-gnu/bits/time64.h \
  /usr/include/aarch64-linux-gnu/bits/types/time_t.h \
  /usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h \
  /usr/include/aarch64-linux-gnu/bits/endian.h \
@@ -104,33 +71,50 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/__sigset_t.h \
  /usr/include/aarch64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
  /usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/atomic_word.h \
- /usr/include/aarch64-linux-gnu/sys/single_threaded.h \
- /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/exception \
- /usr/include/c++/12/bits/exception_ptr.h \
- /usr/include/c++/12/bits/cxxabi_init_exception.h \
- /usr/include/c++/12/bits/nested_exception.h \
- /usr/include/c++/12/bits/shared_ptr_atomic.h \
- /usr/include/c++/12/bits/atomic_base.h \
+ /usr/include/c++/12/bits/this_thread_sleep.h \
+ /usr/include/c++/12/bits/chrono.h /usr/include/c++/12/ratio \
+ /usr/include/c++/12/cstdint \
+ /usr/lib/gcc/aarch64-linux-gnu/12/include/stdint.h /usr/include/stdint.h \
+ /usr/include/aarch64-linux-gnu/bits/stdint-intn.h \
+ /usr/include/aarch64-linux-gnu/bits/stdint-uintn.h \
+ /usr/include/c++/12/limits /usr/include/c++/12/ctime \
+ /usr/include/c++/12/bits/parse_numbers.h \
+ /usr/include/c++/12/ext/numeric_traits.h \
+ /usr/include/c++/12/bits/cpp_type_traits.h \
+ /usr/include/c++/12/ext/type_traits.h /usr/include/c++/12/cerrno \
+ /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
+ /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/12/atomic /usr/include/c++/12/bits/atomic_base.h \
  /usr/include/c++/12/bits/atomic_lockfree_defines.h \
- /usr/include/c++/12/backward/auto_ptr.h \
- /usr/include/c++/12/pstl/glue_memory_defs.h \
- /usr/include/c++/12/pstl/execution_defs.h /usr/include/c++/12/optional \
- /usr/include/c++/12/bits/enable_special_members.h \
- /usr/include/c++/12/set /usr/include/c++/12/bits/stl_tree.h \
- /usr/include/c++/12/bits/node_handle.h \
- /usr/include/c++/12/bits/stl_set.h \
- /usr/include/c++/12/bits/stl_multiset.h \
- /usr/include/c++/12/bits/range_access.h \
- /usr/include/c++/12/bits/erase_if.h /usr/include/c++/12/string \
- /usr/include/c++/12/bits/char_traits.h /usr/include/c++/12/cstdint \
+ /usr/include/c++/12/string /usr/include/c++/12/bits/char_traits.h \
+ /usr/include/c++/12/bits/allocator.h \
+ /usr/include/aarch64-linux-gnu/c++/12/bits/c++allocator.h \
+ /usr/include/c++/12/bits/new_allocator.h /usr/include/c++/12/new \
+ /usr/include/c++/12/bits/exception.h \
+ /usr/include/c++/12/bits/functexcept.h \
+ /usr/include/c++/12/bits/exception_defines.h \
  /usr/include/c++/12/bits/localefwd.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/c++locale.h \
  /usr/include/c++/12/clocale /usr/include/locale.h \
  /usr/include/aarch64-linux-gnu/bits/locale.h /usr/include/c++/12/cctype \
  /usr/include/ctype.h /usr/include/c++/12/bits/ostream_insert.h \
  /usr/include/c++/12/bits/cxxabi_forced.h \
- /usr/include/c++/12/bits/basic_string.h /usr/include/c++/12/string_view \
+ /usr/include/c++/12/bits/stl_iterator_base_types.h \
+ /usr/include/c++/12/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/12/bits/concept_check.h \
+ /usr/include/c++/12/bits/stl_iterator.h \
+ /usr/include/c++/12/bits/ptr_traits.h \
+ /usr/include/c++/12/bits/stl_algobase.h \
+ /usr/include/c++/12/debug/debug.h \
+ /usr/include/c++/12/bits/predefined_ops.h \
+ /usr/include/c++/12/bits/range_access.h \
+ /usr/include/c++/12/initializer_list \
+ /usr/include/c++/12/bits/basic_string.h \
+ /usr/include/c++/12/ext/alloc_traits.h \
+ /usr/include/c++/12/bits/alloc_traits.h \
+ /usr/include/c++/12/bits/stl_construct.h /usr/include/c++/12/string_view \
  /usr/include/c++/12/bits/string_view.tcc \
  /usr/include/c++/12/ext/string_conversions.h /usr/include/c++/12/cstdlib \
  /usr/include/stdlib.h /usr/include/aarch64-linux-gnu/bits/waitflags.h \
@@ -141,9 +125,7 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /usr/include/aarch64-linux-gnu/sys/select.h \
  /usr/include/aarch64-linux-gnu/bits/select.h \
  /usr/include/aarch64-linux-gnu/bits/types/sigset_t.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
  /usr/include/stdio.h \
  /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
@@ -151,86 +133,56 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
- /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
- /usr/include/c++/12/bits/basic_string.tcc \
- /usr/include/libcamera/libcamera/base/class.h \
- /usr/include/libcamera/libcamera/base/flags.h \
- /usr/include/libcamera/libcamera/base/object.h /usr/include/c++/12/list \
- /usr/include/c++/12/bits/stl_list.h /usr/include/c++/12/bits/list.tcc \
- /usr/include/c++/12/utility /usr/include/c++/12/bits/stl_relops.h \
- /usr/include/c++/12/vector /usr/include/c++/12/bits/stl_vector.h \
+ /usr/include/c++/12/bits/basic_string.tcc /usr/include/c++/12/vector \
+ /usr/include/c++/12/bits/stl_uninitialized.h \
+ /usr/include/c++/12/bits/stl_vector.h \
  /usr/include/c++/12/bits/stl_bvector.h \
- /usr/include/c++/12/bits/vector.tcc \
- /usr/include/libcamera/libcamera/base/bound_method.h \
- /usr/include/libcamera/libcamera/base/signal.h \
- /usr/include/c++/12/functional /usr/include/c++/12/bits/std_function.h \
- /usr/include/c++/12/unordered_map /usr/include/c++/12/bits/hashtable.h \
- /usr/include/c++/12/bits/hashtable_policy.h \
- /usr/include/c++/12/bits/unordered_map.h /usr/include/c++/12/array \
- /usr/include/c++/12/compare /usr/include/c++/12/bits/stl_algo.h \
- /usr/include/c++/12/bits/algorithmfwd.h \
- /usr/include/c++/12/bits/stl_heap.h \
- /usr/include/c++/12/bits/uniform_int_dist.h \
- /usr/include/libcamera/libcamera/controls.h /usr/include/assert.h \
- /usr/include/c++/12/map /usr/include/c++/12/bits/stl_map.h \
- /usr/include/c++/12/bits/stl_multimap.h \
- /usr/include/libcamera/libcamera/base/span.h \
- /usr/include/c++/12/iterator /usr/include/c++/12/bits/stream_iterator.h \
- /usr/include/c++/12/bits/streambuf_iterator.h \
- /usr/include/c++/12/streambuf /usr/include/c++/12/bits/ios_base.h \
- /usr/include/c++/12/bits/locale_classes.h \
- /usr/include/c++/12/bits/locale_classes.tcc \
+ /usr/include/c++/12/bits/vector.tcc /usr/include/c++/12/chrono \
+ /usr/include/c++/12/memory /usr/include/c++/12/bits/stl_tempbuf.h \
+ /usr/include/c++/12/bits/stl_raw_storage_iter.h \
+ /usr/include/c++/12/bits/align.h /usr/include/c++/12/bit \
+ /usr/include/c++/12/bits/shared_ptr.h \
+ /usr/include/c++/12/bits/shared_ptr_base.h /usr/include/c++/12/typeinfo \
+ /usr/include/c++/12/bits/allocated_ptr.h \
+ /usr/include/c++/12/ext/aligned_buffer.h \
+ /usr/include/c++/12/ext/atomicity.h \
+ /usr/include/aarch64-linux-gnu/c++/12/bits/atomic_word.h \
+ /usr/include/aarch64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/exception \
+ /usr/include/c++/12/bits/exception_ptr.h \
+ /usr/include/c++/12/bits/cxxabi_init_exception.h \
+ /usr/include/c++/12/bits/nested_exception.h \
+ /usr/include/c++/12/bits/shared_ptr_atomic.h \
+ /usr/include/c++/12/backward/auto_ptr.h \
+ /usr/include/c++/12/pstl/glue_memory_defs.h \
+ /usr/include/c++/12/pstl/execution_defs.h \
+ /home/pi/CoralEdgeTpu/src/pipeline_structs.h /usr/include/c++/12/queue \
+ /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
+ /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_heap.h \
+ /usr/include/c++/12/bits/stl_queue.h /usr/include/c++/12/mutex \
  /usr/include/c++/12/system_error \
  /usr/include/aarch64-linux-gnu/c++/12/bits/error_constants.h \
- /usr/include/c++/12/stdexcept /usr/include/c++/12/bits/streambuf.tcc \
- /usr/include/c++/12/limits /usr/include/libcamera/libcamera/geometry.h \
- /usr/include/c++/12/algorithm \
- /usr/include/c++/12/pstl/glue_algorithm_defs.h \
- /usr/include/c++/12/ostream /usr/include/c++/12/ios \
+ /usr/include/c++/12/stdexcept /usr/include/c++/12/bits/std_mutex.h \
+ /usr/include/c++/12/bits/unique_lock.h \
+ /usr/include/c++/12/condition_variable \
+ /home/pi/CoralEdgeTpu/src/process_supervisor.hpp \
+ /home/pi/CoralEdgeTpu/src/util_logging.h /usr/include/c++/12/fstream \
+ /usr/include/c++/12/istream /usr/include/c++/12/ios \
+ /usr/include/c++/12/bits/ios_base.h \
+ /usr/include/c++/12/bits/locale_classes.h \
+ /usr/include/c++/12/bits/locale_classes.tcc \
+ /usr/include/c++/12/streambuf /usr/include/c++/12/bits/streambuf.tcc \
  /usr/include/c++/12/bits/basic_ios.h \
  /usr/include/c++/12/bits/locale_facets.h /usr/include/c++/12/cwctype \
  /usr/include/wctype.h /usr/include/aarch64-linux-gnu/bits/wctype-wchar.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/ctype_base.h \
+ /usr/include/c++/12/bits/streambuf_iterator.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/ctype_inline.h \
  /usr/include/c++/12/bits/locale_facets.tcc \
- /usr/include/c++/12/bits/basic_ios.tcc \
+ /usr/include/c++/12/bits/basic_ios.tcc /usr/include/c++/12/ostream \
  /usr/include/c++/12/bits/ostream.tcc \
- /usr/include/libcamera/libcamera/orientation.h \
- /usr/include/c++/12/iostream /usr/include/c++/12/istream \
- /usr/include/c++/12/bits/istream.tcc \
- /usr/include/libcamera/libcamera/request.h \
- /usr/include/libcamera/libcamera/fence.h \
- /usr/include/libcamera/libcamera/base/unique_fd.h \
- /usr/include/libcamera/libcamera/stream.h \
- /usr/include/libcamera/libcamera/color_space.h \
- /usr/include/libcamera/libcamera/framebuffer.h \
- /usr/include/libcamera/libcamera/base/shared_fd.h \
- /usr/include/libcamera/libcamera/pixel_format.h \
- /usr/include/libcamera/libcamera/camera_manager.h \
- /usr/include/libcamera/libcamera/control_ids.h \
- /usr/include/libcamera/libcamera/formats.h \
- /usr/include/libcamera/libcamera/framebuffer_allocator.h \
- /usr/include/libcamera/libcamera/logging.h \
- /usr/include/libcamera/libcamera/property_ids.h \
- /usr/include/libcamera/libcamera/transform.h \
- /usr/include/libcamera/libcamera/version.h /usr/include/c++/12/thread \
- /usr/include/c++/12/bits/std_thread.h \
- /usr/include/c++/12/bits/this_thread_sleep.h \
- /usr/include/c++/12/bits/chrono.h /usr/include/c++/12/ratio \
- /usr/include/c++/12/ctime /usr/include/c++/12/bits/parse_numbers.h \
- /usr/include/c++/12/mutex /usr/include/c++/12/bits/std_mutex.h \
- /usr/include/c++/12/bits/unique_lock.h \
- /usr/include/c++/12/condition_variable /usr/include/c++/12/queue \
- /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
- /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_queue.h \
- /usr/include/c++/12/atomic /usr/include/c++/12/chrono \
- /home/pi/CoralEdgeTpu/src/util_logging.h /usr/include/c++/12/fstream \
- /usr/include/c++/12/bits/codecvt.h \
+ /usr/include/c++/12/bits/istream.tcc /usr/include/c++/12/bits/codecvt.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/basic_file.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/c++io.h \
  /usr/include/c++/12/bits/fstream.tcc /usr/include/c++/12/iomanip \
@@ -241,22 +193,71 @@ CMakeFiles/detector.dir/src/camera_capture.cpp.o: \
  /usr/include/libintl.h /usr/include/c++/12/bits/locale_facets_nonio.tcc \
  /usr/include/c++/12/bits/locale_conv.h \
  /usr/include/c++/12/bits/quoted_string.h /usr/include/c++/12/sstream \
- /usr/include/c++/12/bits/sstream.tcc /usr/include/fcntl.h \
- /usr/include/aarch64-linux-gnu/bits/fcntl.h \
- /usr/include/aarch64-linux-gnu/bits/fcntl-linux.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
- /usr/include/linux/falloc.h /usr/include/aarch64-linux-gnu/bits/stat.h \
- /usr/include/aarch64-linux-gnu/bits/struct_stat.h \
- /usr/include/aarch64-linux-gnu/sys/mman.h \
- /usr/include/aarch64-linux-gnu/bits/mman.h \
- /usr/include/aarch64-linux-gnu/bits/mman-map-flags-generic.h \
- /usr/include/aarch64-linux-gnu/bits/mman-linux.h \
- /usr/include/aarch64-linux-gnu/bits/mman-shared.h \
- /usr/include/aarch64-linux-gnu/bits/mman_ext.h /usr/include/unistd.h \
+ /usr/include/c++/12/bits/sstream.tcc /usr/include/c++/12/functional \
+ /usr/include/c++/12/bits/std_function.h \
+ /usr/include/c++/12/unordered_map /usr/include/c++/12/bits/hashtable.h \
+ /usr/include/c++/12/bits/hashtable_policy.h \
+ /usr/include/c++/12/bits/enable_special_members.h \
+ /usr/include/c++/12/bits/node_handle.h \
+ /usr/include/c++/12/bits/unordered_map.h \
+ /usr/include/c++/12/bits/erase_if.h /usr/include/c++/12/array \
+ /usr/include/c++/12/compare /usr/include/c++/12/bits/stl_algo.h \
+ /usr/include/c++/12/bits/algorithmfwd.h \
+ /usr/include/c++/12/bits/uniform_int_dist.h /usr/include/c++/12/numeric \
+ /usr/include/c++/12/bits/stl_numeric.h \
+ /usr/include/c++/12/pstl/glue_numeric_defs.h /usr/include/unistd.h \
  /usr/include/aarch64-linux-gnu/bits/posix_opt.h \
  /usr/include/aarch64-linux-gnu/bits/environments.h \
  /usr/include/aarch64-linux-gnu/bits/confname.h \
  /usr/include/aarch64-linux-gnu/bits/getopt_posix.h \
  /usr/include/aarch64-linux-gnu/bits/getopt_core.h \
  /usr/include/aarch64-linux-gnu/bits/unistd_ext.h \
- /usr/include/linux/close_range.h
+ /usr/include/linux/close_range.h \
+ /usr/include/aarch64-linux-gnu/sys/wait.h /usr/include/signal.h \
+ /usr/include/aarch64-linux-gnu/bits/signum-generic.h \
+ /usr/include/aarch64-linux-gnu/bits/signum-arch.h \
+ /usr/include/aarch64-linux-gnu/bits/types/sig_atomic_t.h \
+ /usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h \
+ /usr/include/aarch64-linux-gnu/bits/types/__sigval_t.h \
+ /usr/include/aarch64-linux-gnu/bits/siginfo-arch.h \
+ /usr/include/aarch64-linux-gnu/bits/siginfo-consts.h \
+ /usr/include/aarch64-linux-gnu/bits/siginfo-consts-arch.h \
+ /usr/include/aarch64-linux-gnu/bits/types/sigval_t.h \
+ /usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h \
+ /usr/include/aarch64-linux-gnu/bits/sigevent-consts.h \
+ /usr/include/aarch64-linux-gnu/bits/sigaction.h \
+ /usr/include/aarch64-linux-gnu/bits/sigcontext.h \
+ /usr/lib/linux/uapi/arm64/asm/sigcontext.h /usr/include/linux/types.h \
+ /usr/lib/linux/uapi/arm64/asm/types.h /usr/include/asm-generic/types.h \
+ /usr/include/asm-generic/int-ll64.h \
+ /usr/lib/linux/uapi/arm64/asm/bitsperlong.h \
+ /usr/include/asm-generic/bitsperlong.h /usr/include/linux/posix_types.h \
+ /usr/include/linux/stddef.h /usr/lib/linux/uapi/arm64/asm/posix_types.h \
+ /usr/include/asm-generic/posix_types.h \
+ /usr/lib/linux/uapi/arm64/asm/sve_context.h \
+ /usr/include/aarch64-linux-gnu/bits/types/stack_t.h \
+ /usr/include/aarch64-linux-gnu/sys/ucontext.h \
+ /usr/include/aarch64-linux-gnu/sys/procfs.h \
+ /usr/include/aarch64-linux-gnu/sys/time.h \
+ /usr/include/aarch64-linux-gnu/sys/user.h \
+ /usr/include/aarch64-linux-gnu/bits/procfs.h \
+ /usr/include/aarch64-linux-gnu/bits/procfs-id.h \
+ /usr/include/aarch64-linux-gnu/bits/procfs-prregset.h \
+ /usr/include/aarch64-linux-gnu/bits/procfs-extra.h \
+ /usr/include/aarch64-linux-gnu/bits/sigstack.h \
+ /usr/include/aarch64-linux-gnu/bits/sigstksz.h \
+ /usr/include/aarch64-linux-gnu/bits/ss_flags.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_sigstack.h \
+ /usr/include/aarch64-linux-gnu/bits/sigthread.h \
+ /usr/include/aarch64-linux-gnu/bits/signal_ext.h \
+ /usr/include/aarch64-linux-gnu/bits/types/idtype_t.h \
+ /usr/include/c++/12/csignal /usr/include/fcntl.h \
+ /usr/include/aarch64-linux-gnu/bits/fcntl.h \
+ /usr/include/aarch64-linux-gnu/bits/fcntl-linux.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
+ /usr/include/linux/falloc.h /usr/include/aarch64-linux-gnu/bits/stat.h \
+ /usr/include/aarch64-linux-gnu/bits/struct_stat.h \
+ /usr/include/c++/12/cstring /usr/include/string.h /usr/include/strings.h \
+ /usr/include/c++/12/algorithm \
+ /usr/include/c++/12/pstl/glue_algorithm_defs.h \
+ /usr/include/c++/12/iostream
diff --git a/build/CMakeFiles/detector.dir/src/inference.cpp.o b/build/CMakeFiles/detector.dir/src/inference.cpp.o
index 5ea8d01..98824c2 100644
Binary files a/build/CMakeFiles/detector.dir/src/inference.cpp.o and b/build/CMakeFiles/detector.dir/src/inference.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/inference.cpp.o.d b/build/CMakeFiles/detector.dir/src/inference.cpp.o.d
index 2df57fb..bb62416 100644
--- a/build/CMakeFiles/detector.dir/src/inference.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/inference.cpp.o.d
@@ -62,9 +62,7 @@ CMakeFiles/detector.dir/src/inference.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h \
  /usr/include/aarch64-linux-gnu/bits/struct_mutex.h \
  /usr/include/aarch64-linux-gnu/bits/struct_rwlock.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/specfun.h \
  /usr/include/c++/12/bits/stl_algobase.h \
  /usr/include/c++/12/bits/functexcept.h \
@@ -152,10 +150,10 @@ CMakeFiles/detector.dir/src/inference.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/c++/12/cerrno /usr/include/errno.h \
+ /usr/include/aarch64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/lib/linux/uapi/arm64/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h \
  /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
  /usr/include/c++/12/bits/basic_string.tcc \
@@ -244,43 +242,26 @@ CMakeFiles/detector.dir/src/inference.cpp.o: \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/verifier.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/mutable_op_resolver.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/kernels/register.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/builtin_op_data.h \
  /usr/include/c++/12/thread /usr/include/c++/12/bits/std_thread.h \
  /usr/include/c++/12/bits/this_thread_sleep.h \
  /usr/include/c++/12/bits/chrono.h /usr/include/c++/12/ratio \
  /usr/include/c++/12/ctime /usr/include/c++/12/bits/parse_numbers.h \
- /usr/include/c++/12/mutex /usr/include/c++/12/bits/std_mutex.h \
- /usr/include/c++/12/bits/unique_lock.h \
- /usr/include/c++/12/condition_variable /usr/include/c++/12/queue \
+ /usr/include/c++/12/atomic /home/pi/CoralEdgeTpu/src/pipeline_structs.h \
+ /usr/include/c++/12/chrono /usr/include/c++/12/queue \
  /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
  /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_queue.h \
- /usr/include/c++/12/atomic /usr/include/c++/12/chrono \
- /home/pi/CoralEdgeTpu/src/camera_capture.h \
- /usr/include/libcamera/libcamera/libcamera.h \
- /usr/include/libcamera/libcamera/camera.h /usr/include/c++/12/optional \
- /usr/include/libcamera/libcamera/base/class.h \
- /usr/include/libcamera/libcamera/base/flags.h \
- /usr/include/libcamera/libcamera/base/object.h /usr/include/c++/12/list \
- /usr/include/c++/12/bits/stl_list.h /usr/include/c++/12/bits/list.tcc \
- /usr/include/libcamera/libcamera/base/bound_method.h \
- /usr/include/libcamera/libcamera/base/signal.h \
- /usr/include/libcamera/libcamera/controls.h \
- /usr/include/libcamera/libcamera/base/span.h \
- /usr/include/libcamera/libcamera/geometry.h \
- /usr/include/libcamera/libcamera/orientation.h \
- /usr/include/c++/12/iostream /usr/include/libcamera/libcamera/request.h \
- /usr/include/libcamera/libcamera/fence.h \
- /usr/include/libcamera/libcamera/base/unique_fd.h \
- /usr/include/libcamera/libcamera/stream.h \
- /usr/include/libcamera/libcamera/color_space.h \
- /usr/include/libcamera/libcamera/framebuffer.h \
- /usr/include/libcamera/libcamera/base/shared_fd.h \
- /usr/include/libcamera/libcamera/pixel_format.h \
- /usr/include/libcamera/libcamera/camera_manager.h \
- /usr/include/libcamera/libcamera/control_ids.h \
- /usr/include/libcamera/libcamera/formats.h \
- /usr/include/libcamera/libcamera/framebuffer_allocator.h \
- /usr/include/libcamera/libcamera/logging.h \
- /usr/include/libcamera/libcamera/property_ids.h \
- /usr/include/libcamera/libcamera/transform.h \
- /usr/include/libcamera/libcamera/version.h
+ /usr/include/c++/12/mutex /usr/include/c++/12/bits/std_mutex.h \
+ /usr/include/c++/12/bits/unique_lock.h \
+ /usr/include/c++/12/condition_variable \
+ /home/pi/CoralEdgeTpu/src/util_logging.h /usr/include/c++/12/fstream \
+ /usr/include/c++/12/bits/codecvt.h \
+ /usr/include/aarch64-linux-gnu/c++/12/bits/basic_file.h \
+ /usr/include/aarch64-linux-gnu/c++/12/bits/c++io.h \
+ /usr/include/c++/12/bits/fstream.tcc /usr/include/c++/12/iomanip \
+ /usr/include/c++/12/locale \
+ /usr/include/c++/12/bits/locale_facets_nonio.h \
+ /usr/include/aarch64-linux-gnu/c++/12/bits/time_members.h \
+ /usr/include/aarch64-linux-gnu/c++/12/bits/messages_members.h \
+ /usr/include/libintl.h /usr/include/c++/12/bits/locale_facets_nonio.tcc \
+ /usr/include/c++/12/bits/locale_conv.h \
+ /usr/include/c++/12/bits/quoted_string.h /usr/include/c++/12/iostream
diff --git a/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o b/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o
index 03d4438..100efa1 100644
Binary files a/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o and b/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d b/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d
index bb306cb..4ab5a8f 100644
--- a/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o.d
@@ -135,9 +135,7 @@ CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o: \
  /usr/include/aarch64-linux-gnu/sys/select.h \
  /usr/include/aarch64-linux-gnu/bits/select.h \
  /usr/include/aarch64-linux-gnu/bits/types/sigset_t.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
  /usr/include/stdio.h \
  /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
@@ -145,10 +143,10 @@ CMakeFiles/detector.dir/src/jpeg_wrapper.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/c++/12/cerrno /usr/include/errno.h \
+ /usr/include/aarch64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/lib/linux/uapi/arm64/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h \
  /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
  /usr/include/c++/12/bits/basic_string.tcc /usr/include/c++/12/stdexcept \
diff --git a/build/CMakeFiles/detector.dir/src/main.cpp.o b/build/CMakeFiles/detector.dir/src/main.cpp.o
index bded935..3fd0495 100644
Binary files a/build/CMakeFiles/detector.dir/src/main.cpp.o and b/build/CMakeFiles/detector.dir/src/main.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/main.cpp.o.d b/build/CMakeFiles/detector.dir/src/main.cpp.o.d
index 0fa821a..3c9c575 100644
--- a/build/CMakeFiles/detector.dir/src/main.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/main.cpp.o.d
@@ -119,9 +119,7 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /usr/include/aarch64-linux-gnu/sys/select.h \
  /usr/include/aarch64-linux-gnu/bits/select.h \
  /usr/include/aarch64-linux-gnu/bits/types/sigset_t.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
  /usr/include/stdio.h \
  /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
@@ -129,10 +127,10 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/c++/12/cerrno /usr/include/errno.h \
+ /usr/include/aarch64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/lib/linux/uapi/arm64/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h \
  /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
  /usr/include/c++/12/bits/basic_string.tcc \
@@ -232,63 +230,42 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /usr/include/c++/12/bits/quoted_string.h /usr/include/c++/12/sstream \
  /usr/include/c++/12/bits/sstream.tcc /usr/include/c++/12/codecvt \
  /usr/include/c++/12/bits/fs_dir.h /usr/include/c++/12/bits/fs_ops.h \
- /home/pi/CoralEdgeTpu/src/camera_capture.h \
- /usr/include/libcamera/libcamera/libcamera.h \
- /usr/include/libcamera/libcamera/camera.h /usr/include/c++/12/optional \
- /usr/include/c++/12/bits/enable_special_members.h \
- /usr/include/c++/12/set /usr/include/c++/12/bits/stl_tree.h \
- /usr/include/c++/12/bits/node_handle.h \
- /usr/include/c++/12/bits/stl_set.h \
- /usr/include/c++/12/bits/stl_multiset.h \
- /usr/include/c++/12/bits/erase_if.h \
- /usr/include/libcamera/libcamera/base/class.h \
- /usr/include/libcamera/libcamera/base/flags.h \
- /usr/include/libcamera/libcamera/base/object.h /usr/include/c++/12/list \
- /usr/include/c++/12/bits/stl_list.h /usr/include/c++/12/bits/list.tcc \
- /usr/include/c++/12/utility /usr/include/c++/12/bits/stl_relops.h \
- /usr/include/libcamera/libcamera/base/bound_method.h \
- /usr/include/libcamera/libcamera/base/signal.h \
- /usr/include/c++/12/functional /usr/include/c++/12/bits/std_function.h \
+ /usr/include/c++/12/chrono /home/pi/CoralEdgeTpu/src/pipeline_structs.h \
+ /usr/include/c++/12/queue /usr/include/c++/12/deque \
+ /usr/include/c++/12/bits/stl_deque.h /usr/include/c++/12/bits/deque.tcc \
+ /usr/include/c++/12/bits/stl_heap.h /usr/include/c++/12/bits/stl_queue.h \
+ /usr/include/c++/12/mutex /usr/include/c++/12/bits/std_mutex.h \
+ /usr/include/c++/12/bits/unique_lock.h \
+ /usr/include/c++/12/condition_variable \
+ /home/pi/CoralEdgeTpu/src/camera_capture.h /usr/include/c++/12/thread \
+ /usr/include/c++/12/bits/std_thread.h \
+ /usr/include/c++/12/bits/this_thread_sleep.h \
+ /home/pi/CoralEdgeTpu/src/process_supervisor.hpp \
+ /home/pi/CoralEdgeTpu/src/util_logging.h /usr/include/c++/12/functional \
+ /usr/include/c++/12/bits/std_function.h \
  /usr/include/c++/12/unordered_map /usr/include/c++/12/bits/hashtable.h \
  /usr/include/c++/12/bits/hashtable_policy.h \
- /usr/include/c++/12/bits/unordered_map.h /usr/include/c++/12/array \
+ /usr/include/c++/12/bits/enable_special_members.h \
+ /usr/include/c++/12/bits/node_handle.h \
+ /usr/include/c++/12/bits/unordered_map.h \
+ /usr/include/c++/12/bits/erase_if.h /usr/include/c++/12/array \
  /usr/include/c++/12/compare /usr/include/c++/12/bits/stl_algo.h \
  /usr/include/c++/12/bits/algorithmfwd.h \
- /usr/include/c++/12/bits/stl_heap.h \
- /usr/include/c++/12/bits/uniform_int_dist.h \
- /usr/include/libcamera/libcamera/controls.h /usr/include/assert.h \
- /usr/include/c++/12/map /usr/include/c++/12/bits/stl_map.h \
- /usr/include/c++/12/bits/stl_multimap.h \
- /usr/include/libcamera/libcamera/base/span.h \
- /usr/include/c++/12/iterator /usr/include/c++/12/bits/stream_iterator.h \
- /usr/include/libcamera/libcamera/geometry.h \
+ /usr/include/c++/12/bits/uniform_int_dist.h /usr/include/c++/12/numeric \
+ /usr/include/c++/12/bits/stl_numeric.h \
+ /usr/include/c++/12/pstl/glue_numeric_defs.h \
+ /usr/include/aarch64-linux-gnu/sys/wait.h \
+ /usr/include/aarch64-linux-gnu/bits/types/idtype_t.h \
+ /usr/include/fcntl.h /usr/include/aarch64-linux-gnu/bits/fcntl.h \
+ /usr/include/aarch64-linux-gnu/bits/fcntl-linux.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
+ /usr/include/linux/falloc.h /usr/include/aarch64-linux-gnu/bits/stat.h \
+ /usr/include/aarch64-linux-gnu/bits/struct_stat.h \
+ /usr/include/c++/12/cstring /usr/include/string.h /usr/include/strings.h \
  /usr/include/c++/12/algorithm \
  /usr/include/c++/12/pstl/glue_algorithm_defs.h \
- /usr/include/libcamera/libcamera/orientation.h \
- /usr/include/libcamera/libcamera/request.h \
- /usr/include/libcamera/libcamera/fence.h \
- /usr/include/libcamera/libcamera/base/unique_fd.h \
- /usr/include/libcamera/libcamera/stream.h \
- /usr/include/libcamera/libcamera/color_space.h \
- /usr/include/libcamera/libcamera/framebuffer.h \
- /usr/include/libcamera/libcamera/base/shared_fd.h \
- /usr/include/libcamera/libcamera/pixel_format.h \
- /usr/include/libcamera/libcamera/camera_manager.h \
- /usr/include/libcamera/libcamera/control_ids.h \
- /usr/include/libcamera/libcamera/formats.h \
- /usr/include/libcamera/libcamera/framebuffer_allocator.h \
- /usr/include/libcamera/libcamera/logging.h \
- /usr/include/libcamera/libcamera/property_ids.h \
- /usr/include/libcamera/libcamera/transform.h \
- /usr/include/libcamera/libcamera/version.h /usr/include/c++/12/thread \
- /usr/include/c++/12/bits/std_thread.h \
- /usr/include/c++/12/bits/this_thread_sleep.h /usr/include/c++/12/mutex \
- /usr/include/c++/12/bits/std_mutex.h \
- /usr/include/c++/12/bits/unique_lock.h \
- /usr/include/c++/12/condition_variable /usr/include/c++/12/queue \
- /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
- /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_queue.h \
- /usr/include/c++/12/chrono /home/pi/CoralEdgeTpu/src/inference.h \
+ /home/pi/CoralEdgeTpu/src/mjpeg_capture.h \
+ /home/pi/CoralEdgeTpu/src/inference.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/interpreter.h \
  /usr/include/c++/12/complex /usr/include/c++/12/cmath \
  /usr/include/math.h /usr/include/aarch64-linux-gnu/bits/math-vector.h \
@@ -311,7 +288,10 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /usr/include/c++/12/tr1/modified_bessel_func.tcc \
  /usr/include/c++/12/tr1/poly_hermite.tcc \
  /usr/include/c++/12/tr1/poly_laguerre.tcc \
- /usr/include/c++/12/tr1/riemann_zeta.tcc \
+ /usr/include/c++/12/tr1/riemann_zeta.tcc /usr/include/c++/12/map \
+ /usr/include/c++/12/bits/stl_tree.h /usr/include/c++/12/bits/stl_map.h \
+ /usr/include/c++/12/bits/stl_multimap.h /usr/include/c++/12/utility \
+ /usr/include/c++/12/bits/stl_relops.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/allocation.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/error_reporter.h \
  /usr/include/c++/12/cstdarg \
@@ -333,8 +313,10 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/interpreter_builder.h \
  /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/flatbuffers.h \
  /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/base.h \
- /usr/include/c++/12/cstddef /usr/include/c++/12/cstring \
- /usr/include/string.h /usr/include/strings.h \
+ /usr/include/assert.h /usr/include/c++/12/cstddef \
+ /usr/include/c++/12/set /usr/include/c++/12/bits/stl_set.h \
+ /usr/include/c++/12/bits/stl_multiset.h /usr/include/c++/12/iterator \
+ /usr/include/c++/12/bits/stream_iterator.h \
  /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/stl_emulation.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/op_resolver.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/schema/schema_generated.h \
@@ -342,11 +324,8 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/verifier.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/mutable_op_resolver.h \
  /home/pi/CoralEdgeTpu/include/tensorflow/lite/kernels/register.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/builtin_op_data.h \
  /home/pi/CoralEdgeTpu/src/mjpeg_server.h \
- /home/pi/CoralEdgeTpu/src/udp_sender.h /usr/include/netinet/in.h \
  /usr/include/aarch64-linux-gnu/sys/socket.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
  /usr/include/aarch64-linux-gnu/bits/socket.h \
  /usr/include/aarch64-linux-gnu/bits/socket_type.h \
  /usr/include/aarch64-linux-gnu/bits/sockaddr.h \
@@ -354,8 +333,5 @@ CMakeFiles/detector.dir/src/main.cpp.o: \
  /usr/lib/linux/uapi/arm64/asm/sockios.h \
  /usr/include/asm-generic/sockios.h \
  /usr/include/aarch64-linux-gnu/bits/types/struct_osockaddr.h \
- /usr/include/aarch64-linux-gnu/bits/in.h \
- /home/pi/CoralEdgeTpu/src/jpeg_wrapper.h /usr/include/setjmp.h \
- /usr/include/jpeglib.h /usr/include/aarch64-linux-gnu/jconfig.h \
- /usr/include/jmorecfg.h /home/pi/CoralEdgeTpu/src/util_logging.h \
- /home/pi/CoralEdgeTpu/src/output_processor.h
+ /home/pi/CoralEdgeTpu/src/udp_sender.h /usr/include/netinet/in.h \
+ /usr/include/aarch64-linux-gnu/bits/in.h
diff --git a/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o b/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o
index 748f7b5..efe7803 100644
Binary files a/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o and b/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d b/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d
index 5c26689..108f458 100644
--- a/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/mjpeg_server.cpp.o.d
@@ -100,9 +100,7 @@ CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h \
  /usr/include/aarch64-linux-gnu/bits/struct_mutex.h \
  /usr/include/aarch64-linux-gnu/bits/struct_rwlock.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
  /usr/include/stdio.h \
  /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
@@ -110,10 +108,10 @@ CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/c++/12/cerrno /usr/include/errno.h \
+ /usr/include/aarch64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/lib/linux/uapi/arm64/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h \
  /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
  /usr/include/c++/12/bits/basic_string.tcc /usr/include/c++/12/vector \
@@ -143,6 +141,24 @@ CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: \
  /usr/include/c++/12/bits/parse_numbers.h /usr/include/c++/12/atomic \
  /usr/include/c++/12/bits/atomic_base.h \
  /usr/include/c++/12/bits/atomic_lockfree_defines.h \
+ /usr/include/aarch64-linux-gnu/sys/socket.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
+ /usr/include/aarch64-linux-gnu/bits/socket.h \
+ /usr/include/aarch64-linux-gnu/bits/socket_type.h \
+ /usr/include/aarch64-linux-gnu/bits/sockaddr.h \
+ /usr/lib/linux/uapi/arm64/asm/socket.h /usr/include/asm-generic/socket.h \
+ /usr/include/linux/posix_types.h /usr/include/linux/stddef.h \
+ /usr/lib/linux/uapi/arm64/asm/posix_types.h \
+ /usr/include/asm-generic/posix_types.h \
+ /usr/lib/linux/uapi/arm64/asm/bitsperlong.h \
+ /usr/include/asm-generic/bitsperlong.h \
+ /usr/lib/linux/uapi/arm64/asm/sockios.h \
+ /usr/include/asm-generic/sockios.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_osockaddr.h \
+ /home/pi/CoralEdgeTpu/src/pipeline_structs.h /usr/include/c++/12/chrono \
+ /usr/include/c++/12/queue /usr/include/c++/12/deque \
+ /usr/include/c++/12/bits/stl_deque.h /usr/include/c++/12/bits/deque.tcc \
+ /usr/include/c++/12/bits/stl_heap.h /usr/include/c++/12/bits/stl_queue.h \
  /usr/include/c++/12/mutex /usr/include/c++/12/exception \
  /usr/include/c++/12/bits/exception_ptr.h \
  /usr/include/c++/12/bits/cxxabi_init_exception.h \
@@ -159,10 +175,7 @@ CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: \
  /usr/include/c++/12/bits/shared_ptr_base.h \
  /usr/include/c++/12/bits/allocated_ptr.h \
  /usr/include/c++/12/ext/aligned_buffer.h \
- /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/queue \
- /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
- /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_heap.h \
- /usr/include/c++/12/bits/stl_queue.h /usr/include/c++/12/iostream \
+ /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/iostream \
  /usr/include/c++/12/ostream /usr/include/c++/12/ios \
  /usr/include/c++/12/bits/ios_base.h \
  /usr/include/c++/12/bits/locale_classes.h \
@@ -177,23 +190,9 @@ CMakeFiles/detector.dir/src/mjpeg_server.cpp.o: \
  /usr/include/c++/12/bits/locale_facets.tcc \
  /usr/include/c++/12/bits/basic_ios.tcc \
  /usr/include/c++/12/bits/ostream.tcc /usr/include/c++/12/istream \
- /usr/include/c++/12/bits/istream.tcc \
- /usr/include/aarch64-linux-gnu/sys/socket.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
- /usr/include/aarch64-linux-gnu/bits/socket.h \
- /usr/include/aarch64-linux-gnu/bits/socket_type.h \
- /usr/include/aarch64-linux-gnu/bits/sockaddr.h \
- /usr/lib/linux/uapi/arm64/asm/socket.h /usr/include/asm-generic/socket.h \
- /usr/include/linux/posix_types.h /usr/include/linux/stddef.h \
- /usr/lib/linux/uapi/arm64/asm/posix_types.h \
- /usr/include/asm-generic/posix_types.h \
- /usr/lib/linux/uapi/arm64/asm/bitsperlong.h \
- /usr/include/asm-generic/bitsperlong.h \
- /usr/lib/linux/uapi/arm64/asm/sockios.h \
- /usr/include/asm-generic/sockios.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_osockaddr.h \
- /usr/include/netinet/in.h /usr/include/aarch64-linux-gnu/bits/in.h \
- /usr/include/unistd.h /usr/include/aarch64-linux-gnu/bits/posix_opt.h \
+ /usr/include/c++/12/bits/istream.tcc /usr/include/netinet/in.h \
+ /usr/include/aarch64-linux-gnu/bits/in.h /usr/include/unistd.h \
+ /usr/include/aarch64-linux-gnu/bits/posix_opt.h \
  /usr/include/aarch64-linux-gnu/bits/environments.h \
  /usr/include/aarch64-linux-gnu/bits/confname.h \
  /usr/include/aarch64-linux-gnu/bits/getopt_posix.h \
diff --git a/build/CMakeFiles/detector.dir/src/output_processor.cpp.o b/build/CMakeFiles/detector.dir/src/output_processor.cpp.o
deleted file mode 100644
index 0c9dc67..0000000
Binary files a/build/CMakeFiles/detector.dir/src/output_processor.cpp.o and /dev/null differ
diff --git a/build/CMakeFiles/detector.dir/src/output_processor.cpp.o.d b/build/CMakeFiles/detector.dir/src/output_processor.cpp.o.d
deleted file mode 100644
index ab02576..0000000
--- a/build/CMakeFiles/detector.dir/src/output_processor.cpp.o.d
+++ /dev/null
@@ -1,292 +0,0 @@
-CMakeFiles/detector.dir/src/output_processor.cpp.o: \
- /home/pi/CoralEdgeTpu/src/output_processor.cpp \
- /usr/include/stdc-predef.h /home/pi/CoralEdgeTpu/src/output_processor.h \
- /usr/include/c++/12/vector /usr/include/c++/12/bits/stl_algobase.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/c++config.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/os_defines.h \
- /usr/include/features.h /usr/include/features-time64.h \
- /usr/include/aarch64-linux-gnu/bits/wordsize.h \
- /usr/include/aarch64-linux-gnu/bits/timesize.h \
- /usr/include/aarch64-linux-gnu/sys/cdefs.h \
- /usr/include/aarch64-linux-gnu/bits/long-double.h \
- /usr/include/aarch64-linux-gnu/gnu/stubs.h \
- /usr/include/aarch64-linux-gnu/gnu/stubs-lp64.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/cpu_defines.h \
- /usr/include/c++/12/pstl/pstl_config.h \
- /usr/include/c++/12/bits/functexcept.h \
- /usr/include/c++/12/bits/exception_defines.h \
- /usr/include/c++/12/bits/cpp_type_traits.h \
- /usr/include/c++/12/ext/type_traits.h \
- /usr/include/c++/12/ext/numeric_traits.h \
- /usr/include/c++/12/bits/stl_pair.h /usr/include/c++/12/type_traits \
- /usr/include/c++/12/bits/move.h /usr/include/c++/12/bits/utility.h \
- /usr/include/c++/12/bits/stl_iterator_base_types.h \
- /usr/include/c++/12/bits/stl_iterator_base_funcs.h \
- /usr/include/c++/12/bits/concept_check.h \
- /usr/include/c++/12/debug/assertions.h \
- /usr/include/c++/12/bits/stl_iterator.h \
- /usr/include/c++/12/bits/ptr_traits.h /usr/include/c++/12/debug/debug.h \
- /usr/include/c++/12/bits/predefined_ops.h \
- /usr/include/c++/12/bits/allocator.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/c++allocator.h \
- /usr/include/c++/12/bits/new_allocator.h /usr/include/c++/12/new \
- /usr/include/c++/12/bits/exception.h \
- /usr/include/c++/12/bits/memoryfwd.h \
- /usr/include/c++/12/bits/stl_construct.h \
- /usr/include/c++/12/bits/stl_uninitialized.h \
- /usr/include/c++/12/ext/alloc_traits.h \
- /usr/include/c++/12/bits/alloc_traits.h \
- /usr/include/c++/12/bits/stl_vector.h \
- /usr/include/c++/12/initializer_list \
- /usr/include/c++/12/bits/stl_bvector.h \
- /usr/include/c++/12/bits/functional_hash.h \
- /usr/include/c++/12/bits/hash_bytes.h /usr/include/c++/12/bits/refwrap.h \
- /usr/include/c++/12/bits/invoke.h \
- /usr/include/c++/12/bits/stl_function.h \
- /usr/include/c++/12/backward/binders.h \
- /usr/include/c++/12/bits/range_access.h \
- /usr/include/c++/12/bits/vector.tcc /usr/include/c++/12/string \
- /usr/include/c++/12/bits/stringfwd.h \
- /usr/include/c++/12/bits/char_traits.h \
- /usr/include/c++/12/bits/postypes.h /usr/include/c++/12/cwchar \
- /usr/include/wchar.h \
- /usr/include/aarch64-linux-gnu/bits/libc-header-start.h \
- /usr/include/aarch64-linux-gnu/bits/floatn.h \
- /usr/include/aarch64-linux-gnu/bits/floatn-common.h \
- /usr/lib/gcc/aarch64-linux-gnu/12/include/stddef.h \
- /usr/lib/gcc/aarch64-linux-gnu/12/include/stdarg.h \
- /usr/include/aarch64-linux-gnu/bits/wchar.h \
- /usr/include/aarch64-linux-gnu/bits/types/wint_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/mbstate_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/__FILE.h \
- /usr/include/aarch64-linux-gnu/bits/types/FILE.h \
- /usr/include/aarch64-linux-gnu/bits/types/locale_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/__locale_t.h \
- /usr/include/c++/12/cstdint \
- /usr/lib/gcc/aarch64-linux-gnu/12/include/stdint.h /usr/include/stdint.h \
- /usr/include/aarch64-linux-gnu/bits/types.h \
- /usr/include/aarch64-linux-gnu/bits/typesizes.h \
- /usr/include/aarch64-linux-gnu/bits/time64.h \
- /usr/include/aarch64-linux-gnu/bits/stdint-intn.h \
- /usr/include/aarch64-linux-gnu/bits/stdint-uintn.h \
- /usr/include/c++/12/bits/localefwd.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/c++locale.h \
- /usr/include/c++/12/clocale /usr/include/locale.h \
- /usr/include/aarch64-linux-gnu/bits/locale.h /usr/include/c++/12/iosfwd \
- /usr/include/c++/12/cctype /usr/include/ctype.h \
- /usr/include/aarch64-linux-gnu/bits/endian.h \
- /usr/include/aarch64-linux-gnu/bits/endianness.h \
- /usr/include/c++/12/bits/ostream_insert.h \
- /usr/include/c++/12/bits/cxxabi_forced.h \
- /usr/include/c++/12/bits/basic_string.h /usr/include/c++/12/string_view \
- /usr/include/c++/12/bits/string_view.tcc \
- /usr/include/c++/12/ext/string_conversions.h /usr/include/c++/12/cstdlib \
- /usr/include/stdlib.h /usr/include/aarch64-linux-gnu/bits/waitflags.h \
- /usr/include/aarch64-linux-gnu/bits/waitstatus.h \
- /usr/include/aarch64-linux-gnu/sys/types.h \
- /usr/include/aarch64-linux-gnu/bits/types/clock_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/clockid_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/time_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/timer_t.h \
- /usr/include/endian.h /usr/include/aarch64-linux-gnu/bits/byteswap.h \
- /usr/include/aarch64-linux-gnu/bits/uintn-identity.h \
- /usr/include/aarch64-linux-gnu/sys/select.h \
- /usr/include/aarch64-linux-gnu/bits/select.h \
- /usr/include/aarch64-linux-gnu/bits/types/sigset_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/__sigset_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_timeval.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h \
- /usr/include/aarch64-linux-gnu/bits/pthreadtypes.h \
- /usr/include/aarch64-linux-gnu/bits/thread-shared-types.h \
- /usr/include/aarch64-linux-gnu/bits/pthreadtypes-arch.h \
- /usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h \
- /usr/include/aarch64-linux-gnu/bits/struct_mutex.h \
- /usr/include/aarch64-linux-gnu/bits/struct_rwlock.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
- /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
- /usr/include/stdio.h \
- /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
- /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
- /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
- /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
- /usr/include/c++/12/bits/charconv.h \
- /usr/include/c++/12/bits/basic_string.tcc /usr/include/c++/12/thread \
- /usr/include/c++/12/bits/std_thread.h /usr/include/c++/12/tuple \
- /usr/include/c++/12/bits/uses_allocator.h \
- /usr/include/c++/12/bits/unique_ptr.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/gthr.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/gthr-default.h \
- /usr/include/pthread.h /usr/include/sched.h \
- /usr/include/aarch64-linux-gnu/bits/sched.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_sched_param.h \
- /usr/include/aarch64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
- /usr/include/aarch64-linux-gnu/bits/time.h \
- /usr/include/aarch64-linux-gnu/bits/timex.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_tm.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_itimerspec.h \
- /usr/include/aarch64-linux-gnu/bits/setjmp.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
- /usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h \
- /usr/include/c++/12/bits/this_thread_sleep.h \
- /usr/include/c++/12/bits/chrono.h /usr/include/c++/12/ratio \
- /usr/include/c++/12/limits /usr/include/c++/12/ctime \
- /usr/include/c++/12/bits/parse_numbers.h /usr/include/c++/12/atomic \
- /usr/include/c++/12/bits/atomic_base.h \
- /usr/include/c++/12/bits/atomic_lockfree_defines.h \
- /usr/include/c++/12/mutex /usr/include/c++/12/exception \
- /usr/include/c++/12/bits/exception_ptr.h \
- /usr/include/c++/12/bits/cxxabi_init_exception.h \
- /usr/include/c++/12/typeinfo /usr/include/c++/12/bits/nested_exception.h \
- /usr/include/c++/12/system_error \
- /usr/include/aarch64-linux-gnu/c++/12/bits/error_constants.h \
- /usr/include/c++/12/stdexcept /usr/include/c++/12/bits/std_mutex.h \
- /usr/include/c++/12/bits/unique_lock.h \
- /usr/include/c++/12/ext/atomicity.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/atomic_word.h \
- /usr/include/aarch64-linux-gnu/sys/single_threaded.h \
- /usr/include/c++/12/condition_variable \
- /usr/include/c++/12/bits/shared_ptr.h \
- /usr/include/c++/12/bits/shared_ptr_base.h \
- /usr/include/c++/12/bits/allocated_ptr.h \
- /usr/include/c++/12/ext/aligned_buffer.h \
- /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/queue \
- /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
- /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_heap.h \
- /usr/include/c++/12/bits/stl_queue.h /usr/include/c++/12/chrono \
- /home/pi/CoralEdgeTpu/src/inference.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/interpreter.h \
- /usr/include/c++/12/complex /usr/include/c++/12/cmath \
- /usr/include/math.h /usr/include/aarch64-linux-gnu/bits/math-vector.h \
- /usr/include/aarch64-linux-gnu/bits/libm-simd-decl-stubs.h \
- /usr/include/aarch64-linux-gnu/bits/flt-eval-method.h \
- /usr/include/aarch64-linux-gnu/bits/fp-logb.h \
- /usr/include/aarch64-linux-gnu/bits/fp-fast.h \
- /usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h \
- /usr/include/aarch64-linux-gnu/bits/mathcalls.h \
- /usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h \
- /usr/include/aarch64-linux-gnu/bits/iscanonical.h \
- /usr/include/c++/12/bits/specfun.h /usr/include/c++/12/tr1/gamma.tcc \
- /usr/include/c++/12/tr1/special_function_util.h \
- /usr/include/c++/12/tr1/bessel_function.tcc \
- /usr/include/c++/12/tr1/beta_function.tcc \
- /usr/include/c++/12/tr1/ell_integral.tcc \
- /usr/include/c++/12/tr1/exp_integral.tcc \
- /usr/include/c++/12/tr1/hypergeometric.tcc \
- /usr/include/c++/12/tr1/legendre_function.tcc \
- /usr/include/c++/12/tr1/modified_bessel_func.tcc \
- /usr/include/c++/12/tr1/poly_hermite.tcc \
- /usr/include/c++/12/tr1/poly_laguerre.tcc \
- /usr/include/c++/12/tr1/riemann_zeta.tcc /usr/include/c++/12/sstream \
- /usr/include/c++/12/istream /usr/include/c++/12/ios \
- /usr/include/c++/12/bits/ios_base.h \
- /usr/include/c++/12/bits/locale_classes.h \
- /usr/include/c++/12/bits/locale_classes.tcc \
- /usr/include/c++/12/streambuf /usr/include/c++/12/bits/streambuf.tcc \
- /usr/include/c++/12/bits/basic_ios.h \
- /usr/include/c++/12/bits/locale_facets.h /usr/include/c++/12/cwctype \
- /usr/include/wctype.h /usr/include/aarch64-linux-gnu/bits/wctype-wchar.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/ctype_base.h \
- /usr/include/c++/12/bits/streambuf_iterator.h \
- /usr/include/aarch64-linux-gnu/c++/12/bits/ctype_inline.h \
- /usr/include/c++/12/bits/locale_facets.tcc \
- /usr/include/c++/12/bits/basic_ios.tcc /usr/include/c++/12/ostream \
- /usr/include/c++/12/bits/ostream.tcc \
- /usr/include/c++/12/bits/istream.tcc \
- /usr/include/c++/12/bits/sstream.tcc /usr/include/c++/12/functional \
- /usr/include/c++/12/bits/std_function.h \
- /usr/include/c++/12/unordered_map /usr/include/c++/12/bits/hashtable.h \
- /usr/include/c++/12/bits/hashtable_policy.h \
- /usr/include/c++/12/bits/enable_special_members.h \
- /usr/include/c++/12/bits/node_handle.h \
- /usr/include/c++/12/bits/unordered_map.h \
- /usr/include/c++/12/bits/erase_if.h /usr/include/c++/12/array \
- /usr/include/c++/12/compare /usr/include/c++/12/bits/stl_algo.h \
- /usr/include/c++/12/bits/algorithmfwd.h \
- /usr/include/c++/12/bits/stl_tempbuf.h \
- /usr/include/c++/12/bits/uniform_int_dist.h /usr/include/c++/12/map \
- /usr/include/c++/12/bits/stl_tree.h /usr/include/c++/12/bits/stl_map.h \
- /usr/include/c++/12/bits/stl_multimap.h /usr/include/c++/12/memory \
- /usr/include/c++/12/bits/stl_raw_storage_iter.h \
- /usr/include/c++/12/bits/align.h /usr/include/c++/12/bit \
- /usr/include/c++/12/bits/shared_ptr_atomic.h \
- /usr/include/c++/12/backward/auto_ptr.h \
- /usr/include/c++/12/pstl/glue_memory_defs.h \
- /usr/include/c++/12/pstl/execution_defs.h /usr/include/c++/12/utility \
- /usr/include/c++/12/bits/stl_relops.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/allocation.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/error_reporter.h \
- /usr/include/c++/12/cstdarg \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/common.h \
- /usr/lib/gcc/aarch64-linux-gnu/12/include/stdbool.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/c_api_types.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/profiler.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/subgraph.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/macros.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/experimental/resource/resource_base.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/memory_planner.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/util.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/external_cpu_backend_context.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/portable_type_to_tflitetype.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/stderr_reporter.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/string_type.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/type_to_tflitetype.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/model.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/interpreter_builder.h \
- /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/flatbuffers.h \
- /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/base.h \
- /usr/include/assert.h /usr/include/c++/12/cstddef \
- /usr/include/c++/12/cstring /usr/include/string.h /usr/include/strings.h \
- /usr/include/c++/12/set /usr/include/c++/12/bits/stl_set.h \
- /usr/include/c++/12/bits/stl_multiset.h /usr/include/c++/12/algorithm \
- /usr/include/c++/12/pstl/glue_algorithm_defs.h \
- /usr/include/c++/12/iterator /usr/include/c++/12/bits/stream_iterator.h \
- /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/stl_emulation.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/op_resolver.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/schema/schema_generated.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/model_builder.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/verifier.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/mutable_op_resolver.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/kernels/register.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/builtin_op_data.h \
- /home/pi/CoralEdgeTpu/src/camera_capture.h \
- /usr/include/libcamera/libcamera/libcamera.h \
- /usr/include/libcamera/libcamera/camera.h /usr/include/c++/12/optional \
- /usr/include/libcamera/libcamera/base/class.h \
- /usr/include/libcamera/libcamera/base/flags.h \
- /usr/include/libcamera/libcamera/base/object.h /usr/include/c++/12/list \
- /usr/include/c++/12/bits/stl_list.h /usr/include/c++/12/bits/list.tcc \
- /usr/include/libcamera/libcamera/base/bound_method.h \
- /usr/include/libcamera/libcamera/base/signal.h \
- /usr/include/libcamera/libcamera/controls.h \
- /usr/include/libcamera/libcamera/base/span.h \
- /usr/include/libcamera/libcamera/geometry.h \
- /usr/include/libcamera/libcamera/orientation.h \
- /usr/include/c++/12/iostream /usr/include/libcamera/libcamera/request.h \
- /usr/include/libcamera/libcamera/fence.h \
- /usr/include/libcamera/libcamera/base/unique_fd.h \
- /usr/include/libcamera/libcamera/stream.h \
- /usr/include/libcamera/libcamera/color_space.h \
- /usr/include/libcamera/libcamera/framebuffer.h \
- /usr/include/libcamera/libcamera/base/shared_fd.h \
- /usr/include/libcamera/libcamera/pixel_format.h \
- /usr/include/libcamera/libcamera/camera_manager.h \
- /usr/include/libcamera/libcamera/control_ids.h \
- /usr/include/libcamera/libcamera/formats.h \
- /usr/include/libcamera/libcamera/framebuffer_allocator.h \
- /usr/include/libcamera/libcamera/logging.h \
- /usr/include/libcamera/libcamera/property_ids.h \
- /usr/include/libcamera/libcamera/transform.h \
- /usr/include/libcamera/libcamera/version.h \
- /home/pi/CoralEdgeTpu/src/mjpeg_server.h \
- /home/pi/CoralEdgeTpu/src/jpeg_wrapper.h /usr/include/setjmp.h \
- /usr/include/jpeglib.h /usr/include/aarch64-linux-gnu/jconfig.h \
- /usr/include/jmorecfg.h
diff --git a/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o b/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o
index fe4c3c7..6de1efd 100644
Binary files a/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o and b/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o.d b/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o.d
index d41e8d6..dcd6dbe 100644
--- a/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/udp_sender.cpp.o.d
@@ -100,9 +100,7 @@ CMakeFiles/detector.dir/src/udp_sender.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h \
  /usr/include/aarch64-linux-gnu/bits/struct_mutex.h \
  /usr/include/aarch64-linux-gnu/bits/struct_rwlock.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
  /usr/include/stdio.h \
  /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
@@ -110,10 +108,10 @@ CMakeFiles/detector.dir/src/udp_sender.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/c++/12/cerrno /usr/include/errno.h \
+ /usr/include/aarch64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/lib/linux/uapi/arm64/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h \
  /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
  /usr/include/c++/12/bits/basic_string.tcc /usr/include/c++/12/vector \
@@ -143,6 +141,25 @@ CMakeFiles/detector.dir/src/udp_sender.cpp.o: \
  /usr/include/c++/12/bits/parse_numbers.h /usr/include/c++/12/atomic \
  /usr/include/c++/12/bits/atomic_base.h \
  /usr/include/c++/12/bits/atomic_lockfree_defines.h \
+ /usr/include/netinet/in.h /usr/include/aarch64-linux-gnu/sys/socket.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
+ /usr/include/aarch64-linux-gnu/bits/socket.h \
+ /usr/include/aarch64-linux-gnu/bits/socket_type.h \
+ /usr/include/aarch64-linux-gnu/bits/sockaddr.h \
+ /usr/lib/linux/uapi/arm64/asm/socket.h /usr/include/asm-generic/socket.h \
+ /usr/include/linux/posix_types.h /usr/include/linux/stddef.h \
+ /usr/lib/linux/uapi/arm64/asm/posix_types.h \
+ /usr/include/asm-generic/posix_types.h \
+ /usr/lib/linux/uapi/arm64/asm/bitsperlong.h \
+ /usr/include/asm-generic/bitsperlong.h \
+ /usr/lib/linux/uapi/arm64/asm/sockios.h \
+ /usr/include/asm-generic/sockios.h \
+ /usr/include/aarch64-linux-gnu/bits/types/struct_osockaddr.h \
+ /usr/include/aarch64-linux-gnu/bits/in.h \
+ /home/pi/CoralEdgeTpu/src/pipeline_structs.h /usr/include/c++/12/chrono \
+ /usr/include/c++/12/queue /usr/include/c++/12/deque \
+ /usr/include/c++/12/bits/stl_deque.h /usr/include/c++/12/bits/deque.tcc \
+ /usr/include/c++/12/bits/stl_heap.h /usr/include/c++/12/bits/stl_queue.h \
  /usr/include/c++/12/mutex /usr/include/c++/12/exception \
  /usr/include/c++/12/bits/exception_ptr.h \
  /usr/include/c++/12/bits/cxxabi_init_exception.h \
@@ -159,50 +176,8 @@ CMakeFiles/detector.dir/src/udp_sender.cpp.o: \
  /usr/include/c++/12/bits/shared_ptr_base.h \
  /usr/include/c++/12/bits/allocated_ptr.h \
  /usr/include/c++/12/ext/aligned_buffer.h \
- /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/queue \
- /usr/include/c++/12/deque /usr/include/c++/12/bits/stl_deque.h \
- /usr/include/c++/12/bits/deque.tcc /usr/include/c++/12/bits/stl_heap.h \
- /usr/include/c++/12/bits/stl_queue.h /usr/include/netinet/in.h \
- /usr/include/aarch64-linux-gnu/sys/socket.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h \
- /usr/include/aarch64-linux-gnu/bits/socket.h \
- /usr/include/aarch64-linux-gnu/bits/socket_type.h \
- /usr/include/aarch64-linux-gnu/bits/sockaddr.h \
- /usr/lib/linux/uapi/arm64/asm/socket.h /usr/include/asm-generic/socket.h \
- /usr/include/linux/posix_types.h /usr/include/linux/stddef.h \
- /usr/lib/linux/uapi/arm64/asm/posix_types.h \
- /usr/include/asm-generic/posix_types.h \
- /usr/lib/linux/uapi/arm64/asm/bitsperlong.h \
- /usr/include/asm-generic/bitsperlong.h \
- /usr/lib/linux/uapi/arm64/asm/sockios.h \
- /usr/include/asm-generic/sockios.h \
- /usr/include/aarch64-linux-gnu/bits/types/struct_osockaddr.h \
- /usr/include/aarch64-linux-gnu/bits/in.h \
- /home/pi/CoralEdgeTpu/src/inference.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/interpreter.h \
- /usr/include/c++/12/complex /usr/include/c++/12/cmath \
- /usr/include/math.h /usr/include/aarch64-linux-gnu/bits/math-vector.h \
- /usr/include/aarch64-linux-gnu/bits/libm-simd-decl-stubs.h \
- /usr/include/aarch64-linux-gnu/bits/flt-eval-method.h \
- /usr/include/aarch64-linux-gnu/bits/fp-logb.h \
- /usr/include/aarch64-linux-gnu/bits/fp-fast.h \
- /usr/include/aarch64-linux-gnu/bits/mathcalls-helper-functions.h \
- /usr/include/aarch64-linux-gnu/bits/mathcalls.h \
- /usr/include/aarch64-linux-gnu/bits/mathcalls-narrow.h \
- /usr/include/aarch64-linux-gnu/bits/iscanonical.h \
- /usr/include/c++/12/bits/specfun.h /usr/include/c++/12/tr1/gamma.tcc \
- /usr/include/c++/12/tr1/special_function_util.h \
- /usr/include/c++/12/tr1/bessel_function.tcc \
- /usr/include/c++/12/tr1/beta_function.tcc \
- /usr/include/c++/12/tr1/ell_integral.tcc \
- /usr/include/c++/12/tr1/exp_integral.tcc \
- /usr/include/c++/12/tr1/hypergeometric.tcc \
- /usr/include/c++/12/tr1/legendre_function.tcc \
- /usr/include/c++/12/tr1/modified_bessel_func.tcc \
- /usr/include/c++/12/tr1/poly_hermite.tcc \
- /usr/include/c++/12/tr1/poly_laguerre.tcc \
- /usr/include/c++/12/tr1/riemann_zeta.tcc /usr/include/c++/12/sstream \
- /usr/include/c++/12/istream /usr/include/c++/12/ios \
+ /usr/include/c++/12/ext/concurrence.h /usr/include/c++/12/iostream \
+ /usr/include/c++/12/ostream /usr/include/c++/12/ios \
  /usr/include/c++/12/bits/ios_base.h \
  /usr/include/c++/12/bits/locale_classes.h \
  /usr/include/c++/12/bits/locale_classes.tcc \
@@ -214,98 +189,14 @@ CMakeFiles/detector.dir/src/udp_sender.cpp.o: \
  /usr/include/c++/12/bits/streambuf_iterator.h \
  /usr/include/aarch64-linux-gnu/c++/12/bits/ctype_inline.h \
  /usr/include/c++/12/bits/locale_facets.tcc \
- /usr/include/c++/12/bits/basic_ios.tcc /usr/include/c++/12/ostream \
- /usr/include/c++/12/bits/ostream.tcc \
- /usr/include/c++/12/bits/istream.tcc \
- /usr/include/c++/12/bits/sstream.tcc /usr/include/c++/12/functional \
- /usr/include/c++/12/bits/std_function.h \
- /usr/include/c++/12/unordered_map /usr/include/c++/12/bits/hashtable.h \
- /usr/include/c++/12/bits/hashtable_policy.h \
- /usr/include/c++/12/bits/enable_special_members.h \
- /usr/include/c++/12/bits/node_handle.h \
- /usr/include/c++/12/bits/unordered_map.h \
- /usr/include/c++/12/bits/erase_if.h /usr/include/c++/12/array \
- /usr/include/c++/12/compare /usr/include/c++/12/bits/stl_algo.h \
- /usr/include/c++/12/bits/algorithmfwd.h \
- /usr/include/c++/12/bits/stl_tempbuf.h \
- /usr/include/c++/12/bits/uniform_int_dist.h /usr/include/c++/12/map \
- /usr/include/c++/12/bits/stl_tree.h /usr/include/c++/12/bits/stl_map.h \
- /usr/include/c++/12/bits/stl_multimap.h /usr/include/c++/12/memory \
- /usr/include/c++/12/bits/stl_raw_storage_iter.h \
- /usr/include/c++/12/bits/align.h /usr/include/c++/12/bit \
- /usr/include/c++/12/bits/shared_ptr_atomic.h \
- /usr/include/c++/12/backward/auto_ptr.h \
- /usr/include/c++/12/pstl/glue_memory_defs.h \
- /usr/include/c++/12/pstl/execution_defs.h /usr/include/c++/12/utility \
- /usr/include/c++/12/bits/stl_relops.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/allocation.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/error_reporter.h \
- /usr/include/c++/12/cstdarg \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/common.h \
- /usr/lib/gcc/aarch64-linux-gnu/12/include/stdbool.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/c_api_types.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/profiler.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/subgraph.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/macros.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/experimental/resource/resource_base.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/memory_planner.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/util.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/external_cpu_backend_context.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/portable_type_to_tflitetype.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/stderr_reporter.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/string_type.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/type_to_tflitetype.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/model.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/interpreter_builder.h \
- /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/flatbuffers.h \
- /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/base.h \
- /usr/include/assert.h /usr/include/c++/12/cstddef \
- /usr/include/c++/12/cstring /usr/include/string.h /usr/include/strings.h \
- /usr/include/c++/12/set /usr/include/c++/12/bits/stl_set.h \
- /usr/include/c++/12/bits/stl_multiset.h /usr/include/c++/12/algorithm \
- /usr/include/c++/12/pstl/glue_algorithm_defs.h \
- /usr/include/c++/12/iterator /usr/include/c++/12/bits/stream_iterator.h \
- /home/pi/CoralEdgeTpu/flatbuffers/include/flatbuffers/stl_emulation.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/op_resolver.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/schema/schema_generated.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/model_builder.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/core/api/verifier.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/mutable_op_resolver.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/kernels/register.h \
- /home/pi/CoralEdgeTpu/include/tensorflow/lite/c/builtin_op_data.h \
- /usr/include/c++/12/chrono /home/pi/CoralEdgeTpu/src/camera_capture.h \
- /usr/include/libcamera/libcamera/libcamera.h \
- /usr/include/libcamera/libcamera/camera.h /usr/include/c++/12/optional \
- /usr/include/libcamera/libcamera/base/class.h \
- /usr/include/libcamera/libcamera/base/flags.h \
- /usr/include/libcamera/libcamera/base/object.h /usr/include/c++/12/list \
- /usr/include/c++/12/bits/stl_list.h /usr/include/c++/12/bits/list.tcc \
- /usr/include/libcamera/libcamera/base/bound_method.h \
- /usr/include/libcamera/libcamera/base/signal.h \
- /usr/include/libcamera/libcamera/controls.h \
- /usr/include/libcamera/libcamera/base/span.h \
- /usr/include/libcamera/libcamera/geometry.h \
- /usr/include/libcamera/libcamera/orientation.h \
- /usr/include/c++/12/iostream /usr/include/libcamera/libcamera/request.h \
- /usr/include/libcamera/libcamera/fence.h \
- /usr/include/libcamera/libcamera/base/unique_fd.h \
- /usr/include/libcamera/libcamera/stream.h \
- /usr/include/libcamera/libcamera/color_space.h \
- /usr/include/libcamera/libcamera/framebuffer.h \
- /usr/include/libcamera/libcamera/base/shared_fd.h \
- /usr/include/libcamera/libcamera/pixel_format.h \
- /usr/include/libcamera/libcamera/camera_manager.h \
- /usr/include/libcamera/libcamera/control_ids.h \
- /usr/include/libcamera/libcamera/formats.h \
- /usr/include/libcamera/libcamera/framebuffer_allocator.h \
- /usr/include/libcamera/libcamera/logging.h \
- /usr/include/libcamera/libcamera/property_ids.h \
- /usr/include/libcamera/libcamera/transform.h \
- /usr/include/libcamera/libcamera/version.h /usr/include/arpa/inet.h \
+ /usr/include/c++/12/bits/basic_ios.tcc \
+ /usr/include/c++/12/bits/ostream.tcc /usr/include/c++/12/istream \
+ /usr/include/c++/12/bits/istream.tcc /usr/include/arpa/inet.h \
  /usr/include/unistd.h /usr/include/aarch64-linux-gnu/bits/posix_opt.h \
  /usr/include/aarch64-linux-gnu/bits/environments.h \
  /usr/include/aarch64-linux-gnu/bits/confname.h \
  /usr/include/aarch64-linux-gnu/bits/getopt_posix.h \
  /usr/include/aarch64-linux-gnu/bits/getopt_core.h \
  /usr/include/aarch64-linux-gnu/bits/unistd_ext.h \
- /usr/include/linux/close_range.h
+ /usr/include/linux/close_range.h /usr/include/c++/12/sstream \
+ /usr/include/c++/12/bits/sstream.tcc
diff --git a/build/CMakeFiles/detector.dir/src/util_logging.cpp.o b/build/CMakeFiles/detector.dir/src/util_logging.cpp.o
index 858dd83..7e2bf1c 100644
Binary files a/build/CMakeFiles/detector.dir/src/util_logging.cpp.o and b/build/CMakeFiles/detector.dir/src/util_logging.cpp.o differ
diff --git a/build/CMakeFiles/detector.dir/src/util_logging.cpp.o.d b/build/CMakeFiles/detector.dir/src/util_logging.cpp.o.d
index a59ac45..d196fa2 100644
--- a/build/CMakeFiles/detector.dir/src/util_logging.cpp.o.d
+++ b/build/CMakeFiles/detector.dir/src/util_logging.cpp.o.d
@@ -100,9 +100,7 @@ CMakeFiles/detector.dir/src/util_logging.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h \
  /usr/include/aarch64-linux-gnu/bits/struct_mutex.h \
  /usr/include/aarch64-linux-gnu/bits/struct_rwlock.h \
- /usr/include/alloca.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h \
- /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/alloca.h /usr/include/aarch64-linux-gnu/bits/stdlib-float.h \
  /usr/include/c++/12/bits/std_abs.h /usr/include/c++/12/cstdio \
  /usr/include/stdio.h \
  /usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h \
@@ -110,10 +108,10 @@ CMakeFiles/detector.dir/src/util_logging.cpp.o: \
  /usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h \
  /usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h \
  /usr/include/aarch64-linux-gnu/bits/stdio_lim.h \
- /usr/include/aarch64-linux-gnu/bits/stdio.h /usr/include/c++/12/cerrno \
- /usr/include/errno.h /usr/include/aarch64-linux-gnu/bits/errno.h \
- /usr/include/linux/errno.h /usr/lib/linux/uapi/arm64/asm/errno.h \
- /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/c++/12/cerrno /usr/include/errno.h \
+ /usr/include/aarch64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/lib/linux/uapi/arm64/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h \
  /usr/include/aarch64-linux-gnu/bits/types/error_t.h \
  /usr/include/c++/12/bits/charconv.h \
  /usr/include/c++/12/bits/basic_string.tcc /usr/include/c++/12/fstream \
diff --git a/build/Makefile b/build/Makefile
index d38677c..9f67363 100644
--- a/build/Makefile
+++ b/build/Makefile
@@ -225,6 +225,30 @@ src/main.cpp.s:
 	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/main.cpp.s
 .PHONY : src/main.cpp.s
 
+src/mjpeg_capture.o: src/mjpeg_capture.cpp.o
+.PHONY : src/mjpeg_capture.o
+
+# target to build an object file
+src/mjpeg_capture.cpp.o:
+	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/mjpeg_capture.cpp.o
+.PHONY : src/mjpeg_capture.cpp.o
+
+src/mjpeg_capture.i: src/mjpeg_capture.cpp.i
+.PHONY : src/mjpeg_capture.i
+
+# target to preprocess a source file
+src/mjpeg_capture.cpp.i:
+	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/mjpeg_capture.cpp.i
+.PHONY : src/mjpeg_capture.cpp.i
+
+src/mjpeg_capture.s: src/mjpeg_capture.cpp.s
+.PHONY : src/mjpeg_capture.s
+
+# target to generate assembly for a file
+src/mjpeg_capture.cpp.s:
+	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/mjpeg_capture.cpp.s
+.PHONY : src/mjpeg_capture.cpp.s
+
 src/mjpeg_server.o: src/mjpeg_server.cpp.o
 .PHONY : src/mjpeg_server.o
 
@@ -249,30 +273,6 @@ src/mjpeg_server.cpp.s:
 	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/mjpeg_server.cpp.s
 .PHONY : src/mjpeg_server.cpp.s
 
-src/output_processor.o: src/output_processor.cpp.o
-.PHONY : src/output_processor.o
-
-# target to build an object file
-src/output_processor.cpp.o:
-	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/output_processor.cpp.o
-.PHONY : src/output_processor.cpp.o
-
-src/output_processor.i: src/output_processor.cpp.i
-.PHONY : src/output_processor.i
-
-# target to preprocess a source file
-src/output_processor.cpp.i:
-	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/output_processor.cpp.i
-.PHONY : src/output_processor.cpp.i
-
-src/output_processor.s: src/output_processor.cpp.s
-.PHONY : src/output_processor.s
-
-# target to generate assembly for a file
-src/output_processor.cpp.s:
-	$(MAKE) $(MAKESILENT) -f CMakeFiles/detector.dir/build.make CMakeFiles/detector.dir/src/output_processor.cpp.s
-.PHONY : src/output_processor.cpp.s
-
 src/udp_sender.o: src/udp_sender.cpp.o
 .PHONY : src/udp_sender.o
 
@@ -342,12 +342,12 @@ help:
 	@echo "... src/main.o"
 	@echo "... src/main.i"
 	@echo "... src/main.s"
+	@echo "... src/mjpeg_capture.o"
+	@echo "... src/mjpeg_capture.i"
+	@echo "... src/mjpeg_capture.s"
 	@echo "... src/mjpeg_server.o"
 	@echo "... src/mjpeg_server.i"
 	@echo "... src/mjpeg_server.s"
-	@echo "... src/output_processor.o"
-	@echo "... src/output_processor.i"
-	@echo "... src/output_processor.s"
 	@echo "... src/udp_sender.o"
 	@echo "... src/udp_sender.i"
 	@echo "... src/udp_sender.s"
diff --git a/build/detector b/build/detector
index 3ac1098..2ae177f 100755
Binary files a/build/detector and b/build/detector differ
diff --git a/src/camera_capture.cpp b/src/camera_capture.cpp
index cf06420..8add46f 100644
--- a/src/camera_capture.cpp
+++ b/src/camera_capture.cpp
@@ -1,22 +1,26 @@
 #include "camera_capture.h"
 #include "util_logging.h"
-#include <iostream>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <unistd.h>
-#include <iomanip> // For std::setprecision
-
-// Define some helper functions for libcamera callbacks
-static void request_complete(libcamera::Request* request) {
-    // This function will be called by libcamera when a request is complete.
-    // We need to manage the lifetime of the request here.
-    // For now, we just indicate it's complete.
+#include "process_supervisor.hpp" // Include the new supervisor
 
-}
+#include <iostream>
+#include <vector>
+#include <string>
+#include <cstring> // For strerror
+#include <algorithm> // For std::remove_if
+#include <sstream> // For std::ostringstream
 
-CameraCapture::CameraCapture(unsigned int width, unsigned int height, ThreadSafeQueue& output_queue)
+CameraCapture::CameraCapture(unsigned int width, unsigned int height, ImageQueue& output_queue, std::chrono::seconds watchdog_timeout)
     : width_(width), height_(height), output_queue_(output_queue) {
-    camera_manager_ = std::make_unique<libcamera::CameraManager>();
+
+    supervisor_ = std::make_unique<ProcessSupervisor<ImageQueue, ImageData>>(
+        "Inference rpicam-vid",
+        [this]() { return get_command_args(); }, // Command arguments builder
+        [this](std::vector<uint8_t>& buffer, size_t bytes_read, ImageQueue& queue) { // Frame parser
+            return parse_frame_data(buffer, bytes_read, queue);
+        },
+        output_queue_,
+        watchdog_timeout
+    );
 }
 
 CameraCapture::~CameraCapture() {
@@ -24,218 +28,55 @@ CameraCapture::~CameraCapture() {
 }
 
 bool CameraCapture::start() {
-    LOG_INFO("Starting camera capture...");
-    if (running_) {
-        LOG_ERROR("CameraCapture is already running.");
-        return false;
-    }
-
-    int ret = camera_manager_->start();
-    if (ret) {
-        LOG_ERROR("Failed to start camera manager: " + std::to_string(ret));
-        return false;
-    }
-    LOG_INFO("Camera manager started.");
-
-    if (camera_manager_->cameras().empty()) {
-        LOG_ERROR("No cameras found.");
-        camera_manager_->stop();
-        return false;
-    }
-    LOG_INFO("Found " + std::to_string(camera_manager_->cameras().size()) + " cameras.");
-
-    camera_ = camera_manager_->cameras()[0]; // Use the first camera found
-    LOG_INFO("Using camera: " + camera_->id());
-
-    ret = camera_->acquire();
-    if (ret) {
-        LOG_ERROR("Failed to acquire camera: " + std::to_string(ret));
-        camera_manager_->stop(); // Stop manager here too
-        return false;
-    }
-    LOG_INFO("Camera acquired.");
-
-    config_ = camera_->generateConfiguration({libcamera::StreamRole::Viewfinder});
-    if (!config_) {
-        LOG_ERROR("Failed to generate camera configuration.");
-        camera_->release();
-        camera_manager_->stop();
-        return false;
-    }
-    LOG_INFO("Camera configuration generated.");
-
-    // Set resolution
-    // config_->at(0).pixelFormat = libcamera::formats::BGR888; // Let libcamera choose the format
-    config_->at(0).size.width = width_;
-    config_->at(0).size.height = height_;
-    config_->at(0).bufferCount = 4; // Number of buffers for the stream
-    LOG_INFO("Set camera resolution to " + std::to_string(width_) + "x" + std::to_string(height_));
-
-    // Validate and apply configuration
-    libcamera::CameraConfiguration::Status config_status = config_->validate();
-    if (config_status == libcamera::CameraConfiguration::Invalid) {
-        LOG_ERROR("Failed to validate camera configuration.");
-        camera_->release();
-        camera_manager_->stop();
-        return false;
-    } else if (config_status == libcamera::CameraConfiguration::Adjusted) {
-        LOG_INFO("Camera configuration was adjusted.");
-    }
-    LOG_INFO("Camera configuration validated.");
-
-    ret = camera_->configure(config_.get());
-    if (ret) {
-        LOG_ERROR("Failed to configure camera: " + std::to_string(ret));
-        camera_->release();
-        camera_manager_->stop();
-        return false;
-    }
-    LOG_INFO("Camera configured.");
-    LOG_INFO("libcamera chose pixel format: " + config_->at(0).pixelFormat.toString());
-
-    stream_ = config_->at(0).stream();
-    allocator_ = new libcamera::FrameBufferAllocator(camera_);
-    ret = allocator_->allocate(stream_);
-    if (ret) {
-        LOG_ERROR("Failed to allocate buffers: " + std::to_string(ret));
-        delete allocator_; // Clean up allocator
-        allocator_ = nullptr;
-        camera_->release(); // Release camera
-        camera_manager_->stop(); // Stop manager
-        return false;
-    }
-    LOG_INFO("Buffers allocated.");
-
-    for (const auto& buffer : allocator_->buffers(stream_)) {
-        std::unique_ptr<libcamera::Request> request = camera_->createRequest();
-        if (!request) {
-            LOG_ERROR("Failed to create request.");
-            return false;
-        }
-        ret = request->addBuffer(stream_, buffer.get());
-        if (ret) {
-            LOG_ERROR("Failed to add buffer to request: " + std::to_string(ret));
-            return false;
-        }
-        camera_->queueRequest(request.release()); // libcamera takes ownership
-    }
-    LOG_INFO("Requests queued.");
-
-    camera_->requestCompleted.connect(this, &CameraCapture::process_request);
-
-    ret = camera_->start();
-    if (ret) {
-        LOG_ERROR("Failed to start camera: " + std::to_string(ret));
-        camera_->release();
-        camera_manager_->stop();
-        return false;
-    }
-    LOG_INFO("Camera started.");
-
-    running_ = true;
-    capture_thread_ = std::thread(&CameraCapture::capture_thread_func, this);
-
-    LOG_INFO("CameraCapture started successfully.");
-    return true;
+    return supervisor_->start();
 }
 
 void CameraCapture::stop() {
-    if (running_.exchange(false)) { // Atomically set running to false and check its previous value
-        output_queue_.set_running(false);
-        if (capture_thread_.joinable()) {
-            capture_thread_.join();
-        }
-    }
-
-    // Stop the camera and manager. It's generally safe to call these
-    // even if they weren't fully started, but we check for existence first.
-    if (camera_) {
-        camera_->stop();
-        camera_->release();
-    }
-    if (camera_manager_) {
-        camera_manager_->stop();
-    }
-
-    // The allocator is a raw pointer and must be manually deleted.
-    if (allocator_) {
-        // In a more complex scenario, we might need to free buffers first,
-        // but deleting the allocator should handle this for now.
-        delete allocator_;
-        allocator_ = nullptr;
-    }
-
-    LOG_INFO("CameraCapture stopped.");
+    supervisor_->stop();
 }
 
-void CameraCapture::capture_thread_func() {
-    auto last_fps_time = std::chrono::high_resolution_clock::now();
-    int frames_in_period = 0;
-
-    while (running_) {
-        // libcamera operates asynchronously. Requests are queued and completed via signals.
-        // The main work for this thread is to manage requests and potentially report FPS.
-        // The actual frame processing happens in process_request callback.
-
-        // The camera_->requestCompleted signal handler handles the frame data.
-        // We ensure that we continuously queue requests.
-
-        // For now, this thread primarily keeps the `running_` flag active and can report FPS.
-        // A more sophisticated approach might involve waiting for a certain number of requests
-        // or checking queue depth, but for basic operation, the signal handler is key.
-
-        auto now = std::chrono::high_resolution_clock::now();
-        std::chrono::duration<double> diff = now - last_fps_time;
-
-        if (diff.count() >= 1.0) {
-            double fps = frames_captured_ / diff.count();
-            std::cout << "Camera FPS: " << std::fixed << std::setprecision(2) << fps << std::endl;
-            frames_captured_ = 0;
-            last_fps_time = now;
-        }
-        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Prevent busy-waiting
-    }
+bool CameraCapture::is_running() const {
+    return supervisor_->is_running();
 }
 
-void CameraCapture::process_request(libcamera::Request* request) {
-    if (request->status() == libcamera::Request::RequestComplete) {
-        libcamera::FrameBuffer* buffer = request->buffers().at(stream_);
-        if (buffer) {
-            void* mem = nullptr;
-            size_t buffer_len = 0; // Declare buffer_len here
-
-            for (const libcamera::FrameBuffer::Plane& plane : buffer->planes()) {
-                buffer_len = plane.length; // Assign buffer_len here
-                int fd = plane.fd.get();   // Use plane.fd.get() to extract the raw fd
-
-                if (fd < 0) {
-                    std::cerr << "Failed to get FD for buffer plane." << std::endl;
-                    continue; // Skip this plane
-                }
-
-                mem = mmap(nullptr, buffer_len, PROT_READ, MAP_SHARED, fd, 0);
-                if (mem == MAP_FAILED) {
-                    std::cerr << "Failed to mmap buffer." << std::endl;
-                    close(fd);
-                    continue; // Skip this plane
-                }
-
-                ImageData image_data;
-                image_data.width = width_;
-                image_data.height = height_;
-                image_data.timestamp = std::chrono::high_resolution_clock::now();
-                image_data.data.assign(static_cast<uint8_t*>(mem), static_cast<uint8_t*>(mem) + buffer_len);
-
-                output_queue_.push(std::move(image_data));
-                frames_captured_++;
+std::vector<std::string> CameraCapture::get_command_args() {
+    // Current log output: Model Input Dimensions: 300x300x3
+    // Explicitly construct the full JSON string to avoid multi-line issues with the tool
+    std::string json_config = "{\"width\":" + std::to_string(width_) + "\"height\":" + std::to_string(height_) + "\"codec\":\"bgr888\"}";
+    LOG_JSON("rpicam-vid_inference_config", json_config);
+
+    return {
+        "/usr/bin/rpicam-vid",
+        "-t", "0",
+        "--width", std::to_string(width_),
+        "--height", std::to_string(height_),
+        "--codec", "bgr888", // Explicitly request BGR888 for inference
+        "--nopreview",
+        "--output", "-"
+    };
+}
 
-                munmap(mem, buffer_len);
-                close(fd);
-            }
-        }
-    } else {
-        std::cerr << "Request completed with status: " << request->status() << std::endl;
-    }
-    // Re-queue the request for the next frame
-    camera_->queueRequest(request); // libcamera takes ownership
+bool CameraCapture::parse_frame_data(std::vector<uint8_t>& buffer, size_t new_bytes_read, ImageQueue& queue) {
+    const size_t expected_frame_size = width_ * height_ * 3;
+    bool frame_parsed = false;
+
+    // We don't use new_bytes_read directly here, as `buffer` accumulates data.
+    // Instead, we check if `buffer` contains at least one full frame.
+    while (buffer.size() >= expected_frame_size) {
+        ImageData image_data;
+        image_data.width = width_;
+        image_data.height = height_;
+        image_data.timestamp = std::chrono::high_resolution_clock::now();
+        
+        // Copy the frame data
+        image_data.data.assign(buffer.begin(), buffer.begin() + expected_frame_size);
+        
+        // Push to queue
+        queue.push(std::move(image_data));
+        
+        // Remove the consumed frame data from the buffer
+        buffer.erase(buffer.begin(), buffer.begin() + expected_frame_size);
+        frame_parsed = true;
+    }
+    return frame_parsed;
 }
diff --git a/src/camera_capture.h b/src/camera_capture.h
index 36a6dbf..ba6765e 100644
--- a/src/camera_capture.h
+++ b/src/camera_capture.h
@@ -1,99 +1,120 @@
+/**
+ * @file camera_capture.h
+ * @brief Defines the CameraCapture class for managing a dedicated raw image stream
+ *        using rpicam-vid subprocess and robust supervision.
+ *
+ * This class is responsible for launching and supervising an rpicam-vid subprocess
+ * that captures a raw image stream (e.g., BGR888). It reads raw image data from the
+ * subprocess's stdout pipe, converts it into ImageData objects, and pushes them
+ * into a thread-safe queue for consumption by an inference engine. It leverages
+ * the ProcessSupervisor for robust process management, including restart policies
+ * and watchdog functionality.
+ */
+
 #ifndef CAMERA_CAPTURE_H
 #define CAMERA_CAPTURE_H
 
-#include <libcamera/libcamera.h>
 #include <thread>
-#include <vector>
-#include <string>
-#include <mutex>
-#include <condition_variable>
-#include <queue>
 #include <atomic>
+#include <string>
+#include <vector>
 #include <chrono>
+#include <memory> // For std::unique_ptr
 
-// Simple structure to hold image data
-struct ImageData {
-    std::vector<uint8_t> data;
-    size_t width;
-    size_t height;
-    std::chrono::high_resolution_clock::time_point timestamp;
-};
-
-// Thread-safe queue for image data
-class ThreadSafeQueue {
-public:
-    void push(ImageData new_data) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        queue_.push(std::move(new_data));
-        cond_var_.notify_one();
-    }
-
-    bool pop(ImageData& data) {
-        std::unique_lock<std::mutex> lock(mutex_);
-        cond_var_.wait(lock, [this]{ return !queue_.empty() || !running_; });
-        if (queue_.empty()) {
-            return false;
-        }
-        data = std::move(queue_.front());
-        queue_.pop();
-        return true;
-    }
-
-    bool try_pop(ImageData& data) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        if (queue_.empty()) {
-            return false;
-        }
-        data = std::move(queue_.front());
-        queue_.pop();
-        return true;
-    }
-
-    bool empty() const {
-        std::lock_guard<std::mutex> lock(mutex_);
-        return queue_.empty();
-    }
-
-    void set_running(bool val) {
-        running_ = val;
-        if (!val) {
-            cond_var_.notify_all(); // Unblock any waiting threads
-        }
-    }
-
-private:
-    mutable std::mutex mutex_;
-    std::queue<ImageData> queue_;
-    std::condition_variable cond_var_;
-    std::atomic<bool> running_ = true;
-};
+#include "pipeline_structs.h"
+#include "process_supervisor.hpp" // Include the new supervisor
 
+/**
+ * @brief Manages a dedicated raw image camera stream using an rpicam-vid subprocess.
+ *
+ * This class encapsulates the logic for capturing a raw video stream from the
+ * camera via an rpicam-vid subprocess. It utilizes the ProcessSupervisor to
+ * ensure the stability and reliability of the subprocess. Raw image data is
+ * read from the subprocess's pipe, converted, and then pushed into a shared queue.
+ */
 class CameraCapture {
 public:
-    CameraCapture(unsigned int width, unsigned int height, ThreadSafeQueue& output_queue);
+    /**
+     * @brief Constructor for CameraCapture.
+     *
+     * Initializes the camera capture module with specified dimensions and a reference
+     * to the output queue where parsed image data will be pushed. It also sets up
+     * the ProcessSupervisor for robust subprocess management.
+     *
+     * @param width The desired width of the raw image stream.
+     * @param height The desired height of the raw image stream.
+     * @param output_queue Reference to the thread-safe ImageQueue for output.
+     * @param watchdog_timeout The duration after which a lack of activity in the
+     *                         stream will trigger a subprocess restart (e.g., 5 seconds).
+     */
+    CameraCapture(unsigned int width, unsigned int height, ImageQueue& output_queue, std::chrono::seconds watchdog_timeout);
+
+    /**
+     * @brief Destructor for CameraCapture.
+     *
+     * Ensures that the capture process and associated threads are gracefully stopped.
+     */
     ~CameraCapture();
 
+    /**
+     * @brief Starts the camera capture process and its supervisor.
+     *
+     * Launches the rpicam-vid subprocess and initiates the monitoring and
+     * pipe reading threads.
+     *
+     * @return True if the module started successfully, false otherwise.
+     */
     bool start();
+
+    /**
+     * @brief Stops the camera capture process and its supervisor.
+     *
+     * Sends termination signals to the subprocess and joins all associated threads
+     * for a clean shutdown.
+     */
     void stop();
-    bool is_running() const { return running_; }
 
-private:
-    void capture_thread_func();
-    void process_request(libcamera::Request* request);
+    /**
+     * @brief Checks if the camera capture module is currently running.
+     *
+     * @return True if the module is running, false otherwise.
+     */
+    bool is_running() const; // Delegates to supervisor's is_running()
 
-    unsigned int width_;
-    unsigned int height_;
-    ThreadSafeQueue& output_queue_;
+private:
+    unsigned int width_;  ///< The width of the captured raw image stream.
+    unsigned int height_; ///< The height of the captured raw image stream.
+    ImageQueue& output_queue_; ///< Reference to the queue where processed ImageData objects are pushed.
+    
+    /**
+     * @brief Generates the command-line arguments for the rpicam-vid subprocess.
+     *
+     * Constructs a vector of strings representing the arguments to be passed to
+     * `/usr/bin/rpicam-vid` for raw image capture (e.g., BGR888). Includes
+     * parameters for codec, dimensions, and output to stdout. Logs the configuration as JSON.
+     *
+     * @return A vector of strings containing the rpicam-vid command arguments.
+     */
+    std::vector<std::string> get_command_args();
 
-    std::unique_ptr<libcamera::CameraManager> camera_manager_;
-    std::shared_ptr<libcamera::Camera> camera_;
-    std::unique_ptr<libcamera::CameraConfiguration> config_;
-    libcamera::Stream* stream_ = nullptr;
-    libcamera::FrameBufferAllocator* allocator_ = nullptr;
+    /**
+     * @brief Parses raw byte data from the pipe into complete ImageData objects.
+     *
+     * This function is passed as a callback to the ProcessSupervisor. It accumulates
+     * bytes in the buffer and, once a full frame's worth of data is received, it
+     * constructs an ImageData object and pushes it to the output queue. Consumed
+     * bytes are removed from the buffer.
+     *
+     * @param buffer A reference to the buffer accumulating raw byte data.
+     * @param bytes_read The number of new bytes read in the current read operation (not directly used for parsing,
+     *                   the entire buffer content is processed).
+     * @param queue The output ImageQueue to push parsed ImageData objects.
+     * @return True if at least one complete frame was parsed and pushed, false otherwise.
+     */
+    bool parse_frame_data(std::vector<uint8_t>& buffer, size_t bytes_read, ImageQueue& queue);
 
-    std::atomic<bool> running_ = false;
-    std::thread capture_thread_;
-    std::atomic<int> frames_captured_ = 0;
+    /// Unique pointer to the ProcessSupervisor instance managing the rpicam-vid subprocess.
+    std::unique_ptr<ProcessSupervisor<ImageQueue, ImageData>> supervisor_;
 };
 
 #endif // CAMERA_CAPTURE_H
diff --git a/src/inference.cpp b/src/inference.cpp
index acae3e6..9cfed6d 100644
--- a/src/inference.cpp
+++ b/src/inference.cpp
@@ -1,207 +1,352 @@
+/**
+ * @file inference.cpp
+ * @brief Implements the InferenceEngine class for running TensorFlow Lite models
+ *        with Edge TPU acceleration on captured image data.
+ *
+ * This module handles model loading, interpreter creation, Edge TPU delegate
+ * integration, input tensor preparation (including color space conversion),
+ * model invocation, and parsing of output tensors for object detection results.
+ * It operates in a multi-threaded environment, with worker threads performing
+ * inference on frames from a queue and pushing results to another queue.
+ */
+
 #include "inference.h"
+#include "util_logging.h"
 #include <iostream>
-#include <algorithm> // For std::sort
-#include <cmath>     // For std::abs
+#include <stdexcept>
+#include <algorithm>
+#include <cmath>
 
-// Edge TPU delegate C API functions
+// Edge TPU delegate C API functions - Adjusted signature based on previous iteration backup
+// These functions are dynamically linked from libedgetpu.so
 extern "C" {
-    TfLiteDelegate* tflite_plugin_create_delegate(char** options_keys, char** options_values, size_t num_options);
+    /**
+     * @brief Creates an Edge TPU delegate instance.
+     *
+     * This function is part of the Edge TPU C API and is used to acquire
+     * a delegate that can be applied to a TensorFlow Lite interpreter
+     * to enable acceleration on the Coral Edge TPU.
+     *
+     * @param options A pointer to delegate-specific options (can be nullptr for default).
+     * @return A pointer to a TfLiteDelegate instance, or nullptr on failure.
+     */
+    TfLiteDelegate* tflite_plugin_create_delegate(const void* options);
+
+    /**
+     * @brief Destroys an Edge TPU delegate instance.
+     *
+     * This function is part of the Edge TPU C API and is used to deallocate
+     * resources associated with an Edge TPU delegate.
+     *
+     * @param delegate A pointer to the TfLiteDelegate instance to destroy.
+     */
     void tflite_plugin_destroy_delegate(TfLiteDelegate* delegate);
 }
 
-InferenceEngine::InferenceEngine(const std::string& model_path, ThreadSafeQueue& input_queue, DetectionQueue& output_queue, int num_threads)
-    : model_path_(model_path), input_queue_(input_queue), output_queue_(output_queue), num_threads_(num_threads) {
-
+/**
+ * @brief Constructor for InferenceEngine.
+ *
+ * Initializes the inference engine by loading the TensorFlow Lite model from the
+ * specified path, performing a pre-check for Edge TPU delegate creation, and
+ * extracting input tensor dimensions for validation and processing.
+ *
+ * @param model_path The filesystem path to the TensorFlow Lite model file.
+ * @param input_queue Reference to the ImageQueue from which image data is consumed.
+ * @param udp_output_queue Reference to the UdpQueue where detection results are pushed.
+ * @param num_threads The number of worker threads to use for inference.
+ * @throws std::runtime_error if the model fails to load, delegate pre-check fails,
+ *         or input tensor dimensions are invalid.
+ */
+InferenceEngine::InferenceEngine(const std::string& model_path, ImageQueue& input_queue, UdpQueue& udp_output_queue, int num_threads)
+    : model_path_(model_path), input_queue_(input_queue), udp_output_queue_(udp_output_queue), num_threads_(num_threads) {
+
+    // Load the TensorFlow Lite model from the file system.
     model_ = tflite::FlatBufferModel::BuildFromFile(model_path_.c_str());
     if (!model_) {
-        std::cerr << "Failed to load model: " << model_path_ << std::endl;
-        // Handle error appropriately, e.g., throw exception
+        throw std::runtime_error("Failed to load model: " + model_path_ + ". Please ensure the model path is correct and the file exists.");
+    }
+
+    // Create a temporary interpreter for model inspection (e.g., getting dimensions).
+    std::unique_ptr<tflite::Interpreter> interpreter;
+    tflite::InterpreterBuilder(*model_, resolver_)(&interpreter);
+    if (!interpreter) {
+        throw std::runtime_error("Failed to create temporary interpreter for model inspection.");
+    }
+    
+    // Pre-check for Edge TPU delegate creation during initialization.
+    // This helps in failing fast if the Edge TPU is not available or drivers are not installed.
+    TfLiteDelegate* test_delegate = tflite_plugin_create_delegate(nullptr);
+    if (!test_delegate) {
+        throw std::runtime_error("Failed to create Edge TPU delegate during initialization. Ensure Edge TPU drivers are installed and device is connected.");
+    }
+    // The test delegate is not owned by the interpreter yet, so destroy it immediately.
+    tflite_plugin_destroy_delegate(test_delegate);
+
+    // Extract input tensor dimensions from the model.
+    int input_tensor_idx = interpreter->inputs()[0];
+    TfLiteTensor* input_tensor = interpreter->tensor(input_tensor_idx);
+    
+    // Validate input tensor dimensions. Expects a 4D tensor (Batch, Height, Width, Channels).
+    if (input_tensor->dims->size < 4) {
+        throw std::runtime_error("Model input tensor has fewer than 4 dimensions, which is not supported.");
+    }
+    input_height_ = input_tensor->dims->data[1];
+    input_width_ = input_tensor->dims->data[2];
+    input_channels_ = input_tensor->dims->data[3];
+    
+    LOG_INFO("Model Input Dimensions: " + std::to_string(input_width_) + "x" + std::to_string(input_height_) + "x" + std::to_string(input_channels_));
+
+    // This application is designed for 3-channel (RGB/BGR) input images.
+    if (input_channels_ != 3) {
+        throw std::runtime_error("Model expects " + std::to_string(input_channels_) + " channels, but this application is hardcoded for 3 (RGB).");
     }
 }
 
+/**
+ * @brief Destructor for InferenceEngine.
+ *
+ * Ensures that all inference worker threads are stopped gracefully.
+ */
 InferenceEngine::~InferenceEngine() {
     stop();
 }
 
+/**
+ * @brief Starts the inference engine worker threads.
+ *
+ * Launches a specified number of worker threads, each running an inference loop.
+ *
+ * @return True if the engine started successfully, false otherwise.
+ */
 bool InferenceEngine::start() {
     if (running_) {
-        std::cerr << "InferenceEngine is already running." << std::endl;
+        LOG_ERROR("InferenceEngine is already running.");
         return false;
     }
-
     if (!model_) {
-        std::cerr << "Model not loaded, cannot start inference engine." << std::endl;
+        LOG_ERROR("Model not loaded, cannot start inference engine.");
         return false;
     }
 
     running_ = true;
-    for (int i = 0; i < num_threads_; ++i) {
-        // Create an interpreter for each thread
-        std::unique_ptr<tflite::Interpreter> interpreter = create_interpreter();
-        if (!interpreter) {
-            std::cerr << "Failed to create interpreter for worker " << i << std::endl;
-            running_ = false;
-            return false;
-        }
-        std::lock_guard<std::mutex> lock(interpreter_pool_mutex_);
-        interpreter_pool_.push(std::move(interpreter));
+    // Signal to associated queues that they should continue running.
+    input_queue_.set_running(true);
+    udp_output_queue_.set_running(true);
 
+    // Create and launch worker threads. Each thread will create its own interpreter.
+    for (int i = 0; i < num_threads_; ++i) {
         worker_threads_.emplace_back(&InferenceEngine::worker_thread_func, this);
     }
 
-    std::cout << "InferenceEngine started with " << num_threads_ << " worker threads." << std::endl;
+    LOG_INFO("InferenceEngine started with " + std::to_string(num_threads_) + " worker threads.");
     return true;
 }
 
+/**
+ * @brief Stops the inference engine worker threads.
+ *
+ * Sets the running flag to false, signals associated queues to stop, and joins
+ * all worker threads for a clean shutdown.
+ */
 void InferenceEngine::stop() {
-    if (!running_) {
-        return;
-    }
-    running_ = false;
-    output_queue_.set_running(false); // Signal consumers to stop
-    // Also signal the input queue to unblock the inference threads
-    input_queue_.set_running(false);
-    
-    for (std::thread& thread : worker_threads_) {
-        if (thread.joinable()) {
-            thread.join();
+    if (running_.exchange(false)) { // Atomically set running_ to false and check previous value
+        LOG_INFO("Stopping InferenceEngine...");
+        // Signal associated queues to stop.
+        udp_output_queue_.set_running(false);
+        input_queue_.set_running(false);
+        
+        // Join all worker threads to ensure they complete their tasks or exit.
+        for (std::thread& thread : worker_threads_) {
+            if (thread.joinable()) {
+                thread.join();
+            }
         }
+        worker_threads_.clear();
+        LOG_INFO("InferenceEngine stopped.");
     }
-    worker_threads_.clear();
-    std::cout << "InferenceEngine stopped." << std::endl;
 }
 
+/**
+ * @brief Creates and initializes a TensorFlow Lite interpreter with the Edge TPU delegate.
+ *
+ * This function is called by each worker thread to get its own interpreter instance.
+ * It builds the interpreter from the loaded model, creates and applies the Edge TPU
+ * delegate, and allocates tensors. Proper error handling and delegate cleanup are included.
+ *
+ * @return A unique pointer to a configured tflite::Interpreter, or nullptr on failure.
+ */
 std::unique_ptr<tflite::Interpreter> InferenceEngine::create_interpreter() {
     std::unique_ptr<tflite::Interpreter> local_interpreter;
+    // Build the interpreter using the model and a standard op resolver.
     tflite::InterpreterBuilder(*model_, resolver_)(&local_interpreter);
-
     if (!local_interpreter) {
-        std::cerr << "Failed to create interpreter." << std::endl;
+        LOG_ERROR("Failed to build interpreter.");
         return nullptr;
     }
 
-    // Attach EdgeTPU delegate
-    // Options can be passed as key-value pairs if needed
-    char* options_keys[] = {};
-    char* options_values[] = {};
-    size_t num_options = 0;
-
-    TfLiteDelegate* delegate = tflite_plugin_create_delegate(options_keys, options_values, num_options);
+    // Create the Edge TPU delegate.
+    TfLiteDelegate* delegate = tflite_plugin_create_delegate(nullptr);
     if (!delegate) {
-        std::cerr << "Failed to create EdgeTPU delegate." << std::endl;
+        LOG_ERROR("Failed to create EdgeTPU delegate. Ensure libedgetpu1-std is installed and device is connected.");
         return nullptr;
     }
 
+    // Apply the Edge TPU delegate to the interpreter.
     if (local_interpreter->ModifyGraphWithDelegate(delegate) != kTfLiteOk) {
-        std::cerr << "Failed to apply EdgeTPU delegate." << std::endl;
+        LOG_ERROR("Failed to apply EdgeTPU delegate. Check if the model is compatible with Edge TPU.");
+        // If ModifyGraphWithDelegate fails, the interpreter does not take ownership of the delegate.
         tflite_plugin_destroy_delegate(delegate);
         return nullptr;
     }
-
+    
+    // Allocate tensors. This must be done *after* applying the delegate.
     if (local_interpreter->AllocateTensors() != kTfLiteOk) {
-        std::cerr << "Failed to allocate tensors." << std::endl;
-        tflite_plugin_destroy_delegate(delegate);
+        LOG_ERROR("Failed to allocate tensors after applying EdgeTPU delegate.");
+        // In this specific case, if AllocateTensors fails *after* ModifyGraphWithDelegate succeeded,
+        // the interpreter might *already* own the delegate. Destroying it here might be a double-free
+        // or lead to issues if the interpreter attempts to destroy it later.
+        // For simplicity and safety in this context, we re-destroy it, assuming that if allocation fails,
+        // the interpreter is in an invalid state and should be discarded. A more robust solution
+        // might involve a custom deleter for unique_ptr or checking delegate ownership carefully.
+        tflite_plugin_destroy_delegate(delegate); 
         return nullptr;
     }
-
+    
     return local_interpreter;
 }
 
+/**
+ * @brief The main function for an inference worker thread.
+ *
+ * Each worker thread continuously pops ImageFrame data from the input queue,
+ * prepares the input tensor, invokes the TensorFlow Lite interpreter, parses
+ * the output tensors, and pushes detection results to the UDP output queue.
+ * The loop continues until the `running_` flag is set to false.
+ */
 void InferenceEngine::worker_thread_func() {
-    std::unique_ptr<tflite::Interpreter> interpreter;
-
-    // Get an interpreter from the pool
-    {
-        std::lock_guard<std::mutex> lock(interpreter_pool_mutex_);
-        if (!interpreter_pool_.empty()) {
-            interpreter = std::move(interpreter_pool_.front());
-            interpreter_pool_.pop();
-        } else {
-            std::cerr << "Interpreter pool is empty for worker thread!" << std::endl;
-            return; // Should not happen if pool is sized correctly
-        }
+    // Each worker thread creates and owns its own interpreter instance.
+    // This avoids thread-safety issues with a single interpreter.
+    std::unique_ptr<tflite::Interpreter> interpreter = create_interpreter();
+    if (!interpreter) {
+        LOG_ERROR("Worker thread failed to create interpreter. Exiting thread.");
+        return;
     }
-
+    
     ImageData input_image;
     while (running_) {
-        if (input_queue_.pop(input_image)) { // Blocking call
-            auto inference_start_time = std::chrono::high_resolution_clock::now();
+        // Attempt to pop an image from the input queue.
+        // The queue's pop method will block until data is available or `running_` is false.
+        if (input_queue_.pop(input_image)) {
+            // Validate input image data size against expected model input size.
+            int expected_input_size = input_width_ * input_height_ * input_channels_;
+            if (input_image.data.size() != expected_input_size) {
+                 LOG_ERROR("Input image data size (" + std::to_string(input_image.data.size()) + 
+                           ") does not match expected model input size (" + std::to_string(expected_input_size) + "). Skipping frame.");
+                 continue; // Skip this frame and try the next one.
+            }
 
+            // Prepare the input tensor for the interpreter.
             set_input_tensor(interpreter.get(), input_image);
 
+            // Invoke the TensorFlow Lite interpreter to perform inference.
             if (interpreter->Invoke() != kTfLiteOk) {
-                std::cerr << "Failed to invoke interpreter." << std::endl;
-                continue;
+                LOG_ERROR("Failed to invoke interpreter. Skipping frame.");
+                continue; // Skip this frame.
+            }
+            
+            // Parse the output tensors to get detection results.
+            std::vector<DetectionResult> results = get_output_tensor(interpreter.get());
+            
+            // Push detection results to the UDP output queue if any detections were made.
+            if (!results.empty()) {
+                udp_output_queue_.push(std::move(results));
             }
-
-            std::vector<DetectionResult> results = get_output_tensor(interpreter.get(), input_image);
-            output_queue_.push(std::move(results));
-
-            auto inference_end_time = std::chrono::high_resolution_clock::now();
-            std::chrono::duration<double, std::milli> inference_duration = inference_end_time - inference_start_time;
-            // std::cout << "Inference time: " << inference_duration.count() << " ms" << std::endl;
         }
     }
-
-    // Return interpreter to pool (or destroy it, if we're shutting down the pool)
-    // For now, it will be destroyed when unique_ptr goes out of scope.
-    // If we wanted to re-pool it, we'd push it back to a shared queue before exiting.
 }
 
+/**
+ * @brief Prepares the interpreter's input tensor with image data.
+ *
+ * This function copies the raw image data into the interpreter's input tensor.
+ * It also handles the color channel swap from BGR (from camera) to RGB (expected by model).
+ * Performs validation checks for tensor type and size.
+ *
+ * @param interpreter A pointer to the TensorFlow Lite interpreter.
+ * @param image The ImageData object containing the raw image pixels.
+ */
 void InferenceEngine::set_input_tensor(tflite::Interpreter* interpreter, const ImageData& image) {
-    // Assuming the model expects a single input tensor of type kTfLiteUInt8
-    // and layout (1, height, width, channels)
-    // Here we need to convert the YUV420 image to RGB or grayscale as expected by the model.
-    // For now, we'll assume the model expects a single-channel grayscale image
-    // and copy the Y plane directly, or if it expects RGB, we'd need conversion.
-
     int input_tensor_idx = interpreter->inputs()[0];
     TfLiteTensor* input_tensor = interpreter->tensor(input_tensor_idx);
 
+    // Validate input tensor type. Expects UINT8 for quantized models.
     if (input_tensor->type != kTfLiteUInt8) {
-        std::cerr << "Input tensor type is not kTfLiteUInt8. Model might expect a different format." << std::endl;
-        // Handle error, maybe convert type
+        LOG_ERROR("Input tensor type is not kTfLiteUInt8 as expected. Current type: " + std::to_string(input_tensor->type) + ". Skipping frame.");
+        return;
     }
-
-    if (input_tensor->bytes != image.data.size()) {
-        std::cerr << "WARNING: Input tensor size mismatch. Expected " << input_tensor->bytes
-                  << ", got " << image.data.size() << ". This will likely lead to incorrect inference results." << std::endl;
-        std::cerr << "         Image resizing needs to be implemented." << std::endl;
+    // The input_tensor->bytes (expected size) should have already been validated against image.data.size()
+    // before this call in worker_thread_func.
+
+    // Get a pointer to the input tensor's data buffer.
+    uint8_t* tensor_data = interpreter->typed_input_tensor<uint8_t>(0);
+    const uint8_t* image_data = image.data.data();
+    int num_pixels = input_width_ * input_height_;
+
+    // Perform BGR to RGB conversion by swapping the red and blue channels.
+    // Assuming 3 channels (RGB) in both input and output.
+    for (int i = 0; i < num_pixels; ++i) {
+        tensor_data[i * 3 + 0] = image_data[i * 3 + 2]; // R = B (from source)
+        tensor_data[i * 3 + 1] = image_data[i * 3 + 1]; // G = G (from source)
+        tensor_data[i * 3 + 2] = image_data[i * 3 + 0]; // B = R (from source)
     }
-
-    // Copy image data to input tensor
-    // This will likely cause a buffer overflow if the image is larger than the input tensor.
-    // For now, we'll just copy the first `input_tensor->bytes` bytes.
-    std::copy(image.data.begin(), image.data.begin() + input_tensor->bytes, interpreter->typed_input_tensor<uint8_t>(0));
 }
 
-std::vector<DetectionResult> InferenceEngine::get_output_tensor(tflite::Interpreter* interpreter, const ImageData& image) {
+/**
+ * @brief Extracts and parses object detection results from the interpreter's output tensors.
+ *
+ * This function assumes a specific output tensor structure typical for SSD MobileNet models:
+ * 0: detection_boxes (float, [1, num_detections, 4]) - Bounding box coordinates [ymin, xmin, ymax, xmax] normalized [0,1].
+ * 1: detection_classes (float, [1, num_detections]) - Class IDs.
+ * 2: detection_scores (float, [1, num_detections]) - Confidence scores.
+ * 3: num_detections (float, [1]) - Actual number of detections.
+ *
+ * It applies a confidence threshold (0.5) and scales bounding box coordinates to image dimensions.
+ *
+ * @param interpreter A pointer to the TensorFlow Lite interpreter.
+ * @return A vector of DetectionResult objects found in the current frame.
+ */
+std::vector<DetectionResult> InferenceEngine::get_output_tensor(tflite::Interpreter* interpreter) {
     std::vector<DetectionResult> results;
+    
+    // Ensure the model has the expected number of output tensors.
+    if (interpreter->outputs().size() < 4) {
+        LOG_ERROR("Model does not have expected number of output tensors (expected 4 for SSD MobileNet).");
+        return results;
+    }
 
-    // Assuming a common detection model output format:
-    // Output 0: Detection boxes (1, num_boxes, 4) - [ymin, xmin, ymax, xmax]
-    // Output 1: Detection classes (1, num_boxes)
-    // Output 2: Detection scores (1, num_boxes)
-    // Output 3: Number of detections (1)
+    // Get pointers to the output tensors.
+    const float* detection_boxes = interpreter->typed_output_tensor<float>(0);
+    const float* detection_classes = interpreter->typed_output_tensor<float>(1);
+    const float* detection_scores = interpreter->typed_output_tensor<float>(2);
+    // The num_detections tensor typically contains a single float value indicating the count.
+    const int num_detections = static_cast<int>(*interpreter->typed_output_tensor<float>(3));
 
-    int num_detections = static_cast<int>(*interpreter->typed_output_tensor<float>(3));
-    float* detection_boxes = interpreter->typed_output_tensor<float>(0);
-    float* detection_classes = interpreter->typed_output_tensor<float>(1);
-    float* detection_scores = interpreter->typed_output_tensor<float>(2);
+    auto timestamp = std::chrono::high_resolution_clock::now();
 
+    // Iterate through detected objects and apply a confidence threshold.
     for (int i = 0; i < num_detections; ++i) {
-        if (detection_scores[i] > 0.5) { // Threshold for detections
+        if (detection_scores[i] > 0.5) { // Confidence threshold for valid detections
             DetectionResult res;
             res.class_id = static_cast<int>(detection_classes[i]);
             res.score = detection_scores[i];
-
-            // Bounding box coordinates are normalized [0, 1]
-            // Convert to absolute pixel coordinates
-            res.ymin = detection_boxes[i * 4] * image.height;
-            res.xmin = detection_boxes[i * 4 + 1] * image.width;
-            res.ymax = detection_boxes[i * 4 + 2] * image.height;
-            res.xmax = detection_boxes[i * 4 + 3] * image.width;
-            res.timestamp = image.timestamp;
+            res.timestamp = timestamp;
+
+            // Bounding box coordinates are normalized [0, 1] and in [ymin, xmin, ymax, xmax] order.
+            // Scale them back to the input image dimensions.
+            res.ymin = detection_boxes[i * 4 + 0] * input_height_;
+            res.xmin = detection_boxes[i * 4 + 1] * input_width_;
+            res.ymax = detection_boxes[i * 4 + 2] * input_height_;
+            res.xmax = detection_boxes[i * 4 + 3] * input_width_;
             results.push_back(res);
         }
     }
diff --git a/src/inference.h b/src/inference.h
index 1194ec9..acf2d70 100644
--- a/src/inference.h
+++ b/src/inference.h
@@ -1,98 +1,165 @@
+/**
+ * @file inference.h
+ * @brief Defines the InferenceEngine class for running TensorFlow Lite models
+ *        with Edge TPU acceleration.
+ *
+ * This header provides the interface for the InferenceEngine, which manages
+ * the loading, execution, and output processing of TensorFlow Lite models.
+ * It integrates with the Edge TPU delegate for hardware acceleration and
+ * operates within a multi-threaded pipeline, consuming image data and
+ * producing detection results via thread-safe queues.
+ */
+
 #ifndef INFERENCE_H
 #define INFERENCE_H
 
 #include "tensorflow/lite/interpreter.h"
 #include "tensorflow/lite/model.h"
-#include "tensorflow/lite/kernels/register.h"
-
-#include "tensorflow/lite/c/builtin_op_data.h"
-#include "tensorflow/lite/c/common.h"
+#include "tensorflow/lite/kernels/register.h" // Required for BuiltinOpResolver
+#include "tensorflow/lite/c/common.h"       // Required for TfLiteDelegate
 
 #include <vector>
 #include <string>
-#include <memory>
-#include <thread>
-#include <mutex>
-#include <condition_variable>
-#include <queue>
-#include <atomic>
-#include <chrono>
-
-#include "camera_capture.h" // For ImageData
-
-// Define a structure to hold detection results
-struct DetectionResult {
-    int class_id;
-    float score;
-    float xmin, ymin, xmax, ymax; // Bounding box coordinates
-    std::chrono::high_resolution_clock::time_point timestamp;
-};
-
-// Thread-safe queue for inference results
-class DetectionQueue {
-public:
-    void push(std::vector<DetectionResult> results) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        queue_.push(std::move(results));
-        cond_var_.notify_one();
-    }
-
-    bool pop(std::vector<DetectionResult>& results) {
-        std::unique_lock<std::mutex> lock(mutex_);
-        cond_var_.wait(lock, [this]{ return !queue_.empty(); });
-        if (queue_.empty()) {
-            return false;
-        }
-        results = std::move(queue_.front());
-        queue_.pop();
-        return true;
-    }
-
-    bool empty() const {
-        std::lock_guard<std::mutex> lock(mutex_);
-        return queue_.empty();
-    }
-
-    void set_running(bool val) {
-        running_ = val;
-        if (!val) {
-            cond_var_.notify_all(); // Unblock any waiting threads
-        }
-    }
-
-private:
-    mutable std::mutex mutex_;
-    std::queue<std::vector<DetectionResult>> queue_;
-    std::condition_variable cond_var_;
-    std::atomic<bool> running_ = true;
-};
-
+#include <memory>   // For std::unique_ptr
+#include <thread>   // For std::thread
+#include <atomic>   // For std::atomic
+#include <mutex>    // For std::mutex
+#include <queue>    // For std::queue (used in interpreter_pool_)
+
+#include "pipeline_structs.h" // Use the new central header for queue types and data structures
+
+/**
+ * @brief Manages the TensorFlow Lite inference pipeline with Edge TPU acceleration.
+ *
+ * The InferenceEngine class loads a TFLite model, initializes multiple
+ * interpreter instances (one per worker thread) with the Edge TPU delegate,
+ * and processes incoming ImageData from a queue. It performs inference and
+ * pushes detected objects (DetectionResult) to an output queue.
+ */
 class InferenceEngine {
 public:
-    InferenceEngine(const std::string& model_path, ThreadSafeQueue& input_queue, DetectionQueue& output_queue, int num_threads = 1);
+    /**
+     * @brief Constructor for InferenceEngine.
+     *
+     * Initializes the inference engine, loads the model, and prepares internal
+     * structures. It will throw `std::runtime_error` if model loading or
+     * initial interpreter/delegate setup fails.
+     *
+     * @param model_path The filesystem path to the TensorFlow Lite model file.
+     * @param input_queue Reference to the thread-safe ImageQueue from which
+     *                    raw image data frames are consumed.
+     * @param udp_output_queue Reference to the thread-safe UdpQueue to which
+     *                         detection results are pushed.
+     * @param num_threads The number of worker threads to spawn for parallel inference.
+     */
+    InferenceEngine(const std::string& model_path, ImageQueue& input_queue, UdpQueue& udp_output_queue, int num_threads = 1);
+
+    /**
+     * @brief Destructor for InferenceEngine.
+     *
+     * Ensures all worker threads are stopped gracefully and resources are released.
+     */
     ~InferenceEngine();
 
+    /**
+     * @brief Starts the inference worker threads.
+     *
+     * Launches the configured number of worker threads, each running its
+     * independent inference loop.
+     *
+     * @return True if the engine started successfully, false otherwise.
+     */
     bool start();
+
+    /**
+     * @brief Stops the inference worker threads.
+     *
+     * Signals all worker threads to terminate and waits for them to join.
+     */
     void stop();
+
+    /**
+     * @brief Checks if the inference engine is currently running.
+     *
+     * @return True if the engine is running, false otherwise.
+     */
     bool is_running() const { return running_; }
 
+    /**
+     * @brief Retrieves the input width expected by the loaded TensorFlow Lite model.
+     *
+     * @return The width in pixels.
+     */
+    int get_input_width() const { return input_width_; }
+
+    /**
+     * @brief Retrieves the input height expected by the loaded TensorFlow Lite model.
+     *
+     * @return The height in pixels.
+     */
+    int get_input_height() const { return input_height_; }
+
 private:
+    /**
+     * @brief The main function executed by each inference worker thread.
+     *
+     * This function continuously processes images from the input queue,
+     * performs inference, and pushes results to the output queue.
+     */
     void worker_thread_func();
+
+    /**
+     * @brief Creates and configures a TensorFlow Lite interpreter with the Edge TPU delegate.
+     *
+     * This method is called by each worker thread to obtain its dedicated interpreter instance.
+     *
+     * @return A unique_ptr to a fully initialized interpreter, or nullptr on failure.
+     */
     std::unique_ptr<tflite::Interpreter> create_interpreter();
+
+    /**
+     * @brief Prepares the input tensor for inference.
+     *
+     * Copies image data into the interpreter's input tensor and handles
+     * necessary preprocessing like color channel swapping (BGR to RGB).
+     *
+     * @param interpreter Pointer to the TensorFlow Lite interpreter.
+     * @param image The ImageData to be processed.
+     */
     void set_input_tensor(tflite::Interpreter* interpreter, const ImageData& image);
-    std::vector<DetectionResult> get_output_tensor(tflite::Interpreter* interpreter, const ImageData& image);
-
-    std::string model_path_;
-    ThreadSafeQueue& input_queue_;
-    DetectionQueue& output_queue_;
-    int num_threads_;
-
-    std::unique_ptr<tflite::FlatBufferModel> model_;
-    tflite::ops::builtin::BuiltinOpResolver resolver_;
-    std::vector<std::thread> worker_threads_;
-    std::atomic<bool> running_ = false;
-    std::mutex interpreter_pool_mutex_;
-    std::queue<std::unique_ptr<tflite::Interpreter>> interpreter_pool_;
+
+    /**
+     * @brief Parses the output tensors of the interpreter to extract detection results.
+     *
+     * Assumes a standard output format (e.g., for SSD models) and converts
+     * raw tensor data into a vector of DetectionResult objects.
+     *
+     * @param interpreter Pointer to the TensorFlow Lite interpreter.
+     * @return A vector of detected objects.
+     */
+    std::vector<DetectionResult> get_output_tensor(tflite::Interpreter* interpreter);
+
+    std::string model_path_; ///< Path to the TensorFlow Lite model file.
+    ImageQueue& input_queue_; ///< Reference to the input queue for image data.
+    UdpQueue& udp_output_queue_; ///< Reference to the output queue for detection results.
+    int num_threads_; ///< Number of inference worker threads.
+
+    int input_width_ = 0; ///< Input width required by the loaded model.
+    int input_height_ = 0; ///< Input height required by the loaded model.
+    int input_channels_ = 0; ///< Input channels required by the loaded model (e.g., 3 for RGB/BGR).
+
+    std::unique_ptr<tflite::FlatBufferModel> model_; ///< The loaded TensorFlow Lite model.
+    tflite::ops::builtin::BuiltinOpResolver resolver_; ///< Op resolver for built-in TFLite operations.
+    std::vector<std::thread> worker_threads_; ///< Vector of active inference worker threads.
+    std::atomic<bool> running_ = false; ///< Atomic flag to control the running state of the inference engine.
+    
+    // Note: The interpreter_pool_ and interpreter_pool_mutex_ are remnants from a previous
+    // design where interpreters were pooled. In the current design, each worker thread
+    // creates its own unique_ptr<tflite::Interpreter> instance via create_interpreter().
+    // These members are kept for API compatibility with main.cpp but are not actively used
+    // in the revised inference logic for sharing interpreters.
+    std::mutex interpreter_pool_mutex_; ///< Mutex for protecting access to the interpreter pool (not actively used).
+    std::queue<std::unique_ptr<tflite::Interpreter>> interpreter_pool_; ///< Queue for interpreter instances (not actively used in revised design).
 };
 
-#endif // INFERENCE_H
+#endif // INFERENCE_H
\ No newline at end of file
diff --git a/src/jpeg_wrapper.cpp b/src/jpeg_wrapper.cpp
index ab2a4d8..c273d13 100644
--- a/src/jpeg_wrapper.cpp
+++ b/src/jpeg_wrapper.cpp
@@ -1,10 +1,32 @@
+/**
+ * @file jpeg_wrapper.cpp
+ * @brief Implements a C++ wrapper for libjpeg-turbo for JPEG compression.
+ *
+ * This file provides a utility class `JpegCompressGuard` to simplify the
+ * process of compressing raw pixel data into JPEG format using the libjpeg-turbo
+ * library. It includes custom error handling via `setjmp`/`longjmp` and
+ * a custom destination manager for writing compressed JPEG data directly into
+ * a `std::vector<uint8_t>`.
+ */
+
 #include "jpeg_wrapper.h"
+#include "util_logging.h" // For LOG_ERROR
 #include <iostream>
 #include <cstring> // For memcpy
 #include <csetjmp> // For setjmp/longjmp
 
-
-
+// --- Custom Error Handling for libjpeg ---
+
+/**
+ * @brief Custom error exit handler for libjpeg.
+ *
+ * This function replaces libjpeg's default error handler. Instead of exiting
+ * the program, it uses `longjmp` to return control to a predefined point
+ * (`setjmp_buffer`) in the calling function, allowing for C++ exception-like
+ * error recovery within the libjpeg context.
+ *
+ * @param cinfo Pointer to the common JPEG object, which contains error manager info.
+ */
 METHODDEF(void)
 my_error_exit(j_common_ptr cinfo) {
     // cinfo->err really points to a CustomErrorMgr struct, so coerce pointer
@@ -17,65 +39,136 @@ my_error_exit(j_common_ptr cinfo) {
     longjmp(myerr->setjmp_buffer, 1);
 }
 
-// Custom destination manager routines
+// --- Custom Destination Manager for libjpeg ---
+
+/**
+ * @brief Initializes the custom JPEG destination manager.
+ *
+ * Called by libjpeg to prepare the output buffer for compressed data.
+ * Clears the destination `std::vector<uint8_t>` and sets up the temporary buffer.
+ *
+ * @param cinfo Pointer to the JPEG compression object.
+ */
 METHODDEF(void)
 init_destination(j_compress_ptr cinfo) {
     JpegMemoryDestination* dest = (JpegMemoryDestination*)cinfo->dest;
-    dest->buffer->clear(); // Clear the buffer at start
-    dest->pub.next_output_byte = dest->temp_buffer;
-    dest->pub.free_in_buffer = dest->buffer_size;
+    dest->buffer->clear(); // Clear the output vector at the start of compression
+    dest->pub.next_output_byte = dest->temp_buffer; // Set pointer to temporary buffer
+    dest->pub.free_in_buffer = dest->buffer_size; // Set available space in temporary buffer
 }
 
+/**
+ * @brief Handles a full output buffer in the custom JPEG destination manager.
+ *
+ * Called by libjpeg when the temporary output buffer is full. It appends
+ * the contents of the temporary buffer to the main `std::vector<uint8_t>`
+ * and resets the temporary buffer for further writing.
+ *
+ * @param cinfo Pointer to the JPEG compression object.
+ * @return Always TRUE to indicate success.
+ */
 METHODDEF(boolean)
 empty_output_buffer(j_compress_ptr cinfo) {
     JpegMemoryDestination* dest = (JpegMemoryDestination*)cinfo->dest;
-    // When the buffer is full, append it to the vector
+    // When the buffer is full, append its content to the main vector
     dest->buffer->insert(dest->buffer->end(), dest->temp_buffer, dest->temp_buffer + dest->buffer_size);
-    dest->pub.next_output_byte = dest->temp_buffer;
-    dest->pub.free_in_buffer = dest->buffer_size;
+    dest->pub.next_output_byte = dest->temp_buffer; // Reset pointer to temporary buffer
+    dest->pub.free_in_buffer = dest->buffer_size; // Reset available space
     return TRUE;
 }
 
+/**
+ * @brief Terminates the custom JPEG destination manager.
+ *
+ * Called by libjpeg at the end of compression. Copies any remaining data
+ * from the temporary buffer to the main `std::vector<uint8_t>`.
+ *
+ * @param cinfo Pointer to the JPEG compression object.
+ */
 METHODDEF(void)
 term_destination(j_compress_ptr cinfo) {
     JpegMemoryDestination* dest = (JpegMemoryDestination*)cinfo->dest;
-    // Copy any remaining data from the temp buffer to the vector
+    // Copy any remaining data from the temporary buffer to the vector
     size_t datacount = dest->buffer_size - dest->pub.free_in_buffer;
-    dest->buffer->insert(dest->buffer->end(), dest->temp_buffer, dest->temp_buffer + datacount);
+    if (datacount > 0) {
+        dest->buffer->insert(dest->buffer->end(), dest->temp_buffer, dest->temp_buffer + datacount);
+    }
 }
 
+/**
+ * @brief Sets up a custom memory destination manager for libjpeg.
+ *
+ * This function initializes libjpeg's destination manager to write compressed
+ * JPEG data into a `std::vector<uint8_t>` using a temporary buffer.
+ *
+ * @param cinfo Pointer to the JPEG compression object.
+ * @param buffer Pointer to the `std::vector<uint8_t>` where the compressed data will be stored.
+ * @param temp_buffer_size The size of the temporary buffer to use for output.
+ */
 GLOBAL(void)
 jpeg_mem_dest(j_compress_ptr cinfo, std::vector<uint8_t>* buffer, size_t temp_buffer_size) {
+    // Allocate JpegMemoryDestination structure if not already allocated
     if (cinfo->dest == nullptr) {
         cinfo->dest = (struct jpeg_destination_mgr *)(*cinfo->mem->alloc_small)((j_common_ptr)cinfo, JPOOL_PERMANENT, sizeof(JpegMemoryDestination));
     }
 
     JpegMemoryDestination* dest = (JpegMemoryDestination*)cinfo->dest;
-    dest->pub.init_destination = init_destination;
-    dest->pub.empty_output_buffer = empty_output_buffer;
-    dest->pub.term_destination = term_destination;
-    dest->buffer = buffer;
-    dest->buffer_size = temp_buffer_size;
+    dest->pub.init_destination = init_destination;     // Set initialization function
+    dest->pub.empty_output_buffer = empty_output_buffer; // Set function for full buffer handling
+    dest->pub.term_destination = term_destination;     // Set termination function
+    dest->buffer = buffer;                             // Store pointer to the user's vector
+    dest->buffer_size = temp_buffer_size;              // Store temporary buffer size
+    // Allocate the temporary buffer used by libjpeg
     dest->temp_buffer = (JOCTET *)(*cinfo->mem->alloc_small)((j_common_ptr)cinfo, JPOOL_PERMANENT, temp_buffer_size);
 }
 
 
+/**
+ * @brief Constructor for JpegCompressGuard.
+ *
+ * Initializes the libjpeg compression object and sets up custom error handling.
+ * Throws a `std::runtime_error` if an error occurs during libjpeg initialization.
+ */
 JpegCompressGuard::JpegCompressGuard() {
+    // Set up the normal JPEG error routines, then override error_exit.
     cinfo_.err = jpeg_std_error(&jerr_.pub);
     jerr_.pub.error_exit = my_error_exit;
 
+    // Establish the setjmp return point for error recovery.
     if (setjmp(jerr_.setjmp_buffer)) {
         // If we get here, the JPEG code has signaled an error.
+        LOG_ERROR("JPEG compression error during initialization.");
         throw std::runtime_error("JPEG compression error during initialization.");
     }
 
+    // Initialize the JPEG compression object.
     jpeg_create_compress(&cinfo_);
 }
 
+/**
+ * @brief Destructor for JpegCompressGuard.
+ *
+ * Releases resources associated with the libjpeg compression object.
+ */
 JpegCompressGuard::~JpegCompressGuard() {
     jpeg_destroy_compress(&cinfo_);
 }
 
+/**
+ * @brief Compresses raw pixel data into JPEG format.
+ *
+ * Takes raw pixel data, dimensions, quality, and color space, and compresses
+ * it into a JPEG byte stream stored in a `std::vector<uint8_t>`.
+ * Uses custom error handling to catch libjpeg errors.
+ *
+ * @param pixel_data Pointer to the raw pixel data (e.g., RGB or Grayscale).
+ * @param width The width of the image in pixels.
+ * @param height The height of the image in pixels.
+ * @param quality The JPEG compression quality (0-100).
+ * @param color_space The color space of the input pixel data (e.g., JCS_RGB, JCS_GRAYSCALE).
+ * @return A `std::vector<uint8_t>` containing the compressed JPEG data.
+ * @throws std::runtime_error if a JPEG compression error occurs.
+ */
 std::vector<uint8_t> JpegCompressGuard::compress_image(
     const uint8_t* pixel_data,
     int width,
@@ -85,30 +178,39 @@ std::vector<uint8_t> JpegCompressGuard::compress_image(
 ) {
     std::vector<uint8_t> compressed_data;
 
+    // Establish the setjmp return point for error recovery during compression.
     if (setjmp(jerr_.setjmp_buffer)) {
         // If we get here, the JPEG code has signaled an error.
+        LOG_ERROR("JPEG compression error during image compression.");
         throw std::runtime_error("JPEG compression error.");
     }
 
-    jpeg_mem_dest(&cinfo_, &compressed_data, 4096); // 4KB temp buffer
+    // Set up the custom memory destination manager to write into `compressed_data`.
+    // A 4KB temporary buffer is used internally by libjpeg.
+    jpeg_mem_dest(&cinfo_, &compressed_data, 4096);
 
+    // Configure image parameters for libjpeg.
     cinfo_.image_width = width;
     cinfo_.image_height = height;
-    cinfo_.input_components = (color_space == JCS_RGB || color_space == JCS_YCbCr) ? 3 : 1;
+    cinfo_.input_components = (color_space == JCS_RGB || color_space == JCS_YCbCr) ? 3 : 1; // 3 for color, 1 for grayscale
     cinfo_.in_color_space = color_space;
 
+    // Set default compression parameters and quality.
     jpeg_set_defaults(&cinfo_);
     jpeg_set_quality(&cinfo_, quality, TRUE); // TRUE = limit to baseline-JPEG values
 
+    // Start the compression process.
     jpeg_start_compress(&cinfo_, TRUE);
 
-    JSAMPROW row_pointer[1];
+    JSAMPROW row_pointer[1]; // Pointer to JSAMPLE row[s]
+    // Write scanlines one by one.
     while (cinfo_.next_scanline < cinfo_.image_height) {
         row_pointer[0] = (JSAMPROW)(pixel_data + cinfo_.next_scanline * width * cinfo_.input_components);
         jpeg_write_scanlines(&cinfo_, row_pointer, 1);
     }
 
+    // Finish the compression process.
     jpeg_finish_compress(&cinfo_);
 
     return compressed_data;
-}
+}
\ No newline at end of file
diff --git a/src/jpeg_wrapper.h b/src/jpeg_wrapper.h
index b5d7c66..2b367f9 100644
--- a/src/jpeg_wrapper.h
+++ b/src/jpeg_wrapper.h
@@ -1,34 +1,96 @@
+/**
+ * @file jpeg_wrapper.h
+ * @brief Provides declarations for a C++ wrapper around libjpeg-turbo for JPEG compression.
+ *
+ * This header defines the necessary structures and a class to facilitate
+ * robust JPEG compression from raw pixel data into memory, integrating custom
+ * error handling and a custom destination manager for `std::vector<uint8_t>` output.
+ */
+
 #ifndef JPEG_WRAPPER_H
 #define JPEG_WRAPPER_H
 
 #include <vector>
-#include <memory>
+#include <memory>   // For std::unique_ptr
 #include <string>
 #include <stdexcept>
-#include <cstdio> // For FILE*
+#include <cstdio> // For FILE* (used by libjpeg internally)
+
+#include <setjmp.h>  // Required for jmp_buf, setjmp, longjmp for libjpeg error handling
+#include <jpeglib.h> // Include libjpeg header for core types and functions
 
-#include <setjmp.h> // For jmp_buf, setjmp, longjmp
-#include <jpeglib.h> // Include libjpeg header
+// --- Custom Destination Manager for libjpeg ---
 
-// Custom destination manager for libjpeg
+/**
+ * @brief Custom structure for managing libjpeg output to a `std::vector<uint8_t>`.
+ *
+ * This structure extends libjpeg's `jpeg_destination_mgr` to redirect compressed
+ * JPEG data into a dynamically growing `std::vector<uint8_t>`, using an
+ * intermediate temporary buffer.
+ */
 struct JpegMemoryDestination {
-    struct jpeg_destination_mgr pub; // public fields
-    std::vector<uint8_t>* buffer;   // target buffer
-    size_t buffer_size;             // current buffer size
-    JOCTET* temp_buffer;            // temp buffer for libjpeg
+    struct jpeg_destination_mgr pub; ///< Public fields of the standard destination manager.
+    std::vector<uint8_t>* buffer;   ///< Pointer to the `std::vector<uint8_t>` where compressed data will be stored.
+    size_t buffer_size;             ///< Size of the temporary buffer.
+    JOCTET* temp_buffer;            ///< Temporary buffer used by libjpeg for output.
 };
 
-// Libjpeg error handling (simplified)
+// --- Custom Error Handling for libjpeg ---
+
+/**
+ * @brief Custom error manager structure for libjpeg.
+ *
+ * This structure embeds a `jmp_buf` to allow libjpeg's error handler to
+ * perform a non-local jump back to a safe point in the calling C++ code,
+ * effectively converting a C-style error into a C++ exception-like behavior.
+ */
 struct CustomErrorMgr {
-    struct jpeg_error_mgr pub; // public fields
-    jmp_buf setjmp_buffer;     // for return to caller
+    struct jpeg_error_mgr pub; ///< Public fields of the standard error manager.
+    jmp_buf setjmp_buffer;     ///< Jump buffer for non-local jumps back to the caller.
 };
 
+/**
+ * @brief A RAII (Resource Acquisition Is Initialization) wrapper for libjpeg-turbo compression.
+ *
+ * This class handles the initialization and cleanup of libjpeg's compression
+ * objects (`jpeg_compress_struct`) and provides a convenient method for
+ * compressing raw pixel data into JPEG format with custom error handling.
+ */
 class JpegCompressGuard {
 public:
+    /**
+     * @brief Constructor for JpegCompressGuard.
+     *
+     * Initializes the libjpeg compression object and sets up a custom
+     * error handler using `setjmp` for robust error recovery.
+     *
+     * @throws std::runtime_error if libjpeg initialization fails.
+     */
     JpegCompressGuard();
+
+    /**
+     * @brief Destructor for JpegCompressGuard.
+     *
+     * Releases all resources associated with the libjpeg compression object
+     * by calling `jpeg_destroy_compress`.
+     */
     ~JpegCompressGuard();
 
+    /**
+     * @brief Compresses raw pixel data into JPEG format.
+     *
+     * Takes raw image data, its dimensions, a quality setting, and the input
+     * color space, then compresses it into a JPEG byte stream. The compressed
+     * data is returned as a `std::vector<uint8_t>`.
+     *
+     * @param pixel_data Pointer to the raw pixel data buffer.
+     * @param width The width of the image in pixels.
+     * @param height The height of the image in pixels.
+     * @param quality The JPEG compression quality (0-100), where 100 is best quality.
+     * @param color_space The color space of the input pixel data (e.g., JCS_RGB, JCS_GRAYSCALE).
+     * @return A `std::vector<uint8_t>` containing the compressed JPEG data.
+     * @throws std::runtime_error if a JPEG compression error occurs during the process.
+     */
     std::vector<uint8_t> compress_image(
         const uint8_t* pixel_data,
         int width,
@@ -38,8 +100,8 @@ public:
     );
 
 private:
-    jpeg_compress_struct cinfo_;
-    CustomErrorMgr jerr_; // Use CustomErrorMgr here
+    struct jpeg_compress_struct cinfo_; ///< The libjpeg compression object.
+    CustomErrorMgr jerr_;               ///< Custom error manager for libjpeg.
 };
 
-#endif // JPEG_WRAPPER_H
+#endif // JPEG_WRAPPER_H
\ No newline at end of file
diff --git a/src/main.cpp b/src/main.cpp
index bce50e1..45a0b6e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -1,3 +1,15 @@
+/**
+ * @file main.cpp
+ * @brief Main entry point for the CoralEdgeTpu Detector application.
+ *
+ * This application initializes and manages various modules for a real-time object
+ * detection pipeline on a Raspberry Pi with a Coral Edge TPU. It handles camera
+ * capture for inference and MJPEG streaming, runs TensorFlow Lite inference,
+ * sends detection results via UDP, and provides an MJPEG web server for preview.
+ * It also includes robust process supervision for the rpicam-vid camera streams
+ * and graceful shutdown handling.
+ */
+
 #include <iostream>
 #include <vector>
 #include <memory>
@@ -6,32 +18,51 @@
 #include <atomic>
 #include <fstream>
 #include <filesystem>
+#include <stdexcept>
+#include <chrono> // Required for std::chrono::seconds
 
+#include "pipeline_structs.h"
 #include "camera_capture.h"
+#include "mjpeg_capture.h"
 #include "inference.h"
 #include "mjpeg_server.h"
 #include "udp_sender.h"
-#include "jpeg_wrapper.h"
 #include "util_logging.h"
-#include "output_processor.h"
 
-// Global atomic flag for shutdown
+/// Global atomic flag to signal application shutdown.
 std::atomic<bool> shutdown_requested(false);
 
-// Signal handler
+/**
+ * @brief Signal handler for graceful application shutdown.
+ *
+ * Catches SIGINT (Ctrl+C) and SIGTERM signals, sets the shutdown_requested flag,
+ * and logs the initiation of the cleanup process.
+ *
+ * @param signal The signal number received.
+ */
 void signal_handler(int signal) {
     if (signal == SIGINT || signal == SIGTERM) {
-        std::cout << "Shutdown requested." << std::endl;
-        shutdown_requested = true;
+        if (!shutdown_requested.exchange(true)) {
+             LOG_INFO("Shutdown requested, initiating cleanup...");
+        }
     }
 }
 
-// Function to load labels from a file
+/**
+ * @brief Loads labels from a specified text file.
+ *
+ * Reads each line from the file into a vector of strings, where each string
+ * represents a class label. Logs an error if the file cannot be opened.
+ *
+ * @param path The filesystem path to the labels file.
+ * @return A vector of strings containing the loaded labels. Returns an empty
+ *         vector if the file is not found or is empty.
+ */
 std::vector<std::string> load_labels(const std::string& path) {
     std::vector<std::string> labels;
     std::ifstream file(path);
     if (!file.is_open()) {
-        std::cerr << "Failed to open labels file: " << path << std::endl;
+        LOG_ERROR("Failed to open labels file: " + path);
         return labels;
     }
     std::string line;
@@ -41,100 +72,126 @@ std::vector<std::string> load_labels(const std::string& path) {
     return labels;
 }
 
-
+/**
+ * @brief Main function of the CoralEdgeTpu Detector application.
+ *
+ * Sets up signal handlers, initializes the logger, defines application
+ * configurations (model path, camera streams, network settings),
+ * initializes various pipeline modules (camera capture, inference engine,
+ * UDP sender, MJPEG server), starts them, enters a main loop that waits
+ * for a shutdown signal, and then gracefully shuts down all modules.
+ *
+ * @param argc The number of command-line arguments.
+ * @param argv An array of command-line argument strings.
+ * @return 0 on successful execution, 1 on initialization or startup failure.
+ */
 int main(int argc, char** argv) {
-    // Set up signal handler for graceful shutdown
+    // Register signal handlers for graceful shutdown on SIGINT or SIGTERM
     std::signal(SIGINT, signal_handler);
     std::signal(SIGTERM, signal_handler);
 
-    // Initialize Logger
+    // Initialize the logger singleton
     Logger& logger = Logger::getInstance();
     LOG_INFO("CoralEdgeTpu Detector Starting...");
 
-    // Hardcoded configuration
+    // --- Application Configuration ---
     const std::string model_path = "/home/pi/CoralEdgeTpu/ssd_mobilenet_v2_coco_quant_postprocess_edgetpu.tflite";
     const std::string labels_path = "/home/pi/CoralEdgeTpu/coco_labels.txt";
-    const unsigned int camera_width = 640;
-    const unsigned int camera_height = 480;
+    
+    // MJPEG Stream Configuration
+    const unsigned int mjpeg_width = 640;
+    const unsigned int mjpeg_height = 480;
+    const unsigned int mjpeg_fps = 15;
     const int http_port = 8080;
+
+    // UDP Sender Configuration
     const std::string udp_target_ip = "127.0.0.1";
     const int udp_target_port = 9000;
 
-    LOG_INFO("Configuration:");
-    LOG_INFO("  Model Path: " + model_path);
-    LOG_INFO("  Labels Path: " + labels_path);
-    LOG_INFO("  Camera Mode: " + std::to_string(camera_width) + "x" + std::to_string(camera_height));
-    LOG_INFO("  HTTP Port: " + std::to_string(http_port));
-    LOG_INFO("  UDP Target: " + udp_target_ip + ":" + std::to_string(udp_target_port));
+    // Watchdog timeout for camera streams (5 seconds of inactivity triggers a restart)
+    const std::chrono::seconds camera_watchdog_timeout = std::chrono::seconds(5);
+
+    // --- Thread-Safe Queues for Inter-Module Communication ---
+    // Queue for raw image data from camera capture to inference engine
+    ImageQueue camera_to_inference_queue;
+    // Queue for detection results from inference engine to UDP sender
+    UdpQueue inference_to_udp_queue;
+    // Queue for MJPEG frames from capture to web server
+    MjpegQueue mjpeg_capture_to_server_queue;
 
-    // Load labels
+    // --- Module Initialization ---
+    // Verify existence of model and labels files
+    if (!std::filesystem::exists(model_path)) {
+        LOG_ERROR("Model file not found: " + model_path);
+        return 1;
+    }
     std::vector<std::string> labels = load_labels(labels_path);
     if (labels.empty()) {
-        LOG_ERROR("Failed to load labels from: " + labels_path);
+        LOG_ERROR("Labels file not found or is empty: " + labels_path);
         return 1;
     }
 
-    // Check if model exists
-    if (!std::filesystem::exists(model_path)) {
-        LOG_ERROR("Model file not found: " + model_path);
-        std::cerr << "ERROR: Model file not found. Please place your .tflite model at '"
-                  << model_path << "'" << std::endl;
+    // Initialize the Inference Engine
+    std::unique_ptr<InferenceEngine> inference_engine;
+    try {
+        inference_engine = std::make_unique<InferenceEngine>(model_path, camera_to_inference_queue, inference_to_udp_queue, 2);
+    } catch (const std::runtime_error& e) {
+        LOG_ERROR("Failed to initialize Inference Engine: " + std::string(e.what()));
         return 1;
     }
+    
+    // Get inference input dimensions from the loaded model
+    const unsigned int inference_width = inference_engine->get_input_width();
+    const unsigned int inference_height = inference_engine->get_input_height();
+
+    // Log the current application configuration
+    LOG_INFO("--- Configuration ---");
+    LOG_INFO("  Inference Input: " + std::to_string(inference_width) + "x" + std::to_string(inference_height));
+    LOG_INFO("  MJPEG Stream: " + std::to_string(mjpeg_width) + "x" + std::to_string(mjpeg_height) + "@" + std::to_string(mjpeg_fps) + "fps");
+    LOG_INFO("  HTTP Port: " + std::to_string(http_port));
+    LOG_INFO("  UDP Target: " + udp_target_ip + ":" + std::to_string(udp_target_port));
+    LOG_INFO("---------------------");
 
-    // --- Create shared queues ---
-    ThreadSafeQueue camera_to_inference_queue;
-    DetectionQueue inference_to_output_processor_queue; // Detections for output processing
-    UdpQueue inference_to_udp_queue; // For sending raw detections
-    MjpegQueue mjpeg_output_queue; // For MJPEG server
-
-    // --- Initialize Modules ---
-    CameraCapture camera_capture(camera_width, camera_height, camera_to_inference_queue);
-    InferenceEngine inference_engine(model_path, camera_to_inference_queue, inference_to_output_processor_queue, 2); // 2 inference threads
-    OutputProcessor output_processor(inference_to_output_processor_queue, mjpeg_output_queue, labels);
-    MjpegServer mjpeg_server(http_port, mjpeg_output_queue);
-    UdpSender udp_sender(udp_target_ip, udp_target_port, inference_to_udp_queue);
+    // Initialize CameraCapture modules
+    // Dedicated BGR stream for TensorFlow Lite inference
+    CameraCapture inference_camera(inference_width, inference_height, camera_to_inference_queue, camera_watchdog_timeout);
+    // Dedicated MJPEG stream for web preview
+    MjpegCapture mjpeg_camera(mjpeg_width, mjpeg_height, mjpeg_fps, mjpeg_capture_to_server_queue, camera_watchdog_timeout);
 
-    // --- Start Modules ---
-    bool success = true;
-    if (success) {
-        success = camera_capture.start();
-        if (!success) LOG_ERROR("Failed to start camera capture.");
-    }
-    if (success) {
-        success = inference_engine.start();
-        if (!success) LOG_ERROR("Failed to start inference engine.");
-    }
-    if (success) {
-        success = output_processor.start();
-        if (!success) LOG_ERROR("Failed to start output processor.");
-    }
-    if (success) {
-        success = mjpeg_server.start();
-        if (!success) LOG_ERROR("Failed to start MJPEG server.");
-    }
-    if (success) {
-        success = udp_sender.start();
-        if (!success) LOG_ERROR("Failed to start UDP sender.");
+    // Initialize UDP Sender and MJPEG Server modules
+    UdpSender udp_sender(udp_target_ip, udp_target_port, inference_to_udp_queue);
+    MjpegServer mjpeg_server(http_port, mjpeg_capture_to_server_queue);
+
+    // --- Start all modules ---
+    if (!inference_camera.start() || !mjpeg_camera.start() || !inference_engine->start() || !udp_sender.start() || !mjpeg_server.start()) {
+        LOG_ERROR("Failed to start one or more modules. Shutting down.");
+        // Stop all modules in reverse order to ensure proper cleanup, even if some failed to start.
+        mjpeg_server.stop();
+        udp_sender.stop();
+        inference_engine->stop();
+        mjpeg_camera.stop();
+        inference_camera.stop();
+        logger.stop_writer_thread(); // Stop logging thread last
+        return 1;
     }
 
-    // Main application loop
-    if (success) {
-        while (!shutdown_requested) {
-            std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Sleep to reduce CPU usage
-        }
+    LOG_INFO("Application started successfully. Waiting for shutdown signal (Ctrl+C).");
+    // Main application loop: waits for the shutdown signal
+    while (!shutdown_requested) {
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
     }
 
-    // --- Shutdown Modules (in reverse order of start-up) ---
-    LOG_INFO("Shutting down application...");
-    udp_sender.stop();
+    // --- Shutdown Modules ---
+    LOG_INFO("Shutting down application modules...");
+    // Stop all modules gracefully in a defined order
     mjpeg_server.stop();
-    output_processor.stop();
-    inference_engine.stop();
-    camera_capture.stop();
-    logger.stop_writer_thread(); // Stop logging thread last
-
+    udp_sender.stop();
+    inference_engine->stop();
+    mjpeg_camera.stop();
+    inference_camera.stop();
+    
     LOG_INFO("CoralEdgeTpu Detector Exiting.");
+    logger.stop_writer_thread(); // Stop logging thread last
 
     return 0;
 }
diff --git a/src/mjpeg_server.cpp b/src/mjpeg_server.cpp
index eff4794..3421b46 100644
--- a/src/mjpeg_server.cpp
+++ b/src/mjpeg_server.cpp
@@ -1,159 +1,237 @@
+/**
+ * @file mjpeg_server.cpp
+ * @brief Implements the MjpegServer class for streaming MJPEG video over HTTP.
+ *
+ * This module provides the concrete implementation for a simple HTTP server
+ * that serves MJPEG video frames. It handles socket creation, binding, listening,
+ * client connections, and sending multipart/x-mixed-replace responses with
+ * JPEG frames retrieved from a thread-safe queue.
+ */
+
 #include "mjpeg_server.h"
-#include <iostream>
+#include "util_logging.h" // For LOG_INFO, LOG_ERROR
+#include <iostream>       // For std::cerr (temporarily before full LOG_ERROR conversion)
 #include <string>
 #include <vector>
 #include <thread>
 #include <atomic>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <unistd.h>
-#include <sstream>
-#include <iomanip> // For std::hex, std::setfill, std::setw
-
-// Boundary string for MJPEG stream
+#include <sys/socket.h>   // For socket, bind, listen, accept, send, recv
+#include <netinet/in.h>   // For sockaddr_in, INADDR_ANY
+#include <unistd.h>       // For close
+#include <sstream>        // For std::ostringstream
+#include <iomanip>        // For std::hex, std::setfill, std::setw
+#include <cstring>        // For strerror
+
+// Boundary string for MJPEG multipart stream.
+// This string separates individual JPEG frames within the HTTP response.
 const std::string MJPEG_BOUNDARY = "opencv_boundary";
 
+/**
+ * @brief Constructor for MjpegServer.
+ *
+ * Initializes the server with the specified listening port and a reference
+ * to the queue from which MJPEG frames will be obtained.
+ *
+ * @param port The TCP port number on which the server will listen.
+ * @param input_queue Reference to the thread-safe MjpegQueue providing MJPEG frames.
+ */
 MjpegServer::MjpegServer(int port, MjpegQueue& input_queue)
     : port_(port), input_queue_(input_queue) {}
 
+/**
+ * @brief Destructor for MjpegServer.
+ *
+ * Ensures the server is stopped and its resources are properly cleaned up.
+ */
 MjpegServer::~MjpegServer() {
-    stop();
+    stop(); // Call stop to ensure graceful shutdown and thread joining.
 }
 
+/**
+ * @brief Starts the MJPEG server.
+ *
+ * Creates a TCP socket, binds it to the specified port, and starts listening
+ * for incoming client connections. Launches a dedicated `server_thread_func`
+ * to handle client connections asynchronously.
+ *
+ * @return True if the server started successfully, false otherwise.
+ */
 bool MjpegServer::start() {
     if (running_) {
-        std::cerr << "MjpegServer is already running." << std::endl;
+        LOG_ERROR("MjpegServer is already running.");
         return false;
     }
 
+    // Create a TCP socket.
     server_sock_ = socket(AF_INET, SOCK_STREAM, 0);
     if (server_sock_ < 0) {
-        std::cerr << "Failed to create server socket." << std::endl;
+        LOG_ERROR("Failed to create server socket: " + std::string(strerror(errno)));
         return false;
     }
 
+    // Set socket option to reuse address, preventing "Address already in use" errors.
     int optval = 1;
-    setsockopt(server_sock_, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
+    if (setsockopt(server_sock_, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
+        LOG_ERROR("Failed to set SO_REUSEADDR option on server socket: " + std::string(strerror(errno)));
+        close(server_sock_);
+        return false;
+    }
 
+    // Configure server address structure.
     sockaddr_in server_addr{};
-    server_addr.sin_family = AF_INET;
-    server_addr.sin_addr.s_addr = INADDR_ANY;
-    server_addr.sin_port = htons(port_);
+    server_addr.sin_family = AF_INET;           // IPv4
+    server_addr.sin_addr.s_addr = INADDR_ANY;   // Listen on all available network interfaces.
+    server_addr.sin_port = htons(port_);        // Convert port to network byte order.
 
+    // Bind the socket to the specified port and address.
     if (bind(server_sock_, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
-        std::cerr << "Failed to bind server socket to port " << port_ << std::endl;
+        LOG_ERROR("Failed to bind server socket to port " + std::to_string(port_) + ": " + std::string(strerror(errno)));
         close(server_sock_);
         return false;
     }
 
-    if (listen(server_sock_, 5) < 0) { // Max 5 pending connections
-        std::cerr << "Failed to listen on server socket." << std::endl;
+    // Start listening for incoming connections. Max 5 pending connections in queue.
+    if (listen(server_sock_, 5) < 0) {
+        LOG_ERROR("Failed to listen on server socket: " + std::string(strerror(errno)));
         close(server_sock_);
         return false;
     }
 
     running_ = true;
-    input_queue_.set_running(true);
+    input_queue_.set_running(true); // Signal input queue to be active.
     server_thread_ = std::thread(&MjpegServer::server_thread_func, this);
-    std::cout << "MJPEG server started on port " << port_ << std::endl;
+    LOG_INFO("MJPEG server started on port " + std::to_string(port_));
     return true;
 }
 
+/**
+ * @brief Stops the MJPEG server.
+ *
+ * Signals the server thread to terminate, gracefully shuts down the server socket
+ * to unblock any `accept()` calls, closes the socket, and joins the server thread.
+ */
 void MjpegServer::stop() {
-    if (!running_) {
-        return;
+    if (!running_.exchange(false)) { // Atomically set to false and check previous value.
+        return; // Already stopped.
     }
-    running_ = false;
-    input_queue_.set_running(false);
+    LOG_INFO("Stopping MJPEG server...");
+    input_queue_.set_running(false); // Signal input queue to stop.
 
+    // Shut down and close the server socket to unblock accept() in the server_thread_func.
     if (server_sock_ != -1) {
-        // Shut down the socket to unblock accept()
-        shutdown(server_sock_, SHUT_RDWR);
+        shutdown(server_sock_, SHUT_RDWR); // Stop all I/O on the socket.
         close(server_sock_);
         server_sock_ = -1;
     }
+    // Wait for the server thread to finish its execution.
     if (server_thread_.joinable()) {
         server_thread_.join();
     }
-    std::cout << "MJPEG server stopped." << std::endl;
+    LOG_INFO("MJPEG server stopped.");
 }
 
+/**
+ * @brief The main loop for the MJPEG server thread.
+ *
+ * This function continuously accepts new client connections. For each accepted
+ * client, it detaches a new thread to handle the client's request, allowing
+ * the server to serve multiple clients concurrently.
+ */
 void MjpegServer::server_thread_func() {
     while (running_) {
-        sockaddr_in client_addr{};
+        sockaddr_in client_addr{}; // Structure to hold client address information.
         socklen_t client_addr_len = sizeof(client_addr);
+        // Accept a new client connection. This call blocks until a client connects or the socket is shut down.
         int client_sock = accept(server_sock_, (struct sockaddr*)&client_addr, &client_addr_len);
 
         if (client_sock < 0) {
-            if (running_) { // Only report error if we're still running
-                std::cerr << "Failed to accept client connection." << std::endl;
+            if (running_) { // Only report an error if the server is still expected to be running.
+                LOG_ERROR("Failed to accept client connection: " + std::string(strerror(errno)));
             }
-            continue;
+            continue; // Continue to the next iteration, waiting for another client.
         }
+        // Launch a new thread to handle the client connection. Detach it so the server doesn't wait for it.
         std::thread client_handler(&MjpegServer::handle_client, this, client_sock);
-        client_handler.detach(); // Detach to allow handling multiple clients
+        client_handler.detach();
     }
 }
 
+/**
+ * @brief Handles an individual client connection for MJPEG streaming.
+ *
+ * This function reads the client's HTTP request, sends appropriate MJPEG stream
+ * headers, and then continuously retrieves the latest MJPEG frames from the
+ * input queue, sending them to the connected client as a multipart/x-mixed-replace
+ * HTTP response.
+ *
+ * @param client_sock The socket file descriptor for the connected client.
+ */
 void MjpegServer::handle_client(int client_sock) {
-    char buffer[2048];
-    ssize_t bytes_received = recv(client_sock, buffer, sizeof(buffer) - 1, 0);
+    char buffer[2048]; // Buffer to read incoming HTTP request.
+    ssize_t bytes_received = recv(client_sock, buffer, sizeof(buffer) - 1, 0); // Read client request.
     if (bytes_received <= 0) {
+        LOG_WARNING("Client disconnected or error receiving request.");
         close(client_sock);
         return;
     }
-    buffer[bytes_received] = '\0';
-    // std::cout << "Received request:\n" << buffer << std::endl;
+    buffer[bytes_received] = '\0'; // Null-terminate the received data.
+    // LOG_INFO("Received request from client:\n" + std::string(buffer)); // For debugging requests.
 
-    // We expect a GET request for /, typically
+    // Basic request parsing: check for GET / or GET /stream
     if (std::string(buffer).rfind("GET / ", 0) != 0 && std::string(buffer).rfind("GET /stream ", 0) != 0) {
-        // Simple 404 for other requests
+        // For any other request, send a simple 404 Not Found response.
         std::string response = "HTTP/1.0 404 Not Found\r\nContent-Length: 13\r\n\r\n404 Not Found";
         send(client_sock, response.c_str(), response.length(), 0);
         close(client_sock);
         return;
     }
 
-    // Send MJPEG stream headers
+    // Send MJPEG stream HTTP headers for multipart/x-mixed-replace.
     std::ostringstream header_ss;
     header_ss << "HTTP/1.0 200 OK\r\n";
-    header_ss << "Cache-Control: no-cache\r\n";
-    header_ss << "Pragma: no-cache\r\n";
-    header_ss << "Connection: close\r\n";
-    header_ss << "Content-Type: multipart/x-mixed-replace; boundary=" << MJPEG_BOUNDARY << "\r\n";
-    header_ss << "\r\n";
+    header_ss << "Cache-Control: no-cache\r\n";       // Prevent caching.
+    header_ss << "Pragma: no-cache\r\n";             // For older HTTP/1.0 clients.
+    header_ss << "Connection: close\r\n";            // Connection will be closed by server.
+    header_ss << "Content-Type: multipart/x-mixed-replace; boundary=" << MJPEG_BOUNDARY << "\r\n"; // Main content type.
+    header_ss << "\r\n"; // End of headers.
     std::string headers = header_ss.str();
-    send(client_sock, headers.c_str(), headers.length(), 0);
+    if (send(client_sock, headers.c_str(), headers.length(), 0) < 0) {
+        LOG_ERROR("Failed to send MJPEG stream headers to client: " + std::string(strerror(errno)));
+        close(client_sock);
+        return;
+    }
 
     ImageFrame frame;
-    while (running_ && input_queue_.peek_latest(frame)) { // Peek the latest frame
+    // Loop to continuously send MJPEG frames while the server is running and frames are available.
+    while (running_ && input_queue_.peek_latest(frame)) { // Peek the latest frame from the queue.
         std::ostringstream content_ss;
-        content_ss << "--" << MJPEG_BOUNDARY << "\r\n";
-        content_ss << "Content-Type: image/jpeg\r\n";
-        content_ss << "Content-Length: " << frame.jpeg_data.size() << "\r\n";
-        content_ss << "\r\n";
+        content_ss << "--" << MJPEG_BOUNDARY << "\r\n";        // Start of a new part with boundary.
+        content_ss << "Content-Type: image/jpeg\r\n";          // Content type of the part.
+        content_ss << "Content-Length: " << frame.jpeg_data.size() << "\r\n"; // Size of the JPEG data.
+        content_ss << "\r\n"; // End of content headers for this part.
         std::string content_headers = content_ss.str();
 
-        // Send content headers
+        // Send content headers for the current JPEG frame.
         if (send(client_sock, content_headers.c_str(), content_headers.length(), 0) < 0) {
-            std::cerr << "Failed to send content headers to client." << std::endl;
-            break;
+            LOG_ERROR("Failed to send content headers for MJPEG frame to client: " + std::string(strerror(errno)));
+            break; // Exit loop if send fails.
         }
 
-        // Send JPEG data
+        // Send the actual JPEG data.
         if (send(client_sock, (const char*)frame.jpeg_data.data(), frame.jpeg_data.size(), 0) < 0) {
-            std::cerr << "Failed to send JPEG data to client." << std::endl;
-            break;
+            LOG_ERROR("Failed to send JPEG data to client: " + std::string(strerror(errno)));
+            break; // Exit loop if send fails.
         }
 
-        // Send boundary
+        // Send the boundary delimiter after the JPEG data.
         if (send(client_sock, "\r\n", 2, 0) < 0) {
-            std::cerr << "Failed to send boundary to client." << std::endl;
-            break;
+            LOG_ERROR("Failed to send boundary delimiter to client: " + std::string(strerror(errno)));
+            break; // Exit loop if send fails.
         }
-        std::this_thread::sleep_for(std::chrono::milliseconds(30)); // Avoid burning CPU, simulate frame rate
+        // Small delay to control frame rate and prevent excessive CPU usage.
+        std::this_thread::sleep_for(std::chrono::milliseconds(30));
     }
 
-    close(client_sock);
-    // std::cout << "Client disconnected." << std::endl;
-}
+    close(client_sock); // Close client socket after stream ends or error.
+    // LOG_INFO("Client disconnected."); // For debugging client connections.
+}
\ No newline at end of file
diff --git a/src/mjpeg_server.h b/src/mjpeg_server.h
index 2137fbe..31a8a83 100644
--- a/src/mjpeg_server.h
+++ b/src/mjpeg_server.h
@@ -1,3 +1,13 @@
+/**
+ * @file mjpeg_server.h
+ * @brief Defines the MjpegServer class for streaming MJPEG video over HTTP.
+ *
+ * This class implements a simple HTTP server that serves MJPEG video frames
+ * to connected clients. It retrieves MJPEG frames from a thread-safe queue
+ * populated by a camera capture module and streams them to web browsers or
+ * other compatible clients.
+ */
+
 #ifndef MJPEG_SERVER_H
 #define MJPEG_SERVER_H
 
@@ -5,87 +15,87 @@
 #include <vector>
 #include <thread>
 #include <atomic>
-#include <mutex>
-#include <condition_variable>
-#include <queue>
-
-// Forward declare for ImageFrame (if needed, otherwise define directly)
-struct ImageFrame {
-    std::vector<uint8_t> jpeg_data;
-    size_t width;
-    size_t height;
-    // Add timestamp or other metadata if necessary
-};
-
-// Thread-safe queue for MJPEG frames
-class MjpegQueue {
-public:
-    void push(ImageFrame new_frame) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        // Keep only the latest frame for MJPEG streaming
-        if (!queue_.empty()) {
-            queue_.pop();
-        }
-        queue_.push(std::move(new_frame));
-        cond_var_.notify_one();
-    }
-
-    bool pop(ImageFrame& frame) {
-        std::unique_lock<std::mutex> lock(mutex_);
-        // Wait for a new frame, but don't block indefinitely if stopping
-        cond_var_.wait(lock, [this]{ return !queue_.empty() || !running_; });
-        if (queue_.empty()) {
-            return false;
-        }
-        frame = std::move(queue_.front());
-        queue_.pop();
-        return true;
-    }
-
-    // Peeks at the latest frame without removing it
-    bool peek_latest(ImageFrame& frame) {
-        std::unique_lock<std::mutex> lock(mutex_);
-        cond_var_.wait(lock, [this]{ return !queue_.empty() || !running_; });
-        if (queue_.empty()) {
-            return false;
-        }
-        frame = queue_.back(); // Get the latest frame
-        return true;
-    }
-
-    void set_running(bool val) {
-        running_ = val;
-        if (!val) {
-            cond_var_.notify_all(); // Unblock any waiting threads
-        }
-    }
+#include <sys/socket.h> // For socket programming types
 
+#include "pipeline_structs.h" // Use the new central header
 
-private:
-    mutable std::mutex mutex_;
-    std::queue<ImageFrame> queue_;
-    std::condition_variable cond_var_;
-    std::atomic<bool> running_ = true;
-};
-
+/**
+ * @brief A simple HTTP server for streaming MJPEG video.
+ *
+ * The MjpegServer class creates a TCP/IP server that listens for incoming
+ * HTTP connections. Upon a client connection, it continuously reads MJPEG
+ * frames from an input queue and streams them as a multipart/x-mixed-replace
+ * HTTP response, suitable for displaying live video in web browsers.
+ */
 class MjpegServer {
 public:
+    /**
+     * @brief Constructor for MjpegServer.
+     *
+     * Initializes the MJPEG server with the specified port and a reference
+     * to the input queue from which MJPEG frames will be retrieved.
+     *
+     * @param port The TCP port number on which the server will listen.
+     * @param input_queue Reference to the thread-safe MjpegQueue providing MJPEG frames.
+     */
     MjpegServer(int port, MjpegQueue& input_queue);
+
+    /**
+     * @brief Destructor for MjpegServer.
+     *
+     * Ensures that the server thread is gracefully stopped and resources are released.
+     */
     ~MjpegServer();
 
+    /**
+     * @brief Starts the MJPEG server.
+     *
+     * Creates and launches the main server thread that listens for client connections.
+     *
+     * @return True if the server started successfully, false otherwise.
+     */
     bool start();
+
+    /**
+     * @brief Stops the MJPEG server.
+     *
+     * Signals the server thread to terminate, closes the server socket, and joins
+     * the server thread for a clean shutdown.
+     */
     void stop();
+
+    /**
+     * @brief Checks if the MJPEG server is currently running.
+     *
+     * @return True if the server is running, false otherwise.
+     */
     bool is_running() const { return running_; }
 
 private:
+    /**
+     * @brief The main loop for the MJPEG server thread.
+     *
+     * This function binds to the specified port, listens for incoming connections,
+     * accepts clients, and then detaches a new thread to handle each client.
+     */
     void server_thread_func();
+
+    /**
+     * @brief Handles an individual client connection for MJPEG streaming.
+     *
+     * This function sends the HTTP multipart header to the client and then
+     * continuously reads MJPEG frames from the input queue, sending each frame
+     * with its boundary delimiter to the connected client.
+     *
+     * @param client_sock The socket file descriptor for the connected client.
+     */
     void handle_client(int client_sock);
 
-    int port_;
-    MjpegQueue& input_queue_;
-    std::atomic<bool> running_ = false;
-    std::thread server_thread_;
-    int server_sock_ = -1;
+    int port_; ///< The TCP port number the server listens on.
+    MjpegQueue& input_queue_; ///< Reference to the queue from which MJPEG frames are retrieved.
+    std::atomic<bool> running_ = false; ///< Atomic flag to control the server's running state.
+    std::thread server_thread_; ///< The main thread running the server_thread_func.
+    int server_sock_ = -1; ///< The socket file descriptor for the listening server socket.
 };
 
-#endif // MJPEG_SERVER_H
+#endif // MJPEG_SERVER_H
\ No newline at end of file
diff --git a/src/output_processor.cpp b/src/output_processor.cpp
deleted file mode 100644
index 58bda91..0000000
--- a/src/output_processor.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-#include "output_processor.h"
-#include "camera_capture.h" // For ImageData
-#include <iostream>
-#include <vector>
-#include <algorithm> // For std::min, std::max
-
-// Function to draw a rectangle on a YUV420 image. This is a very basic implementation
-// that only draws on the Y (luminance) plane.
-void draw_rectangle_yuv420(std::vector<uint8_t>& yuv_data, size_t width, size_t height,
-                           int x1, int y1, int x2, int y2, uint8_t color_val_y) {
-    // Clamp coordinates to image boundaries
-    x1 = std::max(0, x1);
-    y1 = std::max(0, y1);
-    x2 = std::min((int)width - 1, x2);
-    y2 = std::min((int)height - 1, y2);
-
-    // Draw horizontal lines (top and bottom)
-    for (int x = x1; x <= x2; ++x) {
-        if (y1 >= 0 && y1 < height) yuv_data[y1 * width + x] = color_val_y;
-        if (y2 >= 0 && y2 < height) yuv_data[y2 * width + x] = color_val_y;
-    }
-
-    // Draw vertical lines (left and right)
-    for (int y = y1; y <= y2; ++y) {
-        if (x1 >= 0 && x1 < width) yuv_data[y * width + x1] = color_val_y;
-        if (x2 >= 0 && x2 < width) yuv_data[y * width + x2] = color_val_y;
-    }
-}
-
-OutputProcessor::OutputProcessor(DetectionQueue& input_detection_queue, MjpegQueue& output_mjpeg_queue, const std::vector<std::string>& labels)
-    : input_detection_queue_(input_detection_queue), output_mjpeg_queue_(output_mjpeg_queue), labels_(labels) {}
-
-OutputProcessor::~OutputProcessor() {
-    stop();
-}
-
-bool OutputProcessor::start() {
-    if (running_) {
-        std::cerr << "OutputProcessor is already running." << std::endl;
-        return false;
-    }
-    running_ = true;
-    input_detection_queue_.set_running(true); // Ensure detection queue is active
-    process_thread_ = std::thread(&OutputProcessor::process_thread_func, this);
-    std::cout << "OutputProcessor started." << std::endl;
-    return true;
-}
-
-void OutputProcessor::stop() {
-    if (!running_) {
-        return;
-    }
-    running_ = false;
-    input_detection_queue_.set_running(false); // Signal detection queue to stop
-    if (process_thread_.joinable()) {
-        process_thread_.join();
-    }
-    std::cout << "OutputProcessor stopped." << std::endl;
-}
-
-void OutputProcessor::process_thread_func() {
-    std::vector<DetectionResult> detections;
-    ImageData original_image; // This should ideally come from a queue from camera, but for now we assume we have it in main.cpp
-
-    while (running_) {
-        if (input_detection_queue_.pop(detections)) { // Blocking call
-            // For now, we'll create a dummy image based on expected dimensions
-            // In a real app, image data would be queued.
-            ImageData dummy_image;
-            dummy_image.width = 640; // Default width
-            dummy_image.height = 480; // Default height
-            dummy_image.data.resize(dummy_image.width * dummy_image.height * 3 / 2); // YUV420 size
-
-            std::vector<uint8_t> jpeg_data = draw_boxes_and_encode_jpeg(dummy_image, detections);
-            if (!jpeg_data.empty()) {
-                ImageFrame frame;
-                frame.jpeg_data = std::move(jpeg_data);
-                frame.width = dummy_image.width;
-                frame.height = dummy_image.height;
-                output_mjpeg_queue_.push(std::move(frame));
-            }
-        }
-    }
-}
-
-std::vector<uint8_t> OutputProcessor::draw_boxes_and_encode_jpeg(const ImageData& original_image, const std::vector<DetectionResult>& detections) {
-    std::vector<uint8_t> image_data_yuv = original_image.data; // Make a mutable copy
-
-    for (const auto& det : detections) {
-        // Convert normalized coordinates to pixel coordinates
-        int x1 = static_cast<int>(det.xmin);
-        int y1 = static_cast<int>(det.ymin);
-        int x2 = static_cast<int>(det.xmax);
-        int y2 = static_cast<int>(det.ymax);
-
-        // Draw a green box (arbitrary Y value for green)
-        draw_rectangle_yuv420(image_data_yuv, original_image.width, original_image.height,
-                              x1, y1, x2, y2, 100); // Y=100 for a medium gray/green
-
-        // TODO: Draw label text (e.g., labels_[det.class_id]) on the image
-        // For now, we just print the label to console.
-        if (det.class_id < labels_.size()) {
-            std::cout << "Detected: " << labels_[det.class_id] << std::endl;
-        }
-    }
-
-    // Compress the modified YUV image to JPEG
-    return jpeg_compressor_.compress_image(
-        image_data_yuv.data(),
-        original_image.width,
-        original_image.height,
-        75, // JPEG quality
-        JCS_YCbCr // Assuming YUV420 input maps to JCS_YCbCr
-    );
-}
\ No newline at end of file
diff --git a/src/output_processor.h b/src/output_processor.h
deleted file mode 100644
index 0d2976b..0000000
--- a/src/output_processor.h
+++ /dev/null
@@ -1,42 +0,0 @@
-#ifndef OUTPUT_PROCESSOR_H
-#define OUTPUT_PROCESSOR_H
-
-#include <vector>
-#include <string>
-#include <thread>
-#include <atomic>
-#include <mutex>
-#include <condition_variable>
-#include <queue>
-#include <chrono>
-
-#include "inference.h" // For DetectionQueue and DetectionResult
-#include "mjpeg_server.h" // For MjpegQueue and ImageFrame
-#include "jpeg_wrapper.h" // For JpegCompressGuard
-
-// Forward declare for ImageFrame (if needed, otherwise define directly)
-struct ImageData; // From camera_capture.h
-
-class OutputProcessor {
-public:
-    OutputProcessor(DetectionQueue& input_detection_queue, MjpegQueue& output_mjpeg_queue, const std::vector<std::string>& labels);
-    ~OutputProcessor();
-
-    bool start();
-    void stop();
-    bool is_running() const { return running_; }
-
-private:
-    void process_thread_func();
-    std::vector<uint8_t> draw_boxes_and_encode_jpeg(const ImageData& original_image, const std::vector<DetectionResult>& detections);
-
-    DetectionQueue& input_detection_queue_;
-    MjpegQueue& output_mjpeg_queue_;
-    const std::vector<std::string>& labels_; // Store labels
-
-    std::atomic<bool> running_ = false;
-    std::thread process_thread_;
-    JpegCompressGuard jpeg_compressor_;
-};
-
-#endif // OUTPUT_PROCESSOR_H
diff --git a/src/udp_sender.cpp b/src/udp_sender.cpp
index da05478..429361a 100644
--- a/src/udp_sender.cpp
+++ b/src/udp_sender.cpp
@@ -1,101 +1,167 @@
+/**
+ * @file udp_sender.cpp
+ * @brief Implements the UdpSender class for transmitting object detection results via UDP.
+ *
+ * This module provides the concrete implementation for establishing a UDP socket,
+ * serializing detection results into JSON format, and sending them to a
+ * configured network endpoint. It operates in a dedicated thread, consuming
+ * data from a thread-safe queue.
+ */
+
 #include "udp_sender.h"
-#include <iostream>
-#include <sys/socket.h>
-#include <arpa/inet.h>
-#include <unistd.h>
-#include <sstream>
+#include "util_logging.h" // For LOG_INFO, LOG_ERROR
+#include <iostream>       // For std::cerr (temporarily before full LOG_ERROR conversion)
+#include <sys/socket.h>   // For socket, sendto
+#include <arpa/inet.h>    // For inet_pton
+#include <unistd.h>       // For close
+#include <sstream>        // For std::ostringstream
 
+/**
+ * @brief Constructor for UdpSender.
+ *
+ * Initializes the UDP socket and configures the target server address structure.
+ *
+ * @param target_ip The IP address of the target UDP receiver.
+ * @param target_port The UDP port number of the target receiver.
+ * @param input_queue Reference to the thread-safe UdpQueue providing detection results.
+ */
 UdpSender::UdpSender(const std::string& target_ip, int target_port, UdpQueue& input_queue)
     : target_ip_(target_ip), target_port_(target_port), input_queue_(input_queue) {
 
+    // Create UDP socket.
     sockfd_ = socket(AF_INET, SOCK_DGRAM, 0);
     if (sockfd_ < 0) {
-        std::cerr << "Failed to create UDP socket." << std::endl;
-        // Handle error, e.g., throw exception
+        LOG_ERROR("Failed to create UDP socket.");
+        // In a real application, proper error handling (e.g., throwing an exception)
+        // would be necessary to prevent module startup if socket creation fails.
     }
 
-    server_addr_.sin_family = AF_INET;
-    server_addr_.sin_port = htons(target_port_);
+    // Configure server address structure.
+    server_addr_.sin_family = AF_INET; // IPv4
+    server_addr_.sin_port = htons(target_port_); // Convert port to network byte order
+    // Convert IP address from string to binary form.
     if (inet_pton(AF_INET, target_ip_.c_str(), &server_addr_.sin_addr) <= 0) {
-        std::cerr << "Invalid address/ Address not supported: " << target_ip_ << std::endl;
-        close(sockfd_);
-        sockfd_ = -1;
-        // Handle error
+        LOG_ERROR("Invalid address or address not supported: " + target_ip_);
+        if (sockfd_ != -1) {
+            close(sockfd_);
+            sockfd_ = -1; // Mark socket as invalid
+        }
     }
 }
 
+/**
+ * @brief Destructor for UdpSender.
+ *
+ * Ensures that the sender thread is gracefully stopped and closes the UDP socket.
+ */
 UdpSender::~UdpSender() {
-    stop();
+    stop(); // Ensure sender thread is stopped
     if (sockfd_ != -1) {
-        close(sockfd_);
+        close(sockfd_); // Close the socket
     }
 }
 
+/**
+ * @brief Starts the UDP sender.
+ *
+ * Launches the dedicated sender thread. Verifies that the UDP socket is valid
+ * before attempting to start.
+ *
+ * @return True if the sender started successfully, false otherwise.
+ */
 bool UdpSender::start() {
     if (running_) {
-        std::cerr << "UdpSender is already running." << std::endl;
+        LOG_ERROR("UdpSender is already running.");
         return false;
     }
     if (sockfd_ == -1) {
-        std::cerr << "UDP socket not initialized, cannot start sender." << std::endl;
+        LOG_ERROR("UDP socket not initialized or invalid, cannot start sender.");
         return false;
     }
 
     running_ = true;
-    input_queue_.set_running(true);
+    input_queue_.set_running(true); // Signal input queue to be active
     sender_thread_ = std::thread(&UdpSender::sender_thread_func, this);
-    std::cout << "UDP sender started for target: " << target_ip_ << ":" << target_port_ << std::endl;
+    LOG_INFO("UDP sender started for target: " + target_ip_ + ":" + std::to_string(target_port_));
     return true;
 }
 
+/**
+ * @brief Stops the UDP sender.
+ *
+ * Signals the sender thread to terminate and waits for it to finish. Also
+ * signals the input queue to stop.
+ */
 void UdpSender::stop() {
-    if (!running_) {
-        return;
+    if (!running_.exchange(false)) { // Atomically set to false and check previous value
+        return; // Already stopped
     }
-    running_ = false;
-    input_queue_.set_running(false);
+    LOG_INFO("Stopping UDP sender...");
+    input_queue_.set_running(false); // Signal input queue to stop
     if (sender_thread_.joinable()) {
-        sender_thread_.join();
+        sender_thread_.join(); // Wait for the sender thread to complete
     }
-    std::cout << "UDP sender stopped." << std::endl;
+    LOG_INFO("UDP sender stopped.");
 }
 
+/**
+ * @brief The main loop for the UDP sender thread.
+ *
+ * Continuously retrieves vectors of `DetectionResult` from the input queue,
+ * converts them to a JSON string, and transmits them via the UDP socket.
+ * The loop runs as long as the `running_` flag is true.
+ */
 void UdpSender::sender_thread_func() {
     std::vector<DetectionResult> results;
     while (running_) {
-        if (input_queue_.pop(results)) { // Blocking call
+        // Pop detection results from the queue. This call will block until data
+        // is available or the queue is signaled to stop.
+        if (input_queue_.pop(results)) {
+            // Convert the detection results to a JSON string.
             std::string json_data = detection_to_json(results);
             if (!json_data.empty()) {
+                // Send the JSON data via UDP.
                 ssize_t sent_bytes = sendto(sockfd_, json_data.c_str(), json_data.length(), 0,
                                             (const sockaddr*)&server_addr_, sizeof(server_addr_));
                 if (sent_bytes < 0) {
-                    std::cerr << "Failed to send UDP packet to " << target_ip_ << ":" << target_port_ << std::endl;
+                    LOG_ERROR("Failed to send UDP packet to " + target_ip_ + ":" + std::to_string(target_port_) + ": " + strerror(errno));
                 } else {
-                    // std::cout << "Sent " << sent_bytes << " bytes via UDP." << std::endl;
+                    // For debugging: LOG_INFO("Sent " + std::to_string(sent_bytes) + " bytes via UDP.");
                 }
             }
         }
     }
 }
 
+/**
+ * @brief Converts a vector of `DetectionResult` objects into a JSON string.
+ *
+ * The output JSON is an array of objects, where each object represents
+ * a single detection including its class ID, score, bounding box coordinates,
+ * and timestamp.
+ *
+ * @param results A constant reference to a vector of `DetectionResult` objects.
+ * @return A JSON formatted string representing the detection results.
+ */
 std::string UdpSender::detection_to_json(const std::vector<DetectionResult>& results) {
     std::ostringstream oss;
-    oss << "[";
+    oss << "["; // Start of JSON array
     for (size_t i = 0; i < results.size(); ++i) {
         const auto& res = results[i];
-        oss << "{";
-        oss << "{\"class_id\":" << res.class_id << ",";
+        oss << "{"; // Start of JSON object for a single detection
+        oss << "\"class_id\":" << res.class_id << ",";
         oss << "\"score\":" << res.score << ",";
         oss << "\"xmin\":" << res.xmin << ",";
         oss << "\"ymin\":" << res.ymin << ",";
         oss << "\"xmax\":" << res.xmax << ",";
         oss << "\"ymax\":" << res.ymax << ",";
+        // Convert high_resolution_clock time_point to milliseconds since epoch for JSON
         oss << "\"timestamp\":" << std::chrono::duration_cast<std::chrono::milliseconds>(res.timestamp.time_since_epoch()).count();
-        oss << "}";
+        oss << "}"; // End of JSON object for a single detection
         if (i < results.size() - 1) {
-            oss << ",";
+            oss << ","; // Add comma between objects
         }
     }
-    oss << "]";
+    oss << "]"; // End of JSON array
     return oss.str();
-}
+}
\ No newline at end of file
diff --git a/src/udp_sender.h b/src/udp_sender.h
index 633559a..f6f670c 100644
--- a/src/udp_sender.h
+++ b/src/udp_sender.h
@@ -1,3 +1,13 @@
+/**
+ * @file udp_sender.h
+ * @brief Defines the UdpSender class for sending object detection results via UDP.
+ *
+ * This class implements a UDP client that sends serialized object detection
+ * results to a specified IP address and port. It retrieves detection data
+ * from a thread-safe queue populated by the inference engine and converts
+ * them into a JSON format for transmission.
+ */
+
 #ifndef UDP_SENDER_H
 #define UDP_SENDER_H
 
@@ -5,67 +15,94 @@
 #include <vector>
 #include <thread>
 #include <atomic>
-#include <mutex>
-#include <condition_variable>
-#include <queue>
-#include <netinet/in.h> // For sockaddr_in
-
-#include "inference.h" // For DetectionResult
-
-// Thread-safe queue for detection results (to be sent via UDP)
-class UdpQueue {
-public:
-    void push(std::vector<DetectionResult> results) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        queue_.push(std::move(results));
-        cond_var_.notify_one();
-    }
+#include <netinet/in.h> // For sockaddr_in structure
 
-    bool pop(std::vector<DetectionResult>& results) {
-        std::unique_lock<std::mutex> lock(mutex_);
-        cond_var_.wait(lock, [this]{ return !queue_.empty() || !running_; });
-        if (queue_.empty()) {
-            return false;
-        }
-        results = std::move(queue_.front());
-        queue_.pop();
-        return true;
-    }
+#include "pipeline_structs.h" // Use the new central header
 
-    void set_running(bool val) {
-        running_ = val;
-        if (!val) {
-            cond_var_.notify_all(); // Unblock any waiting threads
-        }
-    }
-
-private:
-    mutable std::mutex mutex_;
-    std::queue<std::vector<DetectionResult>> queue_;
-    std::condition_variable cond_var_;
-    std::atomic<bool> running_ = true;
-};
+// Define the queue type for this module
+/// @brief Type alias for the specific UdpQueue used by UdpSender.
+using UdpQueue = ThreadSafeQueue<std::vector<DetectionResult>>;
 
+/**
+ * @brief Sends object detection results over UDP.
+ *
+ * The UdpSender class establishes a UDP connection to a target IP address and port.
+ * It runs a dedicated thread that continuously retrieves `std::vector<DetectionResult>`
+ * objects from an input queue, serializes them into a JSON string, and sends
+ * the JSON payload via UDP.
+ */
 class UdpSender {
 public:
+    /**
+     * @brief Constructor for UdpSender.
+     *
+     * Initializes the UDP sender with the target IP address and port, and a
+     * reference to the input queue from which detection results will be retrieved.
+     *
+     * @param target_ip The IP address of the target UDP receiver.
+     * @param target_port The UDP port number of the target receiver.
+     * @param input_queue Reference to the thread-safe UdpQueue providing detection results.
+     */
     UdpSender(const std::string& target_ip, int target_port, UdpQueue& input_queue);
+
+    /**
+     * @brief Destructor for UdpSender.
+     *
+     * Ensures that the sender thread is gracefully stopped and resources are released.
+     */
     ~UdpSender();
 
+    /**
+     * @brief Starts the UDP sender.
+     *
+     * Creates and launches the main sender thread that retrieves and transmits data.
+     *
+     * @return True if the sender started successfully, false otherwise.
+     */
     bool start();
+
+    /**
+     * @brief Stops the UDP sender.
+     *
+     * Signals the sender thread to terminate, closes the UDP socket, and joins
+     * the sender thread for a clean shutdown.
+     */
     void stop();
+
+    /**
+     * @brief Checks if the UDP sender is currently running.
+     *
+     * @return True if the sender is running, false otherwise.
+     */
     bool is_running() const { return running_; }
 
 private:
+    /**
+     * @brief The main loop for the UDP sender thread.
+     *
+     * This function continuously retrieves detection results from the input queue,
+     * converts them to a JSON string, and sends them to the configured UDP target.
+     */
     void sender_thread_func();
+
+    /**
+     * @brief Converts a vector of DetectionResult objects into a JSON string.
+     *
+     * The JSON format typically includes an array of objects, where each object
+     * represents a detection with its class ID, score, and bounding box coordinates.
+     *
+     * @param results A constant reference to a vector of DetectionResult objects.
+     * @return A JSON formatted string representing the detection results.
+     */
     std::string detection_to_json(const std::vector<DetectionResult>& results);
 
-    std::string target_ip_;
-    int target_port_;
-    UdpQueue& input_queue_;
-    std::atomic<bool> running_ = false;
-    std::thread sender_thread_;
-    int sockfd_ = -1;
-    sockaddr_in server_addr_;
+    std::string target_ip_; ///< The IP address of the target UDP receiver.
+    int target_port_; ///< The UDP port number of the target receiver.
+    UdpQueue& input_queue_; ///< Reference to the queue providing detection results.
+    std::atomic<bool> running_ = false; ///< Atomic flag to control the sender's running state.
+    std::thread sender_thread_; ///< The main thread running the sender_thread_func.
+    int sockfd_ = -1; ///< The socket file descriptor for the UDP socket.
+    sockaddr_in server_addr_; ///< Structure holding the target server's address information.
 };
 
-#endif // UDP_SENDER_H
+#endif // UDP_SENDER_H
\ No newline at end of file
diff --git a/src/util_logging.cpp b/src/util_logging.cpp
index 8ac2ac9..21fe4be 100644
--- a/src/util_logging.cpp
+++ b/src/util_logging.cpp
@@ -1,34 +1,77 @@
-#include "util_logging.h"
-#include <iostream>
-#include <filesystem> // C++17 for creating directories
-#include <sstream>
-
-namespace fs = std::filesystem;
+/**
+ * @file util_logging.cpp
+ * @brief Implements a thread-safe, asynchronous logging utility for the application.
+ *
+ * This module provides a singleton Logger class that handles logging messages
+ * to both the console (stdout) and a file. It uses a separate writer thread
+ * to process log messages from a queue, minimizing the impact of logging
+ * operations on the main application threads. Logs are written in JSON format
+ * to a file with rotation capabilities.
+ */
 
+#include "util_logging.h"
+#include <iostream>       // For std::cout, std::cerr
+#include <filesystem>     // C++17 for creating directories
+#include <sstream>        // For std::ostringstream
+#include <iomanip>        // For std::put_time
+
+namespace fs = std::filesystem; ///< Alias for std::filesystem for brevity.
+
+/**
+ * @brief Retrieves the singleton instance of the Logger.
+ *
+ * This is the access point for the Logger. The instance is created upon the first
+ * call. Subsequent calls return the same instance.
+ *
+ * @param log_file_prefix The prefix for log filenames (e.g., "run").
+ * @param log_dir The directory where log files will be stored (e.g., "logs").
+ * @return A reference to the singleton Logger instance.
+ */
 Logger& Logger::getInstance(const std::string& log_file_prefix, const std::string& log_dir) {
     static Logger instance(log_file_prefix, log_dir);
     return instance;
 }
 
+/**
+ * @brief Constructor for the Logger.
+ *
+ * Initializes the Logger by ensuring the log directory exists, creating an
+ * initial log file, and starting the asynchronous writer thread.
+ *
+ * @param log_file_prefix The prefix for log filenames.
+ * @param log_dir The directory for log files.
+ */
 Logger::Logger(const std::string& log_file_prefix, const std::string& log_dir)
     : log_dir_(log_dir), log_file_prefix_(log_file_prefix), last_rotation_time_(std::chrono::system_clock::now()) {
     
-    // Ensure log directory exists
+    // Ensure log directory exists, create it if not.
     if (!fs::exists(log_dir_)) {
         fs::create_directories(log_dir_);
     }
     
-    rotate_log_file(); // Create initial log file
-    start_writer_thread();
+    rotate_log_file(); // Create the initial log file (e.g., run-YYYYMMDD-HHMMSS.json).
+    start_writer_thread(); // Begin processing log messages in a separate thread.
 }
 
+/**
+ * @brief Destructor for the Logger.
+ *
+ * Stops the writer thread and closes any open log file handles to ensure
+ * all buffered messages are written and resources are released.
+ */
 Logger::~Logger() {
-    stop_writer_thread();
+    stop_writer_thread(); // Signal writer thread to stop and wait for it.
     if (log_file_.is_open()) {
-        log_file_.close();
+        log_file_.close(); // Close the log file.
     }
 }
 
+/**
+ * @brief Starts the asynchronous writer thread.
+ *
+ * If the logger is not already running, this method launches a dedicated
+ * thread (`writer_thread_func`) to asynchronously write log messages.
+ */
 void Logger::start_writer_thread() {
     if (!running_) {
         running_ = true;
@@ -36,81 +79,133 @@ void Logger::start_writer_thread() {
     }
 }
 
+/**
+ * @brief Stops the asynchronous writer thread.
+ *
+ * Sets the `running_` flag to false, which signals the writer thread to
+ * exit its loop after processing any remaining messages in the queue.
+ * It then waits for the thread to join, ensuring a clean shutdown.
+ */
 void Logger::stop_writer_thread() {
     if (running_) {
-        running_ = false;
+        running_ = false; // Signal the thread to stop.
         if (writer_thread_.joinable()) {
-            writer_thread_.join();
+            writer_thread_.join(); // Wait for the thread to finish.
         }
     }
 }
 
+/**
+ * @brief Enqueues a standard log message to be written.
+ *
+ * This method is thread-safe. It adds a log entry to an internal queue,
+ * which is then processed by the writer thread.
+ *
+ * @param level The log level (e.g., "INFO", "WARNING", "ERROR").
+ * @param message The log message content.
+ */
 void Logger::log(const std::string& level, const std::string& message) {
-    std::lock_guard<std::mutex> lock(log_mutex_);
-    log_queue_.push({std::chrono::system_clock::now(), level, message});
+    std::lock_guard<std::mutex> lock(log_mutex_); // Protect queue access.
+    log_queue_.push({std::chrono::system_clock::now(), level, message}); // Enqueue the log entry.
 }
 
+/**
+ * @brief Enqueues a structured JSON log message.
+ *
+ * This method specifically formats a key-value pair into a simple JSON string
+ * and enqueues it with a "JSON" level.
+ *
+ * @param key The key for the JSON log entry.
+ * @param value The value for the JSON log entry (expected to be a valid JSON string or primitive).
+ */
 void Logger::log_json(const std::string& key, const std::string& value) {
-    std::lock_guard<std::mutex> lock(log_mutex_);
-    // For simplicity, we'll format this as a string for now.
-    // A more robust JSON logger would build a JSON object.
+    std::lock_guard<std::mutex> lock(log_mutex_); // Protect queue access.
+    // For simplicity, we'll format this as a string.
+    // A more robust JSON logger might use a dedicated JSON library.
     std::string json_message = "{\"" + key + "\": " + value + "}";
-    log_queue_.push({std::chrono::system_clock::now(), "JSON", json_message});
+    log_queue_.push({std::chrono::system_clock::now(), "JSON", json_message}); // Enqueue structured log.
 }
 
+/**
+ * @brief The main function for the asynchronous log writer thread.
+ *
+ * This thread continuously dequeues log entries from `log_queue_`, writes them
+ * to both the console and the log file in JSON format. It continues to run
+ * as long as `running_` is true or there are messages still in the queue.
+ */
 void Logger::writer_thread_func() {
+    // Continue running if explicitly enabled OR if there are still messages to process
     while (running_ || !log_queue_.empty()) {
         std::unique_lock<std::mutex> lock(log_mutex_);
+        // If the queue is empty, release the lock and sleep briefly to avoid busy-waiting.
         if (log_queue_.empty()) {
             lock.unlock();
-            std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Sleep if queue is empty
+            std::this_thread::sleep_for(std::chrono::milliseconds(100));
             continue;
         }
 
+        // Retrieve and remove the oldest log entry.
         LogEntry entry = log_queue_.front();
         log_queue_.pop();
-        lock.unlock();
+        lock.unlock(); // Release lock before writing to allow other threads to log.
 
-        // Write to console
+        // Write to console (standard output).
         std::cout << "[" << entry.level << "] " << entry.message << std::endl;
 
-        // Write to file (JSON format)
+        // Write to file in JSON format.
         if (log_file_.is_open()) {
+            // Escape special characters in message if necessary for proper JSON,
+            // but for simplicity, assuming message content is safe or will be escaped upstream.
             log_file_ << "{\"timestamp\":\"" << get_current_iso_time() << "\", \"level\":\"" << entry.level << "\", \"message\":\"" << entry.message << "\"}" << std::endl;
         }
         
-        // Basic log rotation (e.g., every hour or certain size)
-        // For now, let's just make sure a new file is created on startup.
-        // A more complex rotation logic would involve checking size/time and creating new files.
+        // Basic log rotation check. Currently, rotation only happens on startup.
+        // To implement runtime rotation (e.g., hourly or by size), this section
+        // would check `std::chrono::duration_cast<std::chrono::hours>(now - last_rotation_time_).count() > 1`
+        // or file size, and then call `rotate_log_file()`.
     }
 }
 
+/**
+ * @brief Rotates the log file by closing the current one and opening a new one.
+ *
+ * The new log file's name includes a timestamp to ensure uniqueness.
+ */
 void Logger::rotate_log_file() {
     if (log_file_.is_open()) {
-        log_file_.close();
+        log_file_.close(); // Close the old log file.
     }
     
+    // Generate a new filename with current timestamp.
     auto now = std::chrono::system_clock::now();
     std::time_t now_c = std::chrono::system_clock::to_time_t(now);
-    std::tm* now_tm = std::gmtime(&now_c); // Use gmtime for UTC
+    std::tm* now_tm = std::gmtime(&now_c); // Use gmtime for UTC time.
 
     std::ostringstream filename_ss;
     filename_ss << log_dir_ << "/" << log_file_prefix_ << "-"
                 << std::put_time(now_tm, "%Y%m%d-%H%M%S") << ".json";
     
+    // Open the new log file in append mode.
     log_file_.open(filename_ss.str(), std::ios_base::app);
     if (!log_file_.is_open()) {
         std::cerr << "Failed to open log file: " << filename_ss.str() << std::endl;
     }
-    last_rotation_time_ = now;
+    last_rotation_time_ = now; // Update the last rotation timestamp.
 }
 
+/**
+ * @brief Gets the current system time formatted as an ISO 8601 string.
+ *
+ * @return A string representing the current time in ISO 8601 format (e.g., "YYYY-MM-DDTHH:MM:SSZ").
+ */
 std::string Logger::get_current_iso_time() {
     auto now = std::chrono::system_clock::now();
     std::time_t now_c = std::chrono::system_clock::to_time_t(now);
-    std::tm* now_tm = std::gmtime(&now_c); // Use gmtime for UTC
+    // Note: std::put_time expects std::tm*, so we convert system_clock::time_point to std::tm.
+    // This example uses gmtime for UTC time. For local time, use std::localtime.
+    std::tm* now_tm = std::gmtime(&now_c); 
 
     std::ostringstream oss;
-    oss << std::put_time(now_tm, "%Y-%m-%dT%H:%M:%SZ");
+    oss << std::put_time(now_tm, "%Y-%m-%dT%H:%M:%SZ"); // Format as ISO 8601 with 'Z' for UTC.
     return oss.str();
-}
+}
\ No newline at end of file
diff --git a/src/util_logging.h b/src/util_logging.h
index 627ee58..3c7089b 100644
--- a/src/util_logging.h
+++ b/src/util_logging.h
@@ -1,59 +1,162 @@
+/**
+ * @file util_logging.h
+ * @brief Defines a thread-safe, asynchronous logging utility for the application.
+ *
+ * This header provides the Logger singleton class, which allows various modules
+ * to log messages with different severity levels (INFO, WARNING, ERROR) and
+ * also supports structured JSON logging. Messages are processed in a separate
+ * thread to minimize impact on application performance and are written to
+ * both the console and a timestamped JSON log file.
+ */
+
 #ifndef UTIL_LOGGING_H
 #define UTIL_LOGGING_H
 
 #include <string>
 #include <fstream>
-#include <mutex>
-#include <chrono>
-#include <queue>
-#include <thread>
-#include <atomic>
-#include <iomanip> // For std::put_time
-
-// Structure to hold a log entry
+#include <mutex>          // For std::mutex
+#include <chrono>         // For std::chrono::system_clock, time_point
+#include <queue>          // For std::queue<LogEntry>
+#include <thread>         // For std::thread
+#include <atomic>         // For std::atomic<bool>
+#include <iomanip>        // For std::put_time
+
+/**
+ * @brief Structure to hold a single log entry.
+ *
+ * Each log entry consists of a timestamp, severity level, and the message content.
+ */
 struct LogEntry {
-    std::chrono::system_clock::time_point timestamp;
-    std::string level;
-    std::string message;
+    std::chrono::system_clock::time_point timestamp; ///< The exact time the log entry was created.
+    std::string level;                               ///< The severity level of the log (e.g., "INFO", "WARNING", "ERROR", "JSON").
+    std::string message;                             ///< The actual message content to be logged.
 };
 
+/**
+ * @brief A singleton class for thread-safe, asynchronous logging.
+ *
+ * The Logger class ensures that only one instance exists throughout the application.
+ * It provides methods to enqueue log messages, which are then processed and written
+ * to console and a file by a dedicated background thread.
+ */
 class Logger {
 public:
+    /**
+     * @brief Retrieves the singleton instance of the Logger.
+     *
+     * This is the primary access point for the Logger. The instance is created
+     * upon the first call with default or provided parameters. Subsequent calls
+     * return the same instance.
+     *
+     * @param log_file_prefix The prefix for log filenames (e.g., "run").
+     * @param log_dir The directory where log files will be stored (e.g., "logs").
+     * @return A reference to the singleton Logger instance.
+     */
     static Logger& getInstance(const std::string& log_file_prefix = "run", const std::string& log_dir = "logs");
     
-    // Delete copy constructor and assignment operator for singleton
+    // Delete copy constructor and assignment operator to enforce singleton pattern.
     Logger(const Logger&) = delete;
     Logger& operator=(const Logger&) = delete;
 
+    /**
+     * @brief Enqueues a standard log message with a specified level.
+     *
+     * This method is thread-safe and non-blocking, as messages are added
+     * to a queue for asynchronous processing.
+     *
+     * @param level The severity level of the log message (e.g., "INFO", "WARNING", "ERROR").
+     * @param message The content of the log message.
+     */
     void log(const std::string& level, const std::string& message);
-    void log_json(const std::string& key, const std::string& value); // For specific JSON logs
 
+    /**
+     * @brief Enqueues a structured JSON log message.
+     *
+     * This method is used for logging key-value pairs, which are formatted
+     * into a simple JSON string before being enqueued.
+     *
+     * @param key The key for the JSON log entry.
+     * @param value The value for the JSON log entry (expected to be a JSON string or primitive).
+     */
+    void log_json(const std::string& key, const std::string& value);
+
+    /**
+     * @brief Starts the asynchronous writer thread.
+     *
+     * If the logger is not already running, this method launches the background
+     * thread responsible for writing log messages to their destinations.
+     */
     void start_writer_thread();
+
+    /**
+     * @brief Stops the asynchronous writer thread.
+     *
+     * Gracefully signals the writer thread to terminate and waits for it to
+     * finish processing any remaining log messages in the queue.
+     */
     void stop_writer_thread();
 
 private:
+    /**
+     * @brief Private constructor for the Logger (singleton pattern).
+     *
+     * Initializes the log directory, file prefix, and sets up the initial
+     * log file.
+     *
+     * @param log_file_prefix The prefix for log filenames.
+     * @param log_dir The directory for log files.
+     */
     Logger(const std::string& log_file_prefix, const std::string& log_dir);
+
+    /**
+     * @brief Private destructor for the Logger.
+     *
+     * Ensures proper shutdown of the writer thread and closes the log file.
+     */
     ~Logger();
 
+    /**
+     * @brief The main function executed by the asynchronous writer thread.
+     *
+     * This thread continuously dequeues log entries and writes them to the
+     * console and the log file.
+     */
     void writer_thread_func();
+
+    /**
+     * @brief Rotates the log file.
+     *
+     * Closes the current log file and opens a new one with a timestamped name.
+     */
     void rotate_log_file();
+
+    /**
+     * @brief Gets the current system time formatted as an ISO 8601 string.
+     *
+     * @return A string representing the current time in ISO 8601 format.
+     */
     std::string get_current_iso_time();
 
-    std::string log_dir_;
-    std::string log_file_prefix_;
-    std::ofstream log_file_;
-    std::mutex log_mutex_;
-    std::queue<LogEntry> log_queue_;
-    std::thread writer_thread_;
-    std::atomic<bool> running_ = false;
-    std::chrono::system_clock::time_point last_rotation_time_;
+    std::string log_dir_;                        ///< The directory where log files are stored.
+    std::string log_file_prefix_;                ///< The prefix used for log filenames.
+    std::ofstream log_file_;                     ///< Output file stream for logging to a file.
+    std::mutex log_mutex_;                       ///< Mutex to protect access to the log queue.
+    std::queue<LogEntry> log_queue_;             ///< Queue for asynchronous log message processing.
+    std::thread writer_thread_;                  ///< Dedicated thread for writing log messages.
+    std::atomic<bool> running_ = false;          ///< Atomic flag to control the writer thread's running state.
+    std::chrono::system_clock::time_point last_rotation_time_; ///< Timestamp of the last log file rotation.
 };
 
-// Global logging macros for convenience
+// --- Global Logging Macros for Convenience ---
+
+/// @brief Logs an informational message.
 #define LOG_INFO(msg) Logger::getInstance().log("INFO", msg)
+/// @brief Logs a warning message.
 #define LOG_WARNING(msg) Logger::getInstance().log("WARNING", msg)
+/// @brief Logs an error message.
 #define LOG_ERROR(msg) Logger::getInstance().log("ERROR", msg)
+/// @brief Logs a structured JSON message.
 #define LOG_JSON(key, value) Logger::getInstance().log_json(key, value)
 
 
-#endif // UTIL_LOGGING_H
+#endif // UTIL_LOGGING_H
\ No newline at end of file
