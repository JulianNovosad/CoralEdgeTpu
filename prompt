**PRIMARY OBJECTIVE:** Develop a native C++ inference application (`tpu_consumer`) that **demonstrably** uses the Edge TPU API correctly, with every struct, function, and parameter justified by direct header analysis and peer-reviewed examples. **NON-NEGOTIABLE REQUIREMENTS:** 1. **API Introspection First**: Before building, parse and document every touched header file. 2. **Struct/Field Citation**: Every patch must cite: `header:line` + field meaning + why it's mandatory. 3. **Example Provenance**: Every API usage pattern must be traced to ≥1 internet example or official doc. 4. **No Blind Patching**: If you don't understand a symbol, you MUST read its definition before using it. --- ## 1. PHASE -1: API DISCOVERY & DOCUMENTATION (MANDATORY) ### 1.1. Header Discovery Script ```bash #!/bin/bash # discover_api.sh set -e API_MANIFEST="/workspace/api_manifest.json" HEADERS=$(find /workspace -name "*.h" -exec grep -l "edgetpu\|tflite\|gasket\|apex" {} \;) echo '{"headers":[]}' > $API_MANIFEST for HEADER in $HEADERS; do STRUCTS=$(grep -n "struct.*{\" "$HEADER" | awk -F: '{print $1":"$2}') FUNCTIONS=$(grep -n "^[a-zA-Z_].*(\" "$HEADER" | awk -F: '{print $1":"$2}') jq --arg file "$HEADER" \ --arg structs "$STRUCTS" \ --arg funcs "$FUNCTIONS" \ '.headers += [{"file":$file,"structs":($structs|split("\n")),"functions":($funcs|split("\n"))}]' \ $API_MANIFEST > ${API_MANIFEST}.tmp && mv ${API_MANIFEST}.tmp $API_MANIFEST done cat $API_MANIFEST ``` **Rule**: Do not proceed to Phase 0 until `api_manifest.json` is populated with ≥5 relevant headers. ### 1.2. Struct Analyzer ```bash #!/bin/bash # analyze_struct.sh # Usage: ./analyze_struct.sh /workspace/libedgetpu/edgetpu.h EdgeTpuContext HEADER=$1 STRUCT=$2 OUTPUT="/workspace/api_reference/${STRUCT}.json" mkdir -p /workspace/api_reference # Extract struct definition with 10 lines after "struct $STRUCT" sed -n "/struct $STRUCT/,/^};/p" "$HEADER" > /tmp/struct_def.txt # Parse fields (naive but effective) grep -n ".*;\" "/tmp/struct_def.txt | grep -v "//" > /tmp/fields.txt python3 <<PY import json, re fields = [] with open("/tmp/fields.txt") as f: for line in f: line_num, decl = line.split(":", 1) # Remove struct/ noise field = re.sub(r'(struct|enum|class|\s+)', ' ', decl).strip() if field: fields.append({"line": int(line_num), "declaration": field}) json.dump({"struct": "$STRUCT", "header": "$HEADER", "fields": fields}, open("$OUTPUT", "w")) PY cat $OUTPUT ``` ### 1.3. Internet Example Miner ```python #!/usr/bin/env python3 # mine_examples.py import requests, re, json, os, sys def mine_github_examples(function_name, repo="google-coral/edgetpu"): """Fetch code examples from GitHub search API""" url = f"https://api.github.com/search/code?q= {function_name}+repo:{repo}" # Note: Requires GITHUB_TOKEN env var token = os.getenv('GITHUB_TOKEN') headers = {"Authorization": f"token {token}"} if token else {} resp = requests.get(url, headers=headers) examples = [] for item in resp.json().get("items", [])[:3]: raw_url = item["html_url"].replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/") code = requests.get(raw_url).text # Extract usage snippet snippet = re.search(rf".*?{function_name}.*?", code, re.MULTILINE) examples.append({ "source": item["html_url"], "snippet": snippet.group(0) if snippet else "N/A" }) return examples if __name__ == "__main__": if len(sys.argv) < 2: print("Usage: python mine_examples.py <function_name>") sys.exit(1) func = sys.argv[1] print(json.dumps(mine_github_examples(func), indent=2)) ``` **Rule**: Before using any API function, you MUST run `./mine_examples.py FunctionName` and cite the source URL in your patch. --- ## 2. EXPANDED EVIDENCE FRAMEWORK ### 2.1. API Evidence Layer (NEW - Priority 0) **Stronger than Primary Evidence**: Direct header analysis and example provenance. - **Header Evidence**: `/workspace/api_reference/StructName.json` showing field definitions - **Example Evidence**: GitHub URL + snippet demonstrating usage pattern - **Justification Evidence**: Explanation of *why* this field is mandatory (e.g., "Field `device_path` is required because `edgetpu.h:89` shows no default initializer and `apex_driver.c:234` dereferences it without null-check") ### 2.2. Patch Justification Template (MANDATORY) Every patch file must have a sidecar `.justification.yaml`: ```yaml # patches/EXP-006-dtb.diff.justification.yaml api_symbols_used: - symbol: "msi_ranges" header: "/workspace/linux-source/drivers/pci/host/pci-host-common.h:45" field: "struct pci_host_msi_config.msi_ranges" justification: "Increasing msi_ranges from 8 to 32 allows more MSI-X vectors per TPU core, as documented in bcm2712-pcie.yaml:12" example_source: "https://github.com/raspberrypi/linux/blob/rpi-6.12.x/arch/arm/boot/dts/bcm2712.dtsi#L123 " confidence: 9 safety_review: - action: "Modified /boot/firmware/bcm2712-rpi-5-b.dtb" backup_created: "/boot/firmware/bcm2712-rpi-5-b.dtb.backup.EXP-006" rollback_command: "sudo cp /boot/firmware/bcm2712-rpi-5-b.dtb.backup.EXP-006 /boot/firmware/bcm2712-rpi-5-b.dtb" ip_review: - modified_file: "drivers/staging/apex/apex_driver.c" license: "GPL-2.0" copyright_held_by: "Google LLC" rationale: "Patch conforms to GPL-2.0; changes are minimal and for hardware compatibility" ``` --- ## 3. MODIFIED ORCHESTRATOR LOOP (HGE with API Awareness) ### 3.1. HGE v2: API-First Reasoning When triggered, HGE must: 1. **Parse Failure**: Read build log, extract undefined symbol (e.g., `EdgeTpuDelegate`) 2. **Locate Definition**: `grep -rn "EdgeTpuDelegate" /workspace/libedgetpu/src/` 3. **Analyze Header**: `./analyze_struct.sh /workspace/libedgetpu/edgetpu.h EdgeTpuDelegate` 4. **Mine Examples**: `./mine_examples.py EdgeTpuDelegate` 5. **Generate Justification**: Create hypothesis linking the symbol to struct fields + example patterns 6. **Output**: Full experiment declaration + justification.yaml template ### 3.2. Experiment Dependency on API Knowledge ```yaml # experiments.yaml experiments: EXP-010: depends_on: "EXP-009" # Kernel modules loaded requires_api_knowledge: ["EdgeTpuContext", "InterpreterBuilder", "EdgetpuDelegate"] pre_experiment_action: "analyze_api_symbols.sh EdgeTpuContext InterpreterBuilder EdgetpuDelegate" action: "make -C src tpu_consumer" prediction: header_evidence: "/workspace/api_reference/EdgeTpuContext.json exists" example_evidence: "/workspace/examples/InterpreterBuilder.json exists" build_output: "tpu_consumer linked successfully" runtime_evidence: "IVT shows DMA transactions" ``` --- ## 4. END-TO-END INFERENCE VALIDATION (IVT) - ENHANCED ### 4.1. IVT with API Justification ```bash # /workspace/scripts/ivt.sh #!/bin/bash # Inference Validation Test with API proof MODEL="/workspace/models/mobilenet_v2_1.0_224_quant_edgetpu.tflite" IMAGE="/workspace/test_data/cat.jpg" echo "=== API Justification Check ===" grep -r "EdgeTpuContext" /workspace/api_reference/ || { echo "FAIL: No API analysis"; exit 1; } grep -r "InterpreterBuilder" /workspace/examples/ || { echo "FAIL: No example provenance"; exit 1; } echo "=== Running Inference ===" ./src/tpu_consumer --model $MODEL --image $IMAGE --iterations 10 > /tmp/ivt.log 2>&1 echo "=== API Usage Verification ===" # Verify we actually called the right functions nm -u src/tpu_consumer | grep -i edgetpu || { echo "FAIL: No Edge TPU symbols"; exit 1; } echo "=== Performance & Correctness ===" grep -q "Top-1: tabby cat" /tmp/ivt.log || { echo "FAIL: Wrong classification"; exit 1; } AVG_LATENCY=$(grep "Avg latency" /tmp/ivt.log | awk '{print $3}') (( $(echo "$AVG_LATENCY < 100" | bc -l) )) || { echo "FAIL: Too slow"; exit 1; } echo "=== TPU Activation Proof ===" dmesg | grep -q "apex: DMA transaction" || { echo "FAIL: No TPU usage"; exit 1; } echo "SUCCESS: All IVT checks passed" ``` --- ## 5. PHASE 4: API-VALIDATED INTEGRATION (NEW) ### Phase 4.1: API Documentation Synthesis **Goal**: Create human-readable API docs from parsed headers. ```bash # Action: For each API symbol used, generate: /workspace/api_docs/EdgeTpuContext.md: """ ## EdgeTpuContext (edgetpu.h:123) ### Fields: - `device_path` (const char*): Path to /dev/apex_0 node. **Mandatory** - no null-check in driver. - *Example from*: https://github.com/google-coral/edgetpu/blob/.../examples/minimal.cc:45 - `verbosity` (int): Logging level. **Optional** - defaults to 0 if unset. - *Caution*: Setting >2 causes kernel spam (see dmesg log from EXP-003). """ ``` ### Phase 4.2: Build with API Verification **Action**: Compiler flags must include `-Werror=implicit` to force header inclusion errors. **Prediction**: Build fails if any API struct is used without its full definition being parsed. ### Phase 4.3: Runtime API Validation **Action**: Use `LD_DEBUG=libs ./tpu_consumer` to verify `libedgetpu.so` is loaded from correct path. **Prediction**: `LD_DEBUG` output shows `libedgetpu.so.1 => /workspace/install/lib/libedgetpu.so.1` --- ## 6. AUTOMATED EVIDENCE PROTOCOL (AEP) - API-AWARE ### 6.1. Extended Evidence Collection ```bash # In run_aep.sh # After static/dynamic collection, also collect: # API Evidence if [ -f "/workspace/api_reference/${SYMBOL}.json" ]; then cp "/workspace/api_reference/${SYMBOL}.json" "$EVIDENCE_DIR/api_symbol.json" fi # Example Evidence if [ -f "/workspace/examples/${FUNCTION}.json" ]; then cp "/workspace/examples/${FUNCTION}.json" "$EVIDENCE_DIR/api_example.json" fi # Justification Evidence [ -f "${PATCH%.diff}.justification.yaml" ] && cp "${PATCH%.diff}.justification.yaml" "$EVIDENCE_DIR/" ``` ### 6.2. API-Centric Comparison Logic ```bash # Check API evidence exists if [ -n "$PREDICT_API_SYMBOL" ]; then if ! [ -f "$EVIDENCE_DIR/api_symbol.json" ]; then echo "FAIL: API symbol analysis missing" >> $EVIDENCE_DIR/ROLLBACK_TRIGGERED fi fi # Check example provenance if [ -n "$PREDICT_EXAMPLE_URL" ]; then if ! grep -q "$PREDICT_EXAMPLE_URL" "$EVIDENCE_DIR/api_example.json"; then echo "FAIL: Example source not cited" >> $EVIDENCE_DIR/ROLLBACK_TRIGGERED fi fi ``` --- ## 7. DELIVERABLES (API-DOCUMENTED) ### 7.1. Final Reproduce Script ```bash #!/bin/bash # reproduce.sh - Generated after IVT PASS set -e # API Reference Generation (for human review) echo "=== Generating API Documentation ===" python3 /workspace/scripts/generate_api_docs.py echo "=== API-Validated Build ===" # Every build step preceded by API justification check make -C src verify_api_docs || { echo "API docs missing"; exit 1; } make -C src make -C src run_ivt echo "SUCCESS: Native C++ inference validated with complete API documentation" ``` ### 7.2. Patch Manifest with API Citations Every patch must include: ```yaml # patches/EXP-042-use_edgetpu_delegate.diff.meta.yaml api_analysis: - function: "TfLiteInterpreterOptionsSetBufferHandleAllocator" header: "/workspace/tensorflow/tensorflow/lite/c/c_api.h:567" justification: "This function is required to register the Edge TPU as a buffer allocator. Without it, the interpreter defaults to CPU memory allocator." example_source: "https://github.com/tensorflow/tensorflow/blob/v2.16.1/tensorflow/lite/examples/label_image/label_image.cc#L234 " lines_modified: ["src/tpu_consumer.cc:89-92"] validation: - build: "links without undefined symbols" - runtime: "IVT shows DMA transactions" - api_call: "strace shows ioctl(EDGETPU_IOC_ALLOC)" ``` --- ## 8. TERMINATION & SUCCESS CRITERIA **System is SUCCESS when:** 1. `tpu_consumer` compiles with `-Werror=implicit` (proves all headers read) 2. `ivt.sh` passes with: - Correct classification (e.g., "tabby cat") - Latency <100ms - ≥1 DMA transaction in dmesg 3. `api_docs/` contains documentation for **every** API symbol used 4. Every patch in `./patches/` has a `.justification.yaml` citing headers and examples 5. `reproduce.sh` executes a full API-validated build without errors **LOCK if:** - 3 consecutive experiments fail due to "missing API analysis" - Agent attempts to patch without first running `discover_api.sh` - No new API knowledge gained in 5 consecutive iterations (stall detection) --- ## 9. MANDATORY BOOTSTRAP ```bash # 1. On Raspberry Pi with root access: cd /workspace git clone https://github.com/google-coral/edgetpu git clone https://github.com/tensorflow/tensorflow -b v2.16.1 # 2. Run API discovery: ./agent_core_scripts/discover_api.sh ./agent_core_scripts/analyze_struct.sh tensorflow/tensorflow/lite/interpreter.h Interpreter ./agent_core_scripts/mine_examples.py InterpreterBuilder # 3. Verify API manifest: jq '.headers | length' api_manifest.json # Must be ≥5 # 4. Start orchestrator: python3 orchestrator.py --mode=api-first ```
